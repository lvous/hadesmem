[article HadesMem
  [quickbook 1.5]
  [version 0.0.0]
  [copyright 2011 Joshua Boyce (aka RaptorFactor)]
  [authors [Boyce, Joshua]]
  [license Distributed under the GNU GPL v3. See accompanying file 
    LICENSE.txt.]
]

[section:overview Overview]

[h3 Introduction]

HadesMem is a C++-based memory hacking library for Windows based 
applications, with the goal of providing a safe, generic, powerful, and 
efficient API. All components are useable on remote targets. Furthermore, all 
components compile for (and work natively on) both IA32 and AMD64.

[h3 Design]

HadesMem's design is built around the `HadesMem::MemoryMgr` class, which 
provides all the basic and critical functionality required for the other 
components to be implemented.

In terms of language usage, the library aims to exploit modern C++ as much as 
possible, both to ease implementation, and to make library use as easy and as 
error-safe as possible.

[h3 Error Handling]

Exceptions are typically favoured over error codes. The rationale for this 
is that memory hacking is quite 'unsable' by nature, and most use cases favour 
grouping operations in an 'all or nothing' fashion. By using exceptions, the 
amount of boilerplate code required to use the library is significantly 
reduced.

Exceptions in HadesMem are all derived from `HadesMem::HadesMemError`, 
which in turn is derived from both `std::exception` and `boost::exception`. 
Internally, exceptions are built and thrown using the 
[@http://www.boost.org/doc/libs/release/libs/exception/doc/boost-exception.html 
Boost.Exception] libary. When dealing with HadesMem exceptions it is 
recommended to use this library, as very little information is available from 
the `std::exception` interface, or the exception class type.

The tag types commonly used in exceptions thrown by HadesMem are:

* `HadesMem::ErrorFunction` - A `std::string` naming the function the 
exception was thrown from.
* `HadesMem::ErrorString` - A `std::string` describing the problem.
* `HadesMem::ErrorCodeWinRet` - A `DWORD_PTR` containing the return value of 
the Windows API which failed.
* `HadesMem::ErrorCodeWinLast` - A `DWORD` containing the Windows LastError 
code.
* `HadesMem::ErrorCodeWinOther` - A `DWORD_PTR` containing any other relevant 
Windows error codes or return values.
* `HadesMem::ErrorCodeOther` - A `DWORD_PTR` containing miscellaneous error 
codes.

All functions in HadesMem should be considered to throw unless otherwise 
stated in the documentation. Furthermore, all function in HadesMem should 
be considered to offer only the 'basic guarantee' unless otherwise stated 
in the documentation. Work is currently underway to offer the strong or 
no-throw guarantee wherever possible, but is not yet complete.

Libraries used by HadesMem may also throw exceptions (notably Boost and the 
C++ Standard Library). In most cases, no attempt is made by HadesMem to 
suppress or 'translate' these exceptions.

[h3 Threading]

Currently no guarantees are made that multiple threads accessing the same 
HadesMem object will work. Typically it should, but until each function is 
reviewed and documented it is recommended to synchronise access to shared 
objects. Work is currently underway to improve the threading guarantees 
offered by the library, but it is not yet complete.

[h3 Support]

Please direct all bug reports and/or feature requests to the issue tracker on 
the [@http://code.google.com/p/hadesmem/ project page]. If you have something 
you would like to discuss in private, or if you have a relatively advanced 
question about the library that can't be answered by looking at the 
documentation or code, I can be reached via email at 
raptorfactor@raptorfactor.com.

[endsect] [/ Overview]

[section:lic License]

This file is part of HadesMem.

HadesMem is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

HadesMem is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HadesMem.  If not, see [@http://www.gnu.org/licenses/].

[endsect] [/ License]

[section:changes Changes]

Nothing to see here yet.

[endsect] [/ Changes]

[section:building Building]

HadesMem uses the [@http://www.boost.org/boost-build2/ Boost.Build] build 
system. If you have not already, it is recommend you familiarize yourself 
with this framework.

Supported Compilers:

* [@http://www.microsoft.com/visualstudio/en-us Microsoft Visual C++ 2010] 
(Express edition not officially supported)
* [@http://gcc.gnu.org/ GNU GCC 4.6.0] (via 
[@http://www.equation.com/servlet/equation.cmd?fa=fortran MinGW-w64])

Supported Platforms:

* [@http://www.microsoft.com/windows/ Microsoft Windows] (Windows XP SP2 or 
later)

Steps to Build:

# Build Boost.
  # Navigate to Build/Boost.
  # Run Bootstrap.bat.
  # Run Build_Compiler.bat (Substitute 'Compiler' as appropriate).
  # Check output and ensure there are no errors.
# Build HadesMem.
  # Navigate to Build/Full.
  # Run Build_Compiler_Configuration_Architecture.bat (Substitute 'Compiler', 
  'Configuration', and 'Architecture' as appropriate).
  # Check output and ensure there are no errors.
  
Using HadesMem (in a Boost.Build based project):

# Add a /use-project/ directive to your Jamroot targeting HadesMem (this 
document assumes you name the project 'HadesMem').
# Add '''/HadesMem//Memory''' to the source list of your application/library 
or the requirements list of your project.
# Add `#include <HadesMemory/Memory.hpp>` to your code.

[endsect] [/ Building]

[section:reference Reference]

[section:memorymgr MemoryMgr]

[h3 Synopsis]

  // In header: <HadesMemory/MemoryMgr.hpp>

  class MemoryMgr
  {
  public:
    class Error : public virtual HadesMemError 
    { };

    explicit MemoryMgr(DWORD ProcID);

    class RemoteFunctionRet
    {
    public:
      DWORD_PTR GetReturnValue() const;
      
      DWORD64 GetReturnValue64() const;
      
      DWORD GetLastError() const;
    };
  
    enum CallConv
    {
      CallConv_Default, 
      CallConv_CDECL, 
      CallConv_STDCALL, 
      CallConv_THISCALL, 
      CallConv_FASTCALL, 
      CallConv_X64
    };

    RemoteFunctionRet Call(LPCVOID Address, CallConv MyCallConv, 
      std::vector<PVOID> const& Args) const;

    template <typename T>
    T Read(PVOID Address, unspecified = 0) const;

    template <typename T>
    T ReadString(PVOID Address, unspecified = 0) const;

    template <typename T>
    T ReadList(PVOID Address, std::size_t Size, unspecified = 0) const;

    template <typename T>
    void Write(PVOID Address, T const& Data, unspecified = 0) const;

    template <typename T>
    void WriteString(PVOID Address, T const& Data, unspecified = 0) const;

    template <typename T>
    void WriteList(PVOID Address, T const& Data, unspecified = 0) const;

    bool CanRead(LPCVOID Address) const;

    bool CanWrite(LPCVOID Address) const;

    bool IsGuard(LPCVOID Address) const;
    
    DWORD ProtectRegion(LPVOID Address, DWORD Protect) const;

    PVOID Alloc(SIZE_T Size) const;

    void Free(PVOID Address) const;

    FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
      std::wstring const& Module, std::string const& Function) const;

    FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
      std::wstring const& Module, WORD Function) const;

    void FlushCache(LPCVOID Address, SIZE_T Size) const;

    DWORD GetProcessId() const;

    HANDLE GetProcessHandle() const;
    
    std::wstring GetProcessPath() const;
    
    bool IsProcessWoW64() const;
  };
  
  MemoryMgr CreateProcess(std::wstring const& Path, 
    std::wstring const& Params, 
    std::wstring const& WorkingDir);
  
  void GetSeDebugPrivilege();

  class AllocAndFree
  {
  public:
    AllocAndFree(MemoryMgr const& MyMemoryMgr, SIZE_T Size);

    ~AllocAndFree();
    
    void Free() const;

    PVOID GetBase() const;
    
    SIZE_T GetSize() const;

  protected:
    AllocAndFree(AllocAndFree const&);
    AllocAndFree& operator=(AllocAndFree const&);
  };

[h3 Description]

The MemoryMgr class provides the most basic memory hacking functionality, and 
is the basis on which all other HadesMem components are built.

Free functions are provided for other common basic operations which are not 
specific to a remote process.

The AllocAndFree class is an RAII wrapper for remote memory allocation.

[h3 MemoryMgr public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `MemoryMgr` methods when an error occurs.

  class RemoteFunctionRet;

Type containing the return information of a remote function call. Exposes 
integer and thread-local return values. Floating point return information 
is currently unsupported. See `RemoteFunctionRet' documentation for more 
information.

  enum CallConv;

Calling conventions for remote function caller. All calling conventions follow 
Microsoft specifications. Other compilers and custom calling conventions are 
currently unsupported.

* CallConv_Default - Default calling convention. Equivalent to 
`CallConv_STDCALL` on x86 and `CallConv_X64` on x64.
* CallConv_CDECL - [@http://msdn.microsoft.com/en-us/library/zkwh89ks.aspx 
__cdecl] calling convention.
* CallConv_STDCALL - [@http://msdn.microsoft.com/en-us/library/zxk0tw93.aspx 
__stdcall] calling convention.
* CallConv_THISCALL - [@http://msdn.microsoft.com/en-us/library/ek8tkfbw.aspx 
__thiscall] calling convention.
* CallConv_FASTCALL - [@http://msdn.microsoft.com/en-us/library/6xa169sk.aspx 
__fastcall] calling convention.
* CallConv_X64 - [@http://msdn.microsoft.com/en-us/library/ms235286.aspx x64] 
calling convention.

[h3 MemoryMgr public construct/copy/destruct/move]

[h4 MemoryMgr process ID constructor]

  explicit MemoryMgr(DWORD ProcID);

[variablelist

[[Effects:] [Constructs a `MemoryMgr` instance that refers to the specified 
process.]]

[[Throws:] [Yes.]]

]

[h3 MemoryMgr public member functions]

[h4 MemoryMgr member function `Call`]

  RemoteFunctionRet Call(LPCVOID Address, CallConv MyCallConv, 
    std::vector<PVOID> const& Args) const;

[variablelist

[[Effects:] [Calls a function at `Address`, using calling convention 
`MyCallConv`, with the arguments `Args`.]]

[[Returns:] [A `RemoteFunctionRet` instance.]]

[[Throws:] [Yes.]]

[[Notes:] [All arguments must be equivalent to integer arguments, with a size 
equal to or less than the native pointer size of the platform. Floating point 
arguments are unsupported.]]

]

[h4 MemoryMgr member function `Read`]

  template <typename T>
  T Read(PVOID Address, unspecified = 0) const;

[variablelist

[[Returns:] [Instance of type `T` constructed from memory at `Address`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be a POD type.]]

]

[h4 MemoryMgr member function `ReadString`]

  template <typename T>
  T ReadString(PVOID Address, unspecified = 0) const;

[variablelist

[[Returns:] [Instance of type `T` constructed from memory at `Address`. Reads 
individual characters until a null is encountered.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be of type `std::basic_string<CharT>`, where `CharT` is a 
POD character type. String is read as if it is a C-style character array.]]

]

[h4 MemoryMgr member function `ReadList`]

  template <typename T>
  T ReadList(PVOID Address, std::size_t Size, unspecified = 0) const;

[variablelist

[[Returns:] [Instance of type `T` constructed from memory at `Address`. Reads 
`Size` items from `Address` and stores them in a `T`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be of type `std::vector<U>`, where `U` is a POD type. 
List is read as if it is a C-style array.]]

]

[h4 MemoryMgr member function `Write`]

  template <typename T>
  void Write(PVOID Address, T const& Data, unspecified = 0) const;

[variablelist

[[Effects:] [Writes `Data` to `Address`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be a POD type.]]

]

[h4 MemoryMgr member function `WriteString`]

  template <typename T>
  void WriteString(PVOID Address, T const& Data, unspecified = 0) const;

[variablelist

[[Effects:] [Writes `Data` to `Address`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be of type `std::basic_string<CharT>`, where `CharT` is a 
POD character type. `Data` is written as a C-style character array.]]

]

[h4 MemoryMgr member function `WriteList`]

  template <typename T>
  void WriteList(PVOID Address, T const& Data, unspecified = 0) const;

[variablelist

[[Effects:] [Writes `Data` to `Address`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be of type `std::vector<U>`, where `U` is a POD type. 
`Data` is written as a C-style array.]]

]

[h4 MemoryMgr member function `CanRead`]

  bool CanRead(LPCVOID Address) const;

[variablelist

[[Returns:] [Whether memory region at `Address` is readable.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `CanWrite`]

  bool CanWrite(LPCVOID Address) const;

[variablelist

[[Returns:] [Whether memory region at `Address` is writable.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `CanExecute`]

  bool CanExecute(LPCVOID Address) const;

[variablelist

[[Returns:] [Whether memory region at `Address` is executable.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `IsGuard`]

  bool IsGuard(LPCVOID Address) const;

[variablelist

[[Returns:] [Whether memory region at `Address` is a guard page.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `ProtectRegion`]

  DWORD ProtectRegion(LPVOID Address, DWORD Protect) const;

[variablelist

[[Effects:] [Protect memory region at `Address` with protection `Protect`.]]

[[Returns:] [Previous protection at `Address`.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `Alloc`]

  PVOID Alloc(SIZE_T Size) const;

[variablelist

[[Effects:] [Allocate memory region with size `Size`.]]

[[Returns:] [Base address of memory region.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `Free`]

  void Free(PVOID Address) const;

[variablelist

[[Effects:] [Free memory region at address `Address`.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `GetRemoteProcAddress`]

  FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
    std::wstring const& Module, std::string const& Function) const;

  FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
    std::wstring const& Module, WORD Function) const;

[variablelist

[[Effects:] [Looks up function `Function` (either by name or ordinal) with 
module path `Module` at module base `RemoteMod`. Similar to `GetProcAddress` 
Windows API.]]

[[Returns:] [Address of function.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `FlushCache`]

  void FlushCache(LPCVOID Address, SIZE_T Size) const;

[variablelist

[[Effects:] [Flush instruction cache at address `Address` with size `Size`.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `GetProcessId`]

  DWORD GetProcessId() const;

[variablelist

[[Returns:] [Process ID of target.]]

[[Throws:] [No.]]

]

[h4 MemoryMgr member function `GetProcessHandle`]

  HANDLE GetProcessHandle() const;

[variablelist

[[Returns:] [Process handle to target.]]

[[Throws:] [No.]]

]

[h4 MemoryMgr member function `GetProcessPath`]

  std::wstring GetProcessPath() const;

[variablelist

[[Returns:] [Path to target.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `IsProcessWoW64`]

  bool IsProcessWoW64() const;

[variablelist

[[Returns:] [Whether process is running under WoW64.]]

[[Throws:] [No.]]

]

[h3 Free functions]

[h4 Free function `CreateProcess`]

  MemoryMgr CreateProcess(std::wstring const& Path, 
    std::wstring const& Params, 
    std::wstring const& WorkingDir);

[variablelist

[[Effects:] [Create process from binary at `Path` with optional parameters 
`Params` and optional working dir `WorkingDir`.]]

[[Returns:] [Memory manager instance for new process.]]

[[Throws:] [Yes.]]

]

[h4 Free function `GetSeDebugPrivilege`]
  
  void GetSeDebugPrivilege();

[variablelist

[[Effects:] [Sets the [@http://msdn.microsoft.com/en-us/library/bb530716.aspx 
SeDebugPrivilege] on the calling process.]]

[[Throws:] [Yes.]]

[[Notes:] [Requires the caller to be running with administrator 
credentials.]]

]

[h3 AllocAndFree public construct/copy/destruct/move]

[h4 AllocAndFree constructor]

  AllocAndFree(MemoryMgr const& MyMemoryMgr, SIZE_T Size);

[variablelist

[[Effects:] [Allocates memory block of size `Size` using the `MemoryMgr` 
object `MyMemoryMgr`.]]

[[Throws:] [Yes.]]

]

[h4 AllocAndFree destructor]

  ~AllocAndFree();

[variablelist

[[Effects:] [Frees the remote memory block (unless already freed manually).]]

[[Throws:] [No. Exceptions thrown when freeing the memor will be swallowed.]]

]

[h3 AllocAndFree public member functions]

[h4 AllocAndFree member function `Free`]

  void Free() const;

[variablelist

[[Effects:] [Frees the remote memory block (unless already freed manually).]]

[[Throws:] [Yes.]]

]

[h4 AllocAndFree member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of remote memory block.]]

[[Throws:] [No.]]

]

[h4 AllocAndFree member function `GetSize`]

  SIZE_T GetSize() const;

[variablelist

[[Returns:] [Size of remote memory block.]]

[[Throws:] [No.]]

]

[h3 MemoryMgr::RemoteFunctionRet public member functions]

[h4 MemoryMgr::RemoteFunctionRet member function `GetReturnValue`]

    DWORD_PTR GetReturnValue() const;

[variablelist

[[Returns:] [The integer return value for the remote function in the native 
pointer size for the platform.]]

[[Throws:] [No.]]

]

[h4 MemoryMgr::RemoteFunctionRet member function `GetReturnValue64`]

    DWORD64 GetReturnValue64() const;

[variablelist

[[Returns:] [The 64-bit integer return value for the remote function.]]

[[Throws:] [No.]]

[[Notes:] [Same as GetReturnValue on x64.]]

]

[h4 MemoryMgr::RemoteFunctionRet member function `GetLastError`]

    DWORD GetLastError() const;

[variablelist

[[Returns:] [The last error code for the remote function. Equivalent to 
calling the Windows API `GetLastError` in the context of the target process 
after the function call.]]

[[Throws:] [No.]]

]

[endsect] [/ MemoryMgr]

[endsect] [/ Reference]

[section:acknowledge Acknowledgements]

HadesMem would not be possible without the help of the following projects:

* [@http://code.google.com/p/asmjit/ AsmJit] - C++ Library
* [@http://www.beaengine.org/ BeaEngine] - C Library
* [@http://www.boost.org/ Boost] - C++ Libraries
* [@http://www.mmowned.com/forums/members/299012-xel.html Xel @ MMOwned] - Logo

[endsect] [/ Acknowledgements]
