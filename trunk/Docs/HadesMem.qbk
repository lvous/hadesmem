[article HadesMem
  [quickbook 1.5]
  [version 0.0.0]
  [copyright 2011 Joshua Boyce (aka RaptorFactor)]
  [authors [Boyce, Joshua]]
  [license Distributed under the GNU GPL v3. See accompanying file 
    LICENSE.txt.]
]

[section:intro Introduction]

HadesMem is a C++-based memory hacking library for Windows based 
applications, with the goal of providing a safe, generic, powerful, and 
efficient API. All components are useable on remote targets. Furthermore, all 
components compile for (and work natively on) both IA32 and AMD64.

[endsect] [/ Introduction]

[section:lic License]

This file is part of HadesMem.

HadesMem is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

HadesMem is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with HadesMem.  If not, see [@http://www.gnu.org/licenses/].

[endsect] [/ License]

[section:changes Changes]

Nothing to see here yet.

[endsect] [/ Changes]

[section:building Building]

HadesMem uses the [@http://www.boost.org/boost-build2/ Boost.Build] build 
system. If you have not already, it is recommend you familiarize yourself 
with this framework.

Supported Compilers:

* [@http://www.microsoft.com/visualstudio/en-us Microsoft Visual C++ 2010] 
(Express edition not officially supported)
* [@http://gcc.gnu.org/ GNU GCC 4.6.0] (via 
[@http://www.equation.com/servlet/equation.cmd?fa=fortran MinGW-w64])

Supported Platforms:

* [@http://www.microsoft.com/windows/ Microsoft Windows] (Windows XP SP2 or 
later)

Steps to Build:

# Build Boost.
  # Navigate to Build/Boost.
  # Run Bootstrap.bat.
  # Run Build_Compiler.bat (Substitute 'Compiler' as appropriate).
  # Check output and ensure there are no errors.
# Build HadesMem.
  # Navigate to Build/Full.
  # Run Build_Compiler_Configuration_Architecture.bat (Substitute 'Compiler', 
  'Configuration', and 'Architecture' as appropriate).
  # Check output and ensure there are no errors.
  
Using HadesMem (in a Boost.Build based project):

# Add a /use-project/ directive to your Jamroot targeting HadesMem (this 
document assumes you name the project 'HadesMem').
# Add '''/HadesMem//Memory''' to the source list of your application/library 
or the requirements list of your project.
# Add `#include <HadesMemory/Memory.hpp>` to your code.

[endsect] [/ Building]

[section:reference Reference]

[section:process Process]

[h4 Synopsis]

  // In header: <HadesMemory/Process.hpp>

  class Process
  {
  public:
    class Error : public virtual HadesMemError 
    { };
  
    explicit Process(DWORD ProcID);
    
    explicit Process(std::wstring const& ProcName);
    
    Process(std::wstring const& WindowName, std::wstring const& ClassName);
    
    Process(Process const& Other);
    
    Process& operator=(Process const& Other);
  
    HANDLE GetHandle() const;    
    
    DWORD GetID() const;    
    
    std::wstring GetPath() const;      
    
    bool IsWoW64() const;
  };
  
  Process CreateProcess(std::wstring const& Path, 
    std::wstring const& Params, 
    std::wstring const& WorkingDir);
  
  void GetSeDebugPrivilege();

[h4 Description]

The Process class is used for process management in the context of memory 
hacking. It opens a process using the required access rights for memory 
hacking, and exposes APIs to access commonly needed data related to a process.

Free functions are provided for process creation, and debug privilege 
acquisition.

[h4 Process public types]

TODO: Write this!

[h4 Process public construct/copy/destruct/move]

TODO: Write this!

[h4 Process public member functions]

TODO: Write this!

[h4 Public free functions]

TODO: Write this!

[endsect] [/ Process]

[section:memorymgr MemoryMgr]

[h4 Synopsis]

  // In header: <HadesMemory/MemoryMgr.hpp>

  class MemoryMgr
  {
  public:
    class Error : public virtual HadesMemError 
    { };

    explicit MemoryMgr(DWORD ProcID);

    explicit MemoryMgr(std::wstring const& ProcName);

    MemoryMgr(std::wstring const& WindowName, std::wstring const& ClassName);

    class RemoteFunctionRet
    {
    public:
      RemoteFunctionRet() 
        : m_ReturnValue(0), 
        m_ReturnValue64(0), 
        m_ReturnValueFloat(.0), 
        m_LastError(0)
      { }
      
      RemoteFunctionRet(DWORD_PTR ReturnValue, DWORD64 ReturnValue64, 
        double ReturnValueFloat, DWORD LastError) 
        : m_ReturnValue(ReturnValue), 
        m_ReturnValue64(ReturnValue64), 
        m_ReturnValueFloat(ReturnValueFloat), 
        m_LastError(LastError)
      { }
      
      DWORD_PTR GetReturnValue() const
      {
        return m_ReturnValue;
      }
      
      DWORD64 GetReturnValue64() const
      {
        return m_ReturnValue64;
      }
      
      double GetReturnValueFloat() const
      {
        return m_ReturnValueFloat;
      }
      
      DWORD GetLastError() const
      {
        return m_LastError;
      }
      
    private:
      DWORD_PTR m_ReturnValue;
      DWORD64 m_ReturnValue64;
      double m_ReturnValueFloat;
      DWORD m_LastError;
    };
  
    enum CallConv
    {
      CallConv_Default, 
      CallConv_CDECL, 
      CallConv_STDCALL, 
      CallConv_THISCALL, 
      CallConv_FASTCALL, 
      CallConv_X64
    };

    RemoteFunctionRet Call(LPCVOID Address, CallConv MyCallConv, 
      std::vector<PVOID> const& Args) const;

    template <typename T>
    T Read(PVOID Address) const;

    template <typename T>
    T Read(PVOID Address, std::size_t Size) const;

    template <typename T>
    void Write(PVOID Address, T const& Data) const;

    bool CanRead(LPCVOID Address) const;

    bool CanWrite(LPCVOID Address) const;

    bool IsGuard(LPCVOID Address) const;
    
    DWORD ProtectRegion(LPVOID Address, DWORD Protect) const;

    PVOID Alloc(SIZE_T Size) const;

    void Free(PVOID Address) const;

    DWORD GetProcessID() const;

    HANDLE GetProcessHandle() const;

    FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
      std::wstring const& Module, std::string const& Function) const;

    FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
      std::wstring const& Module, WORD Function) const;

    void FlushCache(LPCVOID Address, SIZE_T Size) const;
    
    bool IsWoW64() const;
  };

  class AllocAndFree
  {
  public:
    AllocAndFree(MemoryMgr const& MyMemoryMgr, SIZE_T Size);

    ~AllocAndFree();
    
    void Free() const;

    PVOID GetBase() const;
    
    SIZE_T GetSize() const;

  protected:
    AllocAndFree(AllocAndFree const&);
    AllocAndFree& operator=(AllocAndFree const&);
  };

[h4 Description]

The MemoryMgr class provides the most basic memory hacking functionality, and 
is the basis on which all other HadesMem components are built. It exposes APIs 
for memory reading, memory writing, function calling, region querying, memory 
allocation, and instruction cache flushing.

The AllocAndFree class is an RAII wrapper for remote memory allocation and 
freeing.

[h4 MemoryMgr public types]

TODO: Write this!

[h4 MemoryMgr public construct/copy/destruct/move]

TODO: Write this!

[h4 MemoryMgr public member functions]

TODO: Write this!

[h4 AllocAndFree public types]

TODO: Write this!

[h4 AllocAndFree public construct/copy/destruct/move]

TODO: Write this!

[h4 AllocAndFree public member functions]

TODO: Write this!

[endsect] [/ MemoryMgr]

[endsect] [/ Reference]

[section:acknowledge Acknowledgements]

HadesMem would not be possible without the help of the following projects:

* [@http://code.google.com/p/asmjit/ AsmJit]
* [@http://www.beaengine.org/ BeaEngine]
* [@http://www.boost.org/ Boost]

[endsect] [/ Acknowledgements]
