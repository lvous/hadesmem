Index: HTML/hadesmem_/acknowledgments.html
===================================================================
--- HTML/hadesmem_/acknowledgments.html	(revision 830)
+++ HTML/hadesmem_/acknowledgments.html	(working copy)
@@ -1,3 +1,4 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
 <html>
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
Index: HTML/hadesmem_/changes.html
===================================================================
--- HTML/hadesmem_/changes.html	(revision 830)
+++ HTML/hadesmem_/changes.html	(working copy)
@@ -1,3 +1,4 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
 <html>
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
Index: HTML/hadesmem_/faq.html
===================================================================
--- HTML/hadesmem_/faq.html	(revision 830)
+++ HTML/hadesmem_/faq.html	(working copy)
@@ -1,3 +1,4 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
 <html>
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
Index: HTML/hadesmem_/hadesmem.html
===================================================================
--- HTML/hadesmem_/hadesmem.html	(revision 830)
+++ HTML/hadesmem_/hadesmem.html	(working copy)
@@ -1,3 +1,4 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
 <html>
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
Index: HTML/hadesmem_/install.html
===================================================================
--- HTML/hadesmem_/install.html	(revision 830)
+++ HTML/hadesmem_/install.html	(working copy)
@@ -1,3 +1,4 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
 <html>
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
Index: HTML/hadesmem_/pyhadesmem.html
===================================================================
--- HTML/hadesmem_/pyhadesmem.html	(revision 830)
+++ HTML/hadesmem_/pyhadesmem.html	(working copy)
@@ -1,3 +1,4 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
 <html>
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
Index: HTML/index.html
===================================================================
--- HTML/index.html	(revision 830)
+++ HTML/index.html	(working copy)
@@ -1,3 +1,4 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
 <html>
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
@@ -18,7 +19,7 @@
 <a name="hadesmem_"></a>HadesMem </h1></div>
 <div><p class="copyright">Copyright &#169; 2010 RaptorFactor</p></div>
 <div><div class="legalnotice">
-<a name="id841582"></a><p>
+<a name="id774620"></a><p>
         Distributed under the GNU General Public License, Version 3. (See accompanying
         file gpl-3.0 or copy at <a href="http://www.gnu.org/licenses/" target="_top">http://www.gnu.org/licenses/</a>)
       </p>
@@ -85,7 +86,7 @@
 </div>
 </div>
 <table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
-<td align="left"><p><small>Last revised: January 06, 2011 at 15:28:39 GMT</small></p></td>
+<td align="left"><p><small>Last revised: January 10, 2011 at 07:27:46 GMT</small></p></td>
 <td align="right"><div class="copyright-footer"></div></td>
 </tr></table>
 <hr>
Index: Include/Common/Common/EnsureCleanup.hpp
===================================================================
--- Include/Common/Common/EnsureCleanup.hpp	(revision 0)
+++ Include/Common/Common/EnsureCleanup.hpp	(revision 0)
@@ -0,0 +1,673 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher).
+<http://www.cypherjb.com/> <cypher.jb@gmail.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <Windows.h>
+#include <Objbase.h>
+
+// C++ Standard Library
+#include <string>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/noncopyable.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Notice: Modified version of EnsureCleanup library provided in the 'Windows
+// via C/C++' sample code. Originally copyright Jeffrey Richter and
+// Christophe Nasarre.
+
+namespace Hades
+{
+  namespace Windows
+  {
+    // Windows RAII helper class template
+    // HandleT = Handle type (e.g. 'HANDLE')
+    // FuncT = Function prototype (e.g. 'BOOL (WINAPI*) (HANDLE)' )
+    // CleanupFn = Cleanup function (e.g. 'CloseHandle')
+    // Invalid = Invalid handle value (e.g. '0')
+    template <typename HandleT, typename FuncT, FuncT CleanupFn, 
+      DWORD_PTR Invalid>
+    class EnsureCleanup : private boost::noncopyable
+    {
+    public:
+      // Ensure size of handle type is valid. Under Windows all handles are 
+      // the size of a pointer.
+      static_assert(sizeof(HandleT) == sizeof(DWORD_PTR), 
+        "Size of handle type is invalid.");
+
+      // Constructor
+      EnsureCleanup(HandleT Handle = reinterpret_cast<HandleT>(Invalid))
+        : m_Handle(Handle)
+      { }
+
+      // Move constructor
+      EnsureCleanup(EnsureCleanup&& MyEnsureCleanup)
+        : m_Handle(Invalid)
+      {
+        *this = std::move(MyEnsureCleanup);
+      }
+
+      // Move assignment operator
+      EnsureCleanup& operator= (EnsureCleanup&& MyEnsureCleanup)
+      {
+        Cleanup();
+
+        this->m_Handle = MyEnsureCleanup.m_Handle;
+        MyEnsureCleanup.m_Handle = Invalid;
+
+        return *this;
+      }
+
+      // Assignment operator (for HandleT values)
+      EnsureCleanup& operator= (HandleT Handle)
+      {
+        Cleanup();
+
+        m_Handle = Handle;
+
+        return *this;
+      }
+
+      // The destructor performs the cleanup.
+      ~EnsureCleanup()
+      {
+        Cleanup();
+      }
+
+      // Whether object is valid
+      BOOL IsValid() const
+      {
+        return m_Handle != reinterpret_cast<HandleT>(Invalid);
+      }
+
+      // Whether object is invalid
+      BOOL IsInvalid() const
+      {
+        return !IsValid();
+      }
+
+      // Implicit conversion operator for HandleT
+      operator HandleT() const
+      {
+        return m_Handle;
+      }
+
+      // Cleanup the object if the value represents a valid object
+      void Cleanup()
+      {
+        if (IsValid())
+        {
+          // Close the object.
+          CleanupFn(m_Handle);
+
+          // We no longer represent a valid object.
+          m_Handle = reinterpret_cast<HandleT>(Invalid);
+        }
+      }
+
+    private:
+      // Handle being managed
+      HandleT m_Handle;
+    };
+    
+    // GCC workaround
+    namespace
+    {
+      DWORD_PTR const INVALID_HANDLE_VALUE_CUSTOM = 
+        static_cast<DWORD_PTR>(-1);
+    }
+
+    // Instances of the template C++ class for common data types.
+    typedef EnsureCleanup<HANDLE, BOOL(WINAPI*)(HANDLE), FindClose, 0> 
+      EnsureFindClose;
+    typedef EnsureCleanup<HANDLE, BOOL(WINAPI*)(HANDLE), CloseHandle, 0> 
+      EnsureCloseHandle;
+    typedef EnsureCleanup<HANDLE, BOOL(WINAPI*)(HANDLE), CloseHandle, 
+      INVALID_HANDLE_VALUE_CUSTOM> EnsureCloseSnap;
+    typedef EnsureCleanup<HLOCAL, HLOCAL(WINAPI*)(HLOCAL), LocalFree, 0> 
+      EnsureLocalFree;
+    typedef EnsureCleanup<HGLOBAL, HGLOBAL(WINAPI*)(HGLOBAL), GlobalFree, 0> 
+      EnsureGlobalFree;
+    typedef EnsureCleanup<HGLOBAL, BOOL(WINAPI*)(HGLOBAL), GlobalUnlock, 0> 
+      EnsureGlobalUnlock;
+    typedef EnsureCleanup<HKEY, LONG(WINAPI*)(HKEY), RegCloseKey, 0> 
+      EnsureRegCloseKey;
+    typedef EnsureCleanup<SC_HANDLE, BOOL(WINAPI*)(SC_HANDLE), 
+      CloseServiceHandle, 0> EnsureCloseServiceHandle;
+    typedef EnsureCleanup<HWINSTA, BOOL(WINAPI*)(HWINSTA), CloseWindowStation, 
+      0> EnsureCloseWindowStation;
+    typedef EnsureCleanup<HDESK, BOOL(WINAPI*)(HDESK), CloseDesktop, 0> 
+      EnsureCloseDesktop;
+    typedef EnsureCleanup<LPCVOID, BOOL(WINAPI*)(LPCVOID), UnmapViewOfFile, 0> 
+      EnsureUnmapViewOfFile;
+    typedef EnsureCleanup<HMODULE, BOOL(WINAPI*)(HMODULE), FreeLibrary, 0> 
+      EnsureFreeLibrary;
+    typedef EnsureCleanup<PVOID, ULONG(WINAPI*)(PVOID), 
+      RemoveVectoredExceptionHandler, 0> EnsureRemoveVEH;
+    typedef EnsureCleanup<HANDLE, DWORD(WINAPI*)(HANDLE), ResumeThread, 0> 
+      EnsureResumeThread;
+    typedef EnsureCleanup<HANDLE, BOOL(WINAPI*)(HANDLE), CloseHandle, 
+      INVALID_HANDLE_VALUE_CUSTOM> EnsureCloseFile;
+    typedef EnsureCleanup<HHOOK, BOOL(WINAPI*)(HHOOK), UnhookWindowsHookEx, 0> 
+      EnsureUnhookWindowsHookEx;
+    typedef EnsureCleanup<HWND, BOOL(WINAPI*)(HWND), DestroyWindow, 0> 
+      EnsureDestroyWindow;
+    typedef EnsureCleanup<PSID, PVOID(WINAPI*)(PSID), FreeSid, 0> 
+      EnsureFreeSid;
+    typedef EnsureCleanup<HGLOBAL, BOOL(WINAPI*)(HGLOBAL), FreeResource, 0> 
+      EnsureFreeResource;
+    typedef EnsureCleanup<HDC, BOOL(WINAPI*)(HDC), DeleteDC, 0> 
+      EnsureDeleteDc;
+    typedef EnsureCleanup<HBITMAP, BOOL(WINAPI*)(HGDIOBJ), DeleteObject, 0> 
+      EnsureDeleteObject;
+    typedef EnsureCleanup<HICON, BOOL(WINAPI*)(HICON), DestroyIcon, 0> 
+      EnsureDestroyIcon;
+    typedef EnsureCleanup<HMENU, BOOL(WINAPI*)(HMENU), DestroyMenu, 0> 
+      EnsureDestroyMenu;
+
+    // Special class for ensuring COM is uninitialized
+    class EnsureCoUninitialize : private boost::noncopyable
+    {
+    public:
+      ~EnsureCoUninitialize()
+      {
+        CoUninitialize();
+      }
+    };
+
+    // Special class for releasing a reserved region.
+    class EnsureReleaseRegion : private boost::noncopyable
+    {
+    public:
+      // Constructor
+      EnsureReleaseRegion(PVOID pv = nullptr)
+        : m_pv(pv)
+      { }
+
+      // Destructor
+      ~EnsureReleaseRegion()
+      {
+        Cleanup();
+      }
+
+      // Move constructor
+      EnsureReleaseRegion(EnsureReleaseRegion&& MyEnsureCleanup)
+        : m_pv(nullptr)
+      {
+        *this = std::move(MyEnsureCleanup);
+      }
+
+      // Move assignment operator
+      EnsureReleaseRegion& operator= (EnsureReleaseRegion&& MyEnsureCleanup)
+      {
+        Cleanup();
+
+        m_pv = MyEnsureCleanup.m_pv;
+
+        MyEnsureCleanup.m_pv = 0;
+
+        return *this;
+      }
+
+      // Assignment operator (for PVOID values) 
+      EnsureReleaseRegion& operator= (PVOID pv)
+      {
+        Cleanup();
+
+        m_pv = pv;
+
+        return *this;
+      }
+
+      // Implicit conversion operator for PVOID
+      operator PVOID() const
+      {
+        return m_pv;
+      }
+
+      // Cleanup the object if the value represents a valid object
+      void Cleanup()
+      {
+        if (m_pv != nullptr)
+        {
+          VirtualFree(m_pv, 0, MEM_RELEASE);
+
+          m_pv = nullptr;
+        }
+      }
+
+    private:
+      // Handle being managed
+      PVOID m_pv;
+    };
+
+    // Special class for releasing a reserved region.
+    class EnsureEndUpdateResource : private boost::noncopyable
+    {
+    public:
+      // Constructor
+      EnsureEndUpdateResource(HANDLE File = nullptr) 
+        : m_File(File)
+      { }
+
+      // Move constructor
+      EnsureEndUpdateResource(EnsureEndUpdateResource&& MyEnsureCleanup)
+        : m_File(nullptr)
+      {
+        *this = std::move(MyEnsureCleanup);
+      }
+
+      // Move assignment operator
+      EnsureEndUpdateResource& operator= (EnsureEndUpdateResource&&
+        MyEnsureCleanup)
+      {
+        Cleanup();
+
+        m_File = MyEnsureCleanup.m_File;
+
+        MyEnsureCleanup.m_File = nullptr;
+
+        return *this;
+      }
+
+      // Destructor
+      ~EnsureEndUpdateResource()
+      {
+        Cleanup();
+      }
+
+      // Assignment operator (for HANDLE values) 
+      EnsureEndUpdateResource& operator= (HANDLE File)
+      {
+        Cleanup();
+
+        m_File = File;
+
+        return *this;
+      }
+
+      // Implicit conversion operator for HANDLE
+      operator HANDLE() const
+      {
+        return m_File;
+      }
+
+      // Cleanup the object if the value represents a valid object
+      void Cleanup()
+      {
+        if (m_File != nullptr)
+        {
+          EndUpdateResource(m_File, FALSE);
+
+          m_File = nullptr;
+        }
+      }
+
+    private:
+      // Handle being managed
+      HANDLE m_File;
+    };
+
+    // Special class for freeing a block from a heap
+    class EnsureHeapFree : private boost::noncopyable
+    {
+    public:
+      // Constructor
+      EnsureHeapFree(PVOID pv = nullptr, HANDLE hHeap = GetProcessHeap())
+        : m_pv(pv), m_hHeap(hHeap)
+      { }
+
+      // Move constructor
+      EnsureHeapFree(EnsureHeapFree&& MyEnsureCleanup)
+        : m_pv(nullptr),
+        m_hHeap(nullptr)
+      {
+        *this = std::move(MyEnsureCleanup);
+      }
+
+      // Move assignment operator
+      EnsureHeapFree& operator= (EnsureHeapFree&& MyEnsureCleanup)
+      {
+        Cleanup();
+
+        m_pv = MyEnsureCleanup.m_pv;
+        m_hHeap = MyEnsureCleanup.m_hHeap;
+
+        MyEnsureCleanup.m_pv = nullptr;
+        MyEnsureCleanup.m_hHeap = nullptr;
+
+        return *this;
+      }
+
+      // Destructor
+      ~EnsureHeapFree()
+      {
+        Cleanup();
+      }
+
+      // Assignment operator (for PVOID values)
+      EnsureHeapFree& operator= (PVOID pv)
+      {
+        Cleanup();
+
+        m_pv = pv;
+
+        return *this;
+      }
+
+      // Implicit conversion operator for PVOID
+      operator PVOID() const
+      {
+        return m_pv;
+      }
+
+      // Cleanup the object if the value represents a valid object
+      void Cleanup()
+      {
+        if (m_pv != nullptr)
+        {
+          HeapFree(m_hHeap, 0, m_pv);
+
+          m_pv = nullptr;
+        }
+      }
+
+    private:
+      // Handles being managed
+      PVOID m_pv;
+      HANDLE m_hHeap;
+    };
+
+    // Special class for releasing a remote reserved region
+    class EnsureReleaseRegionEx : private boost::noncopyable
+    {
+    public:
+      // Constructor
+      EnsureReleaseRegionEx(PVOID pv = nullptr, HANDLE proc = nullptr)
+        : m_pv(pv), 
+        m_proc(proc)
+      { }
+
+      // Move constructor
+      EnsureReleaseRegionEx(EnsureReleaseRegionEx&& MyEnsureCleanup)
+        : m_pv(nullptr),
+        m_proc(nullptr)
+      {
+        *this = std::move(MyEnsureCleanup);
+      }
+
+      // Move assignment operator
+      EnsureReleaseRegionEx& operator= (EnsureReleaseRegionEx&&
+        MyEnsureCleanup)
+      {
+        Cleanup();
+
+        m_pv = MyEnsureCleanup.m_pv;
+        m_proc = MyEnsureCleanup.m_proc;
+
+        MyEnsureCleanup.m_pv = nullptr;
+        MyEnsureCleanup.m_proc = nullptr;
+
+        return *this;
+      }
+
+      // Destructor
+      ~EnsureReleaseRegionEx()
+      {
+        Cleanup();
+      }
+
+      // Assignment operator (for PVOID values)
+      EnsureReleaseRegionEx& operator= (PVOID pv)
+      {
+        Cleanup();
+
+        m_pv = pv;
+
+        return *this;
+      }
+
+      // Implicit conversion operator for PVOID
+      operator PVOID() const
+      {
+        return m_pv;
+      }
+
+      // Cleanup the object if the value represents a valid object
+      void Cleanup()
+      {
+        if (m_pv != nullptr && m_proc != nullptr)
+        {
+          VirtualFreeEx(m_proc, m_pv, 0, MEM_RELEASE);
+
+          m_pv = nullptr;
+        }
+      }
+
+    private:
+      // Handles being managed
+      PVOID m_pv;
+      HANDLE m_proc;
+    };
+
+    // Special class for closing the clipboard
+    class EnsureCloseClipboard : private boost::noncopyable
+    {
+    public:
+      // Constructor
+      EnsureCloseClipboard(BOOL Success) 
+        : m_Success(Success)
+      { }
+      
+      // Move constructor
+      EnsureCloseClipboard(EnsureCloseClipboard&& MyEnsureCleanup)
+        : m_Success(FALSE)
+      {
+        *this = std::move(MyEnsureCleanup);
+      }
+
+      // Move assignment operator
+      EnsureCloseClipboard& operator= (EnsureCloseClipboard&& MyEnsureCleanup)
+      {
+        Cleanup();
+
+        m_Success = MyEnsureCleanup.m_Success;
+
+        MyEnsureCleanup.m_Success = FALSE;
+
+        return *this;
+      }
+
+      // Destructor
+      ~EnsureCloseClipboard()
+      {
+        Cleanup();
+      }
+
+      // Assignment operator (for BOOL values)
+      EnsureCloseClipboard& operator= (BOOL Success)
+      {
+        Cleanup();
+
+        m_Success = Success;
+
+        return *this;
+      }
+
+      // Implicit conversion operator for BOOL
+      operator BOOL() const
+      {
+        return m_Success;
+      }
+
+      // Cleanup the object if the value represents a valid object
+      void Cleanup()
+      {
+        if (m_Success)
+        {
+          CloseClipboard();
+
+          m_Success = FALSE;
+        }
+      }
+
+    private:
+      // 'Handle' being managed
+      BOOL m_Success;
+    };
+
+    // Special class for releasing a window class
+    class EnsureUnregisterClass : private boost::noncopyable
+    {
+    public:
+      // Constructor
+      EnsureUnregisterClass(std::basic_string<TCHAR> const& ClassName, 
+        HINSTANCE Instance)
+        : m_ClassName(ClassName),
+        m_Instance(Instance)
+      { }
+
+      // Move constructor
+      EnsureUnregisterClass(EnsureUnregisterClass&& MyEnsureCleanup)
+        : m_ClassName(),
+        m_Instance()
+      {
+        *this = std::move(MyEnsureCleanup);
+      }
+
+      // Move assignment operator
+      EnsureUnregisterClass& operator= (EnsureUnregisterClass&&
+        MyEnsureCleanup)
+      {
+        Cleanup();
+
+        m_ClassName = std::move(MyEnsureCleanup.m_ClassName);
+        m_Instance = MyEnsureCleanup.m_Instance;
+
+        MyEnsureCleanup.m_ClassName = std::basic_string<TCHAR>();
+        MyEnsureCleanup.m_Instance = nullptr;
+
+        return *this;
+      }
+
+      // Destructor
+      ~EnsureUnregisterClass()
+      {
+        Cleanup();
+      }
+
+      // Cleanup the object if the value represents a valid object
+      void Cleanup()
+      {
+        if (!m_ClassName.empty() && m_Instance)
+        {
+          UnregisterClass(m_ClassName.c_str(), m_Instance);
+
+          m_ClassName.clear();
+          m_Instance = 0;
+        }
+      }
+
+    private:
+      // 'Handles' being managed
+      std::basic_string<TCHAR> m_ClassName;
+      HINSTANCE m_Instance;
+    };
+
+
+    // Special class for releasing a DC
+    class EnsureReleaseDc
+    {
+    public:
+      // Constructor
+      EnsureReleaseDc(HWND Wnd = nullptr, HDC Dc = nullptr)
+        : m_Wnd(Wnd),
+        m_Dc(Dc)
+      { }
+
+      // Move constructor
+      EnsureReleaseDc(EnsureReleaseDc&& MyEnsureCleanup)
+        : m_Wnd(nullptr),
+        m_Dc(nullptr)
+      {
+        *this = std::move(MyEnsureCleanup);
+      }
+
+      // Move assignment operator
+      EnsureReleaseDc& operator= (EnsureReleaseDc&& MyEnsureCleanup)
+      {
+        Cleanup();
+
+        m_Wnd = MyEnsureCleanup.m_Wnd;
+        m_Dc = MyEnsureCleanup.m_Dc;
+
+        MyEnsureCleanup.m_Wnd = nullptr;
+        MyEnsureCleanup.m_Dc = nullptr;
+
+        return *this;
+      }
+
+      // Destructor
+      ~EnsureReleaseDc()
+      {
+        Cleanup();
+      }
+
+      // Assignment operator (for HDC values)
+      EnsureReleaseDc& operator= (HDC Dc)
+      {
+        Cleanup();
+
+        m_Dc = Dc;
+
+        return *this;
+      }
+
+      // Implicit conversion operator for BOOL
+      operator HDC() const
+      {
+        return m_Dc;
+      }
+
+      // Cleanup the object if the value represents a valid object
+      void Cleanup()
+      {
+        if (m_Wnd != nullptr && m_Dc != nullptr)
+        {
+          ReleaseDC(m_Wnd, m_Dc);
+
+          m_Wnd = nullptr;
+          m_Dc = nullptr;
+        }
+      }
+
+    private:
+      // Handles being managed
+      HWND m_Wnd;
+      HDC m_Dc;
+    };
+  }
+}
Index: Include/Common/Common/Error.hpp
===================================================================
--- Include/Common/Common/Error.hpp	(revision 0)
+++ Include/Common/Common/Error.hpp	(revision 0)
@@ -0,0 +1,60 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
+<http://www.cypherjb.com/> <cypher.jb@gmail.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows
+#include <Windows.h>
+
+// C++ Standard Library
+#include <string>
+#include <stdexcept>
+#include <system_error>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/exception/all.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+namespace Hades
+{
+  // Error info (function name)
+  typedef boost::error_info<struct TagErrorFunc, std::string> ErrorFunction;
+  // Error info (error string)
+  typedef boost::error_info<struct TagErrorString, std::string> ErrorString;
+  // Error info (Windows error code)
+  typedef boost::error_info<struct TagErrorCode, std::error_code> 
+    ErrorCode;
+    
+  // Call 'GetLastError' and convert result to error_code
+  inline std::error_code GetLastErrorCode()
+  {
+    DWORD const LastError = GetLastError();
+    return std::error_code(LastError, std::system_category());
+  }
+
+  // Base exception class
+  class HadesError : public virtual std::exception, 
+    public virtual boost::exception
+  { };
+}
Index: Include/Common/Common/Filesystem.hpp
===================================================================
--- Include/Common/Common/Filesystem.hpp	(revision 0)
+++ Include/Common/Common/Filesystem.hpp	(revision 0)
@@ -0,0 +1,123 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
+<http://www.cypherjb.com/> <cypher.jb@gmail.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// C++ Standard Library
+#include <string>
+#include <vector>
+#include <fstream>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/filesystem.hpp>
+#include <boost/filesystem/fstream.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Windows API
+#include <Windows.h>
+
+// Hades
+#include "Error.hpp"
+#include "WinAux.hpp"
+#include "StringBuffer.hpp"
+
+namespace Hades
+{
+  namespace Windows
+  {
+    // Filesystem error type
+    class FilesystemError : public virtual HadesError 
+    { };
+
+    // Load a buffer into a file
+    inline void BufferToFile(std::vector<BYTE> const& Buffer, 
+      boost::filesystem::path const& Path)
+    {
+      // Open file
+      boost::filesystem::basic_ofstream<BYTE> File(Path, std::ios::binary);
+      if (!File)
+      {
+        BOOST_THROW_EXCEPTION(FilesystemError() << 
+          ErrorFunction("BufferToFile") << 
+          ErrorString("Could not open file."));
+      }
+
+      // Copy buffer to file
+      File.write(&Buffer[0], Buffer.size());
+    }
+
+    // Load a file into a buffer
+    inline std::vector<BYTE> FileToBuffer(boost::filesystem::path const& Path)
+    {
+      // Open file
+      boost::filesystem::basic_ifstream<BYTE> File(Path, std::ios::binary | 
+        std::ios::ate);
+      if (!File)
+      {
+        BOOST_THROW_EXCEPTION(FilesystemError() << 
+          ErrorFunction("FileToBuffer") << 
+          ErrorString("Could not open file."));
+      }
+
+      // Copy file to buffer
+      std::vector<BYTE> Buffer(static_cast<std::size_t>(File.tellg()));
+      File.seekg(0, std::ios::beg);
+      File.read(&Buffer[0], Buffer.size());
+
+      // Return file as buffer
+      return Buffer;
+    }
+
+    // Get path to self (directory)
+    inline boost::filesystem::path GetSelfPath()
+    {
+      // Get self
+      HMODULE const ModMe(reinterpret_cast<HMODULE>(GetBaseOfSelf()));
+
+      // Get path to self
+      DWORD const SelfPathSize = MAX_PATH;
+      std::basic_string<TCHAR> SelfFullPath;
+      if (!GetModuleFileName(ModMe, Util::MakeStringBuffer(SelfFullPath, 
+        SelfPathSize), SelfPathSize) || GetLastError() == 
+        ERROR_INSUFFICIENT_BUFFER)
+      {
+        std::error_code const LastError = GetLastErrorCode();
+        BOOST_THROW_EXCEPTION(HadesError() << 
+          ErrorFunction("GetSelfPath") << 
+          ErrorString("Could not get path to self.") << 
+          ErrorCode(LastError));
+      }
+
+      // Path to self
+      return boost::filesystem::path(SelfFullPath);
+    }
+
+    // Get path to self (directory)
+    inline boost::filesystem::path GetSelfDirPath()
+    {
+      // Path to self dir
+      return GetSelfPath().parent_path();
+    }
+  }
+}
Index: Include/Common/Common/I18n.hpp
===================================================================
--- Include/Common/Common/I18n.hpp	(revision 0)
+++ Include/Common/Common/I18n.hpp	(revision 0)
@@ -0,0 +1,78 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
+<http://www.cypherjb.com/> <cypher.jb@gmail.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// C++ Standard Library
+#include <string>
+#ifdef _MSC_VER
+#include <cvt/wstring>
+#endif // #ifdef _MSC_VER
+
+// Boost
+#include <boost/lexical_cast.hpp>
+
+namespace boost
+{
+  // Boost.LexicalCast specialization to allow conversions from wide to narrow 
+  // strings.
+  template<> 
+  inline std::string lexical_cast<std::string, std::wstring>(
+    std::wstring const& Source)
+  {
+  #ifdef _MSC_VER
+    return stdext::cvt::wstring_convert<std::codecvt<wchar_t, char, 
+      mbstate_t>>().to_bytes(Source);
+  #else
+    // Fixme: Implement fully for non-MSVC
+    return std::string(Source.cbegin(), Source.cend());
+  #endif // #ifdef _MSC_VER
+  }
+  
+  // Boost.LexicalCast specialization to allow conversions from narrow to wide 
+  // strings.
+  template<> 
+  inline std::wstring lexical_cast<std::wstring, std::string>(
+    std::string const& Source)
+  {
+  #ifdef _MSC_VER
+    return stdext::cvt::wstring_convert<std::codecvt<wchar_t, char, 
+      mbstate_t>>().from_bytes(Source);
+  #else
+    // Fixme: Implement fully for non-MSVC
+    return std::wstring(Source.cbegin(), Source.cend());
+  #endif // #ifdef _MSC_VER
+  }
+  
+  // Turn attempts to convert between the same string types into a nullsub.
+  template<> 
+  inline std::wstring lexical_cast<std::wstring, std::wstring>(
+    std::wstring const& Source)
+  {
+    return Source;
+  }
+  
+  // Turn attempts to convert between the same string types into a nullsub.
+  template<> 
+  inline std::string lexical_cast<std::string, std::string>(
+    std::string const& Source)
+  {
+    return Source;
+  }
+}
Index: Include/Common/Common/Logger.hpp
===================================================================
--- Include/Common/Common/Logger.hpp	(revision 0)
+++ Include/Common/Common/Logger.hpp	(revision 0)
@@ -0,0 +1,205 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
+<http://www.cypherjb.com/> <cypher.jb@gmail.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <tchar.h>
+#include <Windows.h>
+
+// C++ Standard Library
+#include <string>
+#include <vector>
+#include <utility>
+#include <fstream>
+#include <iostream>
+
+// Boost C++ Libraries
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/thread.hpp>
+#include <boost/format.hpp>
+#include <boost/date_time.hpp>
+#include <boost/filesystem.hpp>
+#include <boost/iostreams/stream.hpp>
+#include <boost/filesystem/fstream.hpp>
+#include <boost/iostreams/categories.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Error.hpp"
+#include "Filesystem.hpp"
+
+#define HADES_LOG_THREAD_SAFE(x)\
+{\
+boost::lock_guard<boost::mutex> MyLock(Hades::Util::Logger<char>::GetMutex());\
+x;\
+}\
+
+
+namespace Hades
+{
+  namespace Util
+  {
+    // Logging class
+    template <typename CharT>
+    class Logger
+    {
+    public:
+      // Logger error type
+      class Error : public virtual HadesError 
+      { };
+
+      // Get logger mutex
+      static boost::mutex& GetMutex()
+      {
+        static boost::mutex MyMutex;
+        return MyMutex;
+      }
+
+      // Sink information
+      typedef CharT char_type;
+      typedef boost::iostreams::sink_tag category;
+
+      // STL typedefs
+      typedef boost::filesystem::basic_ofstream<char_type> tofstream;
+
+      // Stream typedef
+      typedef boost::iostreams::stream<Logger<CharT>> Stream;
+
+      // Constructor
+      Logger(boost::filesystem::path const& LogDirPath, 
+        std::basic_string<TCHAR> const& Filename) 
+        : m_LogPath(GeneratePath(LogDirPath, Filename))
+      { }
+
+      // Get path to log file
+      boost::filesystem::path GetLogPath() const 
+      {
+        return m_LogPath;
+      }
+
+      // Generate path to log file.
+      std::basic_string<TCHAR> GeneratePath(boost::filesystem::path const& 
+        LogDirPath, std::basic_string<TCHAR> const& Filename)
+      {
+        // Get local time
+        boost::posix_time::ptime const Time(boost::posix_time::second_clock::
+          local_time());
+        // Convert time to string YYYY-MM-DDTHH:MM:SS
+        std::basic_string<TCHAR> TimeStr(boost::posix_time::
+          to_iso_extended_string_type<TCHAR>(Time));
+        // Reformat time YYYY-MM-DD_HH-MM-SS
+        TimeStr[10] = _T('_'); TimeStr[13] = _T('-'); TimeStr[16] = _T('-');
+
+        // Generate file path relative to initial directory
+        std::basic_string<TCHAR> const LogFile(Filename + _T("-") + TimeStr + 
+          _T(".log"));
+
+        // Make full path to log file
+        boost::filesystem::path const LogPath(LogDirPath / LogFile);
+
+        // Return path to log file
+        return LogPath.string<std::basic_string<TCHAR>>();
+      }
+
+      // Writes n characters from s
+      std::streamsize write(const char_type* s, std::streamsize n)
+      {
+        // Get time
+        boost::posix_time::ptime const Time(boost::posix_time::second_clock::
+          local_time());
+        // Convert time to string YYYY-MM-DDTHH:MM:SS
+        std::basic_string<char_type> TimeStr(boost::posix_time::
+          to_iso_extended_string_type<char_type>(Time));
+        // Reformat time YYYY-MM-DD_HH-MM-SS
+        TimeStr[10] = '_'; TimeStr[13] = '-'; TimeStr[16] = '-';
+
+        // Open file
+        tofstream Out(m_LogPath, tofstream::out | tofstream::app);
+        if(!Out)
+        {
+          BOOST_THROW_EXCEPTION(Error() << 
+            ErrorFunction("Logger::write") << 
+            ErrorString("Could not open file."));
+        }
+
+        // Write time as string
+        Out << '[' << TimeStr << "]: ";
+
+        // Write data
+        Out.write(s, n);
+
+        // Return size
+        return n;
+      }
+
+    private:
+      // Path to log file
+      boost::filesystem::path m_LogPath;
+    };
+
+    // Initialize logging. Returns wide path to self.
+    inline void InitLogger(std::basic_string<TCHAR> const& OutName, 
+      std::basic_string<TCHAR> const& LogName)
+    {
+      // Check if we actually need to continue
+      if (OutName.empty() && LogName.empty())
+      {
+        return;
+      }
+
+      // Path to self dir
+      boost::filesystem::path const SelfDirPath(Windows::GetSelfDirPath());
+
+      // Ensure Logs directory exists
+      boost::filesystem::path const LogsPath(SelfDirPath / L"/Logs/");
+      boost::filesystem::create_directory(LogsPath);
+
+      // Redirect standard output streams to file
+      if (!OutName.empty())
+      {
+        static Logger<char> AnsiLogger(LogsPath, OutName);
+        static Logger<char>::Stream AnsiStream(AnsiLogger);
+        static Logger<wchar_t> WideLogger(LogsPath, OutName);
+        static Logger<wchar_t>::Stream WideStream(WideLogger);
+        std::cout.rdbuf(AnsiStream.rdbuf());
+        std::wcout.rdbuf(WideStream.rdbuf());
+
+        std::wcout << "Logger initialized." << std::endl;
+      }
+
+      // Redirect standard log output streams to file
+      if (!LogName.empty())
+      {
+        static Logger<char> AnsiLogger(LogsPath, LogName);
+        static Logger<char>::Stream AnsiStream(AnsiLogger);
+        static Logger<wchar_t> WideLogger(LogsPath, LogName);
+        static Logger<wchar_t>::Stream WideStream(WideLogger);
+        std::clog.rdbuf(AnsiStream.rdbuf());
+        std::wclog.rdbuf(WideStream.rdbuf());
+
+        std::wclog << "Logger initialized." << std::endl;
+      }
+    }
+  }
+}
Index: Include/Common/Common/StringBuffer.hpp
===================================================================
--- Include/Common/Common/StringBuffer.hpp	(revision 0)
+++ Include/Common/Common/StringBuffer.hpp	(revision 0)
@@ -0,0 +1,121 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
+<http://www.cypherjb.com/> <cypher.jb@gmail.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// C++ Standard Library
+#include <string>
+#include <vector>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/noncopyable.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+namespace Hades
+{
+  namespace Util
+  {
+    // Utility class to 'bind' a temporary buffer to a string and allow 
+    // easy interoperability with C-style APIs.
+    template <class CharT>
+    class StringBuffer : private boost::noncopyable
+    {
+    public:
+      // Constructor
+      StringBuffer(std::basic_string<CharT>& String, std::size_t Size) 
+        : m_String(&String), 
+        m_Buffer(Size + 1) 
+      { }
+
+      // Move constructor
+      StringBuffer(StringBuffer&& Other)
+      {
+        *this = std::move(Other);
+      }
+
+      // Move assignment operator
+      StringBuffer& operator=(StringBuffer&& Other)
+      {
+        this->m_String = Other.m_String;
+        Other.m_String = 0;
+
+        this->m_Buffer = std::move(Other.m_Buffer);
+
+        return *this;
+      }
+
+      // Destructor
+      ~StringBuffer()
+      {
+        // Commit current buffer
+        Commit();
+      }
+
+      // Get pointer to internal buffer
+      CharT* Get()
+      {
+        return &m_Buffer[0];
+      }
+
+      // Implicit conversion operator to allow for easy C-style API 
+      // interoperability
+      operator CharT* ()
+      {
+        return Get();
+      }
+
+      // Commit current buffer to target string
+      void Commit()
+      {
+        if (!m_Buffer.empty())
+        {
+          *m_String = &m_Buffer[0];
+          m_Buffer.clear();
+        }
+      }
+
+      // Clear current buffer
+      void Abort()
+      {
+        m_Buffer.clear();
+      }
+
+    private:
+      // Target string
+      std::basic_string<CharT>* m_String;
+
+      // Temporary buffer
+      std::vector<CharT> m_Buffer;
+    };
+
+    // Make string buffer class. Function is simply used to automatically 
+    // deduce and forward template argument type.
+    template <class CharT>
+    StringBuffer<CharT> MakeStringBuffer(std::basic_string<CharT>& String, 
+      std::size_t Size)
+    {
+      return StringBuffer<CharT>(String, Size);
+    }
+  }
+}
Index: Include/Common/Common/VecN.hpp
===================================================================
--- Include/Common/Common/VecN.hpp	(revision 0)
+++ Include/Common/Common/VecN.hpp	(revision 0)
@@ -0,0 +1,334 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
+<http://www.cypherjb.com/> <cypher.jb@gmail.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// C++ Standard Library
+#include <array>
+#include <cmath>
+#include <vector>
+#include <numeric>
+#include <cassert>
+#include <iterator>
+#include <stdexcept>
+#include <algorithm>
+#include <functional>
+
+namespace Hades
+{
+  namespace Math
+  {
+    // N-Dimensional Vector
+    template <class ElemT, std::size_t Num>
+    class VecN
+    {
+    public:
+      // ElemT used to store elements
+      typedef std::array<ElemT, Num> DataT;    
+
+      // Element placeholders. For convenience only.
+      enum Elems
+      {
+        XElem,
+        YElem,
+        ZElem
+      };
+
+      // Default constructor. 
+      // All dimensions default initialized.
+      VecN() 
+        : m_Data() 
+      {
+        std::fill(m_Data.begin(), m_Data.end(), static_cast<ElemT>(0)); 
+      }
+
+      // Vec1 constructor
+      VecN(ElemT X) 
+        : m_Data()
+      {
+        static_assert(Num == 1, "Wrong constructor used for VecN");
+        m_Data[XElem] = X;
+      }
+
+      // Vec2 constructor
+      VecN(ElemT X, ElemT Y) 
+        : m_Data()
+      {
+        static_assert(Num == 2, "Wrong constructor used for VecN");
+        m_Data[XElem] = X; m_Data[YElem] = Y;
+      }
+
+      // Vec3 constructor
+      VecN(ElemT X, ElemT Y, ElemT Z) 
+        : m_Data()
+      {
+        static_assert(Num == 3, "Wrong constructor used for VecN");
+        m_Data[XElem] = X; m_Data[YElem] = Y; m_Data[ZElem] = Z;
+      }
+
+      // Vec4 constructor
+      VecN(ElemT X, ElemT Y, ElemT Z, ElemT N) 
+        : m_Data()
+      {
+        static_assert(Num == 4, "Wrong constructor used for VecN");
+        m_Data[XElem] = X; m_Data[YElem] = Y; m_Data[ZElem] = Z; m_Data[3] = N;
+      }
+
+      // Get reference to vector element
+      // Implemented by calling const version of function and const_cast'ing 
+      // the returned reference. Safe in this scenario. For more information 
+      // see [Myers].
+      ElemT& operator[] (unsigned int Index)
+      {
+        assert(Index < Num && "Out of range element access in VecN");
+        return const_cast<ElemT&>(static_cast<const VecN<ElemT, Num>& >(*this).
+          operator[](Index));
+      }
+
+      // Get const reference to vector element
+      const ElemT& operator[] (unsigned int Index) const
+      {
+        assert(Index < Num && "Out of range element access in VecN");
+        return m_Data[Index]; 
+      }
+
+      // Get negated vector
+      VecN<ElemT, Num> operator- () const
+      {
+        VecN<ElemT, Num> Result;
+        std::transform(m_Data.begin(), m_Data.end(), Result.m_Data.begin(), 
+          std::negate<ElemT>());
+        return Result;
+      }
+
+      // Vector subtraction
+      VecN<ElemT, Num> operator- (const VecN<ElemT, Num>& Rhs) const
+      {
+        VecN<ElemT, Num> Result(*this);
+        Result -= Rhs;
+        return Result;
+      }
+
+      // Vector subtraction
+      VecN<ElemT, Num> operator-= (const VecN<ElemT, Num>& Rhs) 
+      {
+        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
+          m_Data.begin(), std::minus<ElemT>());
+        return *this;
+      }
+
+      // Vector addition
+      VecN<ElemT, Num> operator+ (const VecN<ElemT, Num>& Rhs) const
+      {
+        VecN<ElemT, Num> Result(*this);
+        Result += Rhs;
+        return Result;
+      }
+
+      // Vector addition
+      VecN<ElemT, Num> operator+= (const VecN<ElemT, Num>& Rhs) 
+      {
+        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
+          m_Data.begin(), std::plus<ElemT>());
+        return *this;
+      }
+
+      // Vector multiplication (scales elements)
+      VecN<ElemT, Num> operator* (ElemT Rhs) const
+      {
+        VecN<ElemT, Num> Result(*this);
+        Result *= Rhs;
+        return Result;
+      }
+
+      // Vector multiplication (scales elements)
+      // Mixed mode version
+      friend inline VecN<ElemT, Num> operator* (ElemT Lhs, 
+        const VecN<ElemT, Num>& Rhs)
+      {
+        return Rhs * Lhs;
+      }
+
+      // Vector multiplication (scalar/dot product)
+      ElemT operator* (const VecN<ElemT, Num>& Rhs) const
+      {
+        DataT Result(Num);
+        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
+          Result.begin(), std::multiplies<ElemT>());
+        return std::accumulate(Result.begin(), Result.end(), 
+          static_cast<ElemT>(0));
+      }
+
+      // Vector multiplication (scales elements)
+      VecN<ElemT, Num> operator*= (ElemT Rhs) 
+      {
+        std::transform(m_Data.begin(), m_Data.end(), m_Data.begin(), 
+          std::bind(std::multiplies<ElemT>(), std::placeholders::_1, Rhs));
+        return *this;
+      }
+
+      // Vector division (scalar/dot division)
+      ElemT operator/ (const VecN<ElemT, Num>& Rhs) const
+      {
+        DataT Result(Num);
+        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
+          Result.begin(), std::divides<ElemT>());
+        return std::accumulate(Result.begin(), Result.end(), 
+          static_cast<ElemT>(0));
+      }
+
+      // Vector division (scalar/dot division)
+      VecN<ElemT, Num> operator/= (const VecN<ElemT, Num>& Rhs) 
+      {
+        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
+          m_Data.begin(), std::divides<ElemT>());
+        return *this;
+      }
+
+      // Equality test
+      bool operator == (const VecN<ElemT, Num>& Rhs) const
+      {
+        return std::equal(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin());
+      }
+
+      // Inequality check
+      bool operator != (const VecN<ElemT, Num>& Rhs) const
+      {
+        return !std::equal(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin());
+      }
+
+      // Output stream overload
+      // Prints in format:
+      // E1 E2 ... EN
+      friend inline std::ostream& operator << (std::ostream& Lhs, 
+        const VecN<ElemT, Num>& Rhs)
+      {
+        std::copy(Rhs.m_Data.begin(), Rhs.m_Data.end(), 
+          std::ostream_iterator<ElemT>(Lhs, " "));
+        return Lhs;
+      }
+
+      // Output stream overload
+      // Prints in format:
+      // E1 E2 ... EN
+      friend inline std::wostream& operator << (std::wostream& Lhs, 
+        const VecN<ElemT, Num>& Rhs)
+      {
+        std::copy(Rhs.m_Data.begin(), Rhs.m_Data.end(), 
+          std::ostream_iterator<ElemT, wchar_t>(Lhs, L" "));
+        return Lhs;
+      }
+
+      // Gets the squared length of a vector
+      friend inline ElemT LengthSquared(const VecN<ElemT, Num>& v)
+      {
+        VecN<ElemT, Num> Temp;
+        std::transform(v.m_Data.begin(), v.m_Data.end(), v.m_Data.begin(), 
+          Temp.m_Data.begin(), std::multiplies<ElemT>());
+        return std::accumulate(Temp.m_Data.begin(), Temp.m_Data.end(), 
+          static_cast<ElemT>(0));
+      }
+
+      // Gets the length of a vector
+      friend inline ElemT Length(const VecN<ElemT, Num>& v)
+      {
+        return static_cast<ElemT>(sqrt(static_cast<long double>(
+          LengthSquared(v))));
+      }
+
+      // Normalizes a vector
+      friend inline ElemT Normalize(VecN<ElemT, Num>& v)
+      {
+        ElemT Len = Length(v);
+        if (Len != static_cast<ElemT>(0))
+        {
+          std::transform(v.m_Data.cbegin(), v.m_Data.end(), v.m_Data.begin(), 
+            std::bind(std::divides<ElemT>(), std::placeholders::_1, Len));
+        }
+        return Len;
+      }
+
+      // Tests if a vector is normalized
+      friend inline bool IsNormalized(const VecN<ElemT, Num>& v, 
+        ElemT Eps = static_cast<ElemT>(1.0001f))
+      {
+        return static_cast<ElemT>(fabs(static_cast<long double>(
+          LengthSquared(v) - static_cast<ElemT>(1)))) 
+          <= static_cast<ElemT>(Eps);
+      }
+
+      // Reflection
+      friend inline VecN<ElemT, Num> Reflect(const VecN<ElemT, Num>& v, 
+        const VecN<ElemT, Num>& Normal)
+      {
+        return v - (static_cast<ElemT>(2.0) * ((v * Normal) * Normal));
+      }
+
+      // Distance
+      friend inline ElemT Distance(const VecN<ElemT, Num>& v1, 
+        const VecN<ElemT, Num>& v2)
+      {
+        return Length(v1 - v2);
+      }
+
+    private:
+      // Vector elements
+      DataT m_Data;
+    };
+
+    // Cross product
+    template <typename ElemT>
+    inline VecN<ElemT, 3> Cross(const VecN<ElemT, 3>& v1, 
+      const VecN<ElemT, 3>& v2)
+    {
+      typedef VecN<ElemT, 3> VecT;
+      return VecT(
+        (v1[VecT::YElem] * v2[VecT::ZElem]) - 
+        (v1[VecT::ZElem] * v2[VecT::YElem]), 
+        (v1[VecT::ZElem] * v2[VecT::XElem]) - 
+        (v1[VecT::XElem] * v2[VecT::ZElem]), 
+        (v1[VecT::XElem] * v2[VecT::YElem]) - 
+        (v1[VecT::YElem] * v2[VecT::XElem])
+        );
+    }
+
+    // Ease of use typedefs
+    typedef VecN<int, 2> Vec2i;
+    typedef VecN<float, 2> Vec2f;
+    typedef VecN<double, 2> Vec2d;
+    typedef VecN<int, 3> Vec3i;
+    typedef VecN<float, 3> Vec3f;
+    typedef VecN<double, 3> Vec3d;
+
+    // Assert assumptions
+    static_assert(sizeof(Vec2f) == (sizeof(float) * 2), 
+      "Size of Vec2f is incorrect!");
+    static_assert(sizeof(Vec2d) == (sizeof(double) * 2), 
+      "Size of Vec2d is incorrect!");
+    static_assert(sizeof(Vec2i) == (sizeof(int) * 2), 
+      "Size of Vec2i is incorrect!");
+
+    static_assert(sizeof(Vec3f) == (sizeof(float) * 3), 
+      "Size of Vec3f is incorrect!");
+    static_assert(sizeof(Vec3d) == (sizeof(double) * 3), 
+      "Size of Vec3d is incorrect!");
+    static_assert(sizeof(Vec3i) == (sizeof(int) * 3), 
+      "Size of Vec3i is incorrect!");
+  }
+}
Index: Include/Common/Common/WinAux.hpp
===================================================================
--- Include/Common/Common/WinAux.hpp	(revision 0)
+++ Include/Common/Common/WinAux.hpp	(revision 0)
@@ -0,0 +1,53 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
+<http://www.cypherjb.com/> <cypher.jb@gmail.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <Windows.h>
+
+// Hades
+#include "Error.hpp"
+
+namespace Hades
+{
+  namespace Windows
+  {
+    // WinAux error type
+    class WinAuxError : public virtual HadesError 
+    { };
+
+    // Get base of self
+    inline PVOID GetBaseOfSelf()
+    {
+      MEMORY_BASIC_INFORMATION MemInfo = { 0 };
+      if (!VirtualQuery(reinterpret_cast<PVOID>(&GetBaseOfSelf), &MemInfo, 
+        sizeof(MemInfo)))
+      {
+        std::error_code const LastError = GetLastErrorCode();
+        BOOST_THROW_EXCEPTION(WinAuxError() << 
+          ErrorFunction("GetBaseOfSelf") << 
+          ErrorString("Failed to query memory.") << 
+          ErrorCode(LastError));
+      }
+
+      return MemInfo.AllocationBase;
+    }
+  }
+}
Index: Include/Common/Jamfile.v2
===================================================================
--- Include/Common/Jamfile.v2	(revision 0)
+++ Include/Common/Jamfile.v2	(revision 0)
@@ -0,0 +1,12 @@
+# Common/Jamfile.v2
+
+project
+  : requirements <library>/boost//date_time/<link>static 
+  ;
+
+alias Common 
+  : /boost//date_time/<link>static 
+  : 
+  : 
+  : <include>"."
+  ;
Index: Include/HadesMem/HadesMem/Common.hpp
===================================================================
--- Include/HadesMem/HadesMem/Common.hpp	(revision 830)
+++ Include/HadesMem/HadesMem/Common.hpp	(working copy)
@@ -1,30 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Common
-#include "../Common/Common/EnsureCleanup.hpp"
-#include "../Common/Common/Error.hpp"
-#include "../Common/Common/Filesystem.hpp"
-#include "../Common/Common/I18n.hpp"
-#include "../Common/Common/Logger.hpp"
-#include "../Common/Common/StringBuffer.hpp"
-#include "../Common/Common/VecN.hpp"
-#include "../Common/Common/WinAux.hpp"
Index: Include/HadesMem/HadesMem/Memory.hpp
===================================================================
--- Include/HadesMem/HadesMem/Memory.hpp	(revision 830)
+++ Include/HadesMem/HadesMem/Memory.hpp	(working copy)
@@ -1,23 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Hades (External)
-#include "../Memory/Memory/Memory.hpp"
Index: Include/HadesMem/Jamfile.v2
===================================================================
--- Include/HadesMem/Jamfile.v2	(revision 830)
+++ Include/HadesMem/Jamfile.v2	(working copy)
@@ -1,8 +0,0 @@
-# HadesMem/Jamfile.v2
-
-alias HadesMem 
-  : 
-  : 
-  : 
-  : <include>"."
-  ;
Index: Include/Memory/Memory/Disassembler.hpp
===================================================================
--- Include/Memory/Memory/Disassembler.hpp	(revision 0)
+++ Include/Memory/Memory/Disassembler.hpp	(revision 0)
@@ -0,0 +1,79 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <Windows.h>
+
+// C++ Standard Library
+#include <string>
+#include <vector>
+
+// BeaEngine
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include "BeaEngine/BeaEngine.h"
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Disassembler data
+    struct DisasmData
+    {
+      DISASM Disasm;
+      int Len;
+      std::vector<BYTE> Raw;
+    };
+
+    // Disassembler managing class
+    class Disassembler
+    {
+    public:
+      // Disassembler exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      // Constructor
+      explicit Disassembler(MemoryMgr const& MyMemory);
+
+      // Disassemble target to string
+      std::vector<std::basic_string<TCHAR>> DisassembleToStr(PVOID Address, 
+        DWORD_PTR NumInstructions) const;
+
+      // Disassemble target
+      std::vector<DisasmData> Disassemble(PVOID Address, 
+        DWORD_PTR NumInstructions) const;
+
+    private:
+      // MemoryMgr instance
+      MemoryMgr m_MemoryMgr;
+    };
+  }
+}
Index: Include/Memory/Memory/DosHeader.hpp
===================================================================
--- Include/Memory/Memory/DosHeader.hpp	(revision 0)
+++ Include/Memory/Memory/DosHeader.hpp	(revision 0)
@@ -0,0 +1,180 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows
+#include <Windows.h>
+
+// C++ Standard Library
+#include <array>
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "PeFile.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // PE file DOS header
+    class DosHeader
+    {
+    public:
+      // DOS header error class
+      class Error : public virtual HadesMemError
+      { };
+
+      // Constructor
+      explicit DosHeader(PeFile const& MyPeFile);
+
+      // Whether magic is valid
+      bool IsMagicValid() const;
+
+      // Ensure magic is valid
+      void EnsureMagicValid() const;
+
+      // Get magic
+      WORD GetMagic() const;
+
+      // Get bytes on last page
+      WORD GetBytesOnLastPage() const;
+
+      // Get pages in file
+      WORD GetPagesInFile() const;
+
+      // Get relocations
+      WORD GetRelocations() const;
+
+      // Get size of header in paragraphs
+      WORD GetSizeOfHeaderInParagraphs() const;
+
+      // Get minimum extra paragraphs needed
+      WORD GetMinExtraParagraphs() const;
+
+      // Get maximum extra paragraphs needed
+      WORD GetMaxExtraParagraphs() const;
+
+      // Get initial SS value
+      WORD GetInitialSS() const;
+
+      // Get initial SP value
+      WORD GetInitialSP() const;
+
+      // Get checksum
+      WORD GetChecksum() const;
+
+      // Get initial IP value
+      WORD GetInitialIP() const;
+
+      // Get initial CS value
+      WORD GetInitialCS() const;
+
+      // Get file address of reloc table
+      WORD GetRelocTableFileAddr() const;
+
+      // Get overlay number
+      WORD GetOverlayNum() const;
+
+      // Get first set of reserved words
+      std::array<WORD, 4> GetReservedWords1() const;
+
+      // Get OEM ID
+      WORD GetOEMID() const;
+
+      // Get OEM info
+      WORD GetOEMInfo() const;
+
+      // Get second set of reserved words
+      std::array<WORD, 10> GetReservedWords2() const;
+
+      // Get new header offset
+      LONG GetNewHeaderOffset() const;
+
+      // Set magic
+      void SetMagic(WORD Magic) const;
+
+      // Set bytes on last page
+      void SetBytesOnLastPage(WORD BytesOnLastPage) const;
+
+      // Set pages in file
+      void SetPagesInFile(WORD PagesInFile) const;
+
+      // Set relocations
+      void SetRelocations(WORD Relocations) const;
+
+      // Set size of header in paragraphs
+      void SetSizeOfHeaderInParagraphs(WORD SizeOfHeaderInParagraphs) const;
+
+      // Set minimum extra paragraphs needed
+      void SetMinExtraParagraphs(WORD MinExtraParagraphs) const;
+
+      // Set maximum extra paragraphs needed
+      void SetMaxExtraParagraphs(WORD MaxExtraParagraphs) const;
+
+      // Set initial SS value
+      void SetInitialSS(WORD InitialSS) const;
+
+      // Set initial SP value
+      void SetInitialSP(WORD InitialSP) const;
+
+      // Set checksum
+      void SetChecksum(WORD Checksum) const;
+
+      // Set initial IP value
+      void SetInitialIP(WORD InitialIP) const;
+
+      // Set initial CS value
+      void SetInitialCS(WORD InitialCS) const;
+
+      // Set file address of reloc table
+      void SetRelocTableFileAddr(WORD RelocTableFileAddr) const;
+
+      // Set overlay number
+      void SetOverlayNum(WORD OverlayNum) const;
+
+      // Set first set of reserved words
+      void SetReservedWords1(std::array<WORD, 4> const& ReservedWords1) const;
+
+      // Set OEM ID
+      void SetOEMID(WORD OEMID) const;
+
+      // Set OEM info
+      void SetOEMInfo(WORD OEMInfo) const;
+
+      // Set second set of reserved words
+      void SetReservedWords2(std::array<WORD, 10> const& ReservedWords2) const;
+
+      // Set new header offset
+      void SetNewHeaderOffset(LONG Offset) const;
+
+    private:
+      // PE file
+      PeFile m_PeFile;
+
+      // Memory instance
+      MemoryMgr m_Memory;
+
+      // DOS header base
+      PBYTE m_pBase;
+    };
+  }
+}
Index: Include/Memory/Memory/Error.hpp
===================================================================
--- Include/Memory/Memory/Error.hpp	(revision 0)
+++ Include/Memory/Memory/Error.hpp	(revision 0)
@@ -0,0 +1,33 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Hades
+#include "Common/Error.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Base exception class
+    class HadesMemError : public virtual HadesError
+    { };
+  }
+}
Index: Include/Memory/Memory/ExportDir.hpp
===================================================================
--- Include/Memory/Memory/ExportDir.hpp	(revision 0)
+++ Include/Memory/Memory/ExportDir.hpp	(revision 0)
@@ -0,0 +1,202 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows
+#include <Windows.h>
+
+// C++ Standard Library
+#include <string>
+#include <utility>
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "PeFile.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // PE file export directory
+    class ExportDir
+    {
+    public:
+      // ExportDir error class
+      class Error : public virtual HadesMemError
+      { };
+
+      // Constructor
+      explicit ExportDir(PeFile const& MyPeFile);
+
+      // Whether export directory is valid
+      bool IsValid() const;
+
+      // Ensure export directory is valid
+      void EnsureValid() const;
+
+      // Get characteristics
+      DWORD GetCharacteristics() const;
+
+      // Set characteristics
+      void SetCharacteristics(DWORD Characteristics) const;
+
+      // Get time date stamp
+      DWORD GetTimeDateStamp() const;
+
+      // Set time date stamp
+      void SetTimeDateStamp(DWORD TimeDateStamp) const;
+
+      // Get major version
+      WORD GetMajorVersion() const;
+
+      // Set major version
+      void SetMajorVersion(WORD MajorVersion) const;
+
+      // Get minor version
+      WORD GetMinorVersion() const;
+
+      // Set minor version
+      void SetMinorVersion(WORD MinorVersion) const;
+
+      // Get module name
+      std::string GetName() const;
+
+      // Get ordinal base
+      DWORD GetOrdinalBase() const;
+
+      // Set ordinal base
+      void SetOrdinalBase(DWORD OrdinalBase) const;
+
+      // Get number of functions
+      DWORD GetNumberOfFunctions() const;
+
+      // Set number of functions
+      void SetNumberOfFunctions(DWORD NumberOfFunctions) const;
+
+      // Get number of names
+      DWORD GetNumberOfNames() const;
+
+      // Set number of names
+      void SetNumberOfNames(DWORD NumberOfNames) const;
+
+      // Get address of functions
+      DWORD GetAddressOfFunctions() const;
+
+      // Set address of functions
+      void SetAddressOfFunctions(DWORD AddressOfFunctions) const;
+
+      // Get address of names
+      DWORD GetAddressOfNames() const;
+
+      // Set address of names
+      void SetAddressOfNames(DWORD AddressOfNames) const;
+
+      // Get address of name ordinals
+      DWORD GetAddressOfNameOrdinals() const;
+
+      // Set address of name ordinals
+      void SetAddressOfNameOrdinals(DWORD AddressOfNameOrdinals) const;
+
+      // Get base of export dir
+      PBYTE GetBase() const;
+
+      // Get raw export dir
+      IMAGE_EXPORT_DIRECTORY GetExportDirRaw() const;
+
+    private:
+      // PE file
+      PeFile m_PeFile;
+
+      // Memory instance
+      MemoryMgr m_Memory;
+
+      // Base of export dir
+      mutable PBYTE m_pBase;
+    };
+
+    // PE file export data
+    class Export
+    {
+    public:
+      // Constructor
+      Export(PeFile const& MyPeFile, DWORD Ordinal);
+
+      // Get RVA
+      DWORD GetRva() const;
+
+      // Get VA
+      PVOID GetVa() const;
+
+      // Get name
+      std::string GetName() const;
+
+      // Get forwarder
+      std::string GetForwarder() const;
+      
+      // Get forwarder module name
+      std::string GetForwarderModule() const;
+      
+      // Get forwarder function name
+      std::string GetForwarderFunction() const;
+
+      // Get ordinal
+      WORD GetOrdinal() const;
+
+      // If entry is exported by name
+      bool ByName() const;
+
+      // If entry is forwarded
+      bool Forwarded() const;
+
+    private:
+      // PE file instance
+      PeFile m_PeFile;
+      
+      // Memory instance
+      MemoryMgr m_Memory;
+
+      // RVA
+      DWORD m_Rva;
+      
+      // VA
+      PVOID m_Va;
+      
+      // Name
+      std::string m_Name;
+      
+      // Forwarder
+      std::string m_Forwarder;
+      
+      // Split forwarder
+      std::pair<std::string, std::string> m_ForwarderSplit;
+      
+      // Ordinal
+      WORD m_Ordinal;
+      
+      // If entry is exported by name
+      bool m_ByName;
+      
+      // If entry is forwarded
+      bool m_Forwarded;
+    };
+  }
+}
Index: Include/Memory/Memory/ExportEnum.hpp
===================================================================
--- Include/Memory/Memory/ExportEnum.hpp	(revision 0)
+++ Include/Memory/Memory/ExportEnum.hpp	(revision 0)
@@ -0,0 +1,96 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// C++ Standard Library
+#include <memory>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/optional.hpp>
+#include <boost/iterator/iterator_facade.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Windows API
+#include <Windows.h>
+
+// Hades
+#include "ExportDir.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Section iterator
+    class ExportIter : public boost::iterator_facade<ExportIter, 
+      boost::optional<Export>, boost::incrementable_traversal_tag>
+    {
+    public:
+      // Constructor
+      explicit ExportIter(PeFile const& MyPeFile)
+        : m_PeFile(MyPeFile), 
+        m_Current()
+      {
+        ExportDir const MyExportDir(m_PeFile);
+        DWORD const NumberOfFunctions = MyExportDir.GetNumberOfFunctions();
+        if (NumberOfFunctions)
+        {
+          m_Current = Export(m_PeFile, MyExportDir.GetOrdinalBase());
+        }
+      }
+
+    private:
+      // Allow Boost.Iterator access to internals
+      friend class boost::iterator_core_access;
+
+      // For Boost.Iterator
+      void increment() 
+      {
+        ExportDir const MyExportDir(m_PeFile);
+        DWORD const NumberOfFunctions = MyExportDir.GetNumberOfFunctions();
+        DWORD const NextOrdinal = m_Current->GetOrdinal() + 1;
+        if (NextOrdinal - MyExportDir.GetOrdinalBase() < NumberOfFunctions)
+        {
+          m_Current = Export(m_PeFile, NextOrdinal);
+        }
+        else
+        {
+          m_Current = boost::optional<Export>();
+        }
+      }
+
+      // For Boost.Iterator
+      boost::optional<Export>& dereference() const
+      {
+        return m_Current;
+      }
+
+      // Memory instance
+      PeFile m_PeFile;
+
+      // Current section
+      mutable boost::optional<Export> m_Current;
+    };
+  }
+}
Index: Include/Memory/Memory/FindPattern.hpp
===================================================================
--- Include/Memory/Memory/FindPattern.hpp	(revision 0)
+++ Include/Memory/Memory/FindPattern.hpp	(revision 0)
@@ -0,0 +1,90 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <tchar.h>
+#include <Windows.h>
+
+// C++ Standard Library
+#include <map>
+#include <string>
+#include <vector>
+#include <utility>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/filesystem.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Pattern finding class
+    class FindPattern
+    {
+    public:
+      // FindPattern exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      // Constructor
+      explicit FindPattern(MemoryMgr const& MyMemory);
+      FindPattern(MemoryMgr const& MyMemory, HMODULE Module);
+
+      // Find pattern
+      PVOID Find(std::basic_string<TCHAR> const& Data, 
+        std::basic_string<TCHAR> const& Mask) const;
+
+      // Load patterns from XML file
+      void LoadFromXML(boost::filesystem::path const& Path);
+
+      // Get address map
+      std::map<std::basic_string<TCHAR>, PVOID> GetAddresses() const;
+
+      // Operator[] overload to allow retrieving addresses by name
+      PVOID operator[](std::basic_string<TCHAR> const& Name) const;
+
+    private:
+      // Search memory
+      PVOID Find(std::vector<std::pair<BYTE, bool>> const& Data) const;
+
+      // Memory manager instance
+      MemoryMgr m_Memory;
+
+      // Start and end addresses of search region
+      PBYTE m_Start;
+      PBYTE m_End;
+
+      // Map to hold addresses
+      std::map<std::basic_string<TCHAR>, PVOID> m_Addresses;
+    };
+  }
+}
Index: Include/Memory/Memory/Fwd.hpp
===================================================================
--- Include/Memory/Memory/Fwd.hpp	(revision 0)
+++ Include/Memory/Memory/Fwd.hpp	(revision 0)
@@ -0,0 +1,51 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Hades (External)
+    class Module;
+    class Region;
+    class Scanner;
+    class Process;
+    class Injector;
+    class MemoryMgr;
+    class ManualMap;
+    class FindPattern;
+    class Disassembler;
+    class Symbols;
+    
+    // Hades (Internal)
+    class Patch;
+    class PatchRaw;
+    class PatchDetour;
+    
+    // Hades (PeLib)
+    class PeFile;
+    class TlsDir;
+    class Section;
+    class DosHeader;
+    class ExportDir;
+    class NtHeaders;
+  }
+}
Index: Include/Memory/Memory/HashString.hpp
===================================================================
--- Include/Memory/Memory/HashString.hpp	(revision 0)
+++ Include/Memory/Memory/HashString.hpp	(revision 0)
@@ -0,0 +1,90 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+// IMPORTANT NOTE:
+// This is a modified version of work by 'Tor Brede Vekterli' who has licensed 
+// the original code under the Boost Software license[1]. As such, all 
+// compile-time string hashing code is licensed under the Boost Software 
+// License.
+// [1] http://www.boost.org/LICENSE_1_0.txt
+// The GPL notice above is present to cover any other code which is unrelated 
+// to the compile-time string hashing.
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/mpl/string.hpp>
+#include <boost/mpl/fold.hpp>
+#include <boost/mpl/size_t.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+namespace Hades
+{
+  namespace Memory
+  {
+    namespace Detail
+    {
+#ifdef _MSC_VER
+      // Disable 'integral constant overflow' warning.
+#pragma warning(push)
+#pragma warning(disable: 4307)
+#endif // #ifdef _MSC_VER
+
+      // Perform hashing
+      template <typename Seed, typename Value>
+      struct HashCombine
+      {
+        typedef boost::mpl::size_t<Seed::value ^ (Value::value + 0x9e3779b9 + 
+          (Seed::value << 6) + (Seed::value >> 2))> type;
+      };
+
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+      // Hash any sequence of integral wrapper types
+      template <typename Sequence>
+      struct HashSequence
+        : boost::mpl::fold<
+        Sequence, 
+        boost::mpl::size_t<0>, 
+        HashCombine<boost::mpl::_1, boost::mpl::_2>
+        >::type
+      { };
+    }
+
+    // Hash WITHOUT terminating null
+    template <typename String>
+    struct HashString 
+      : Detail::HashSequence<String>
+    { };
+
+    // Hash WITH terminating null
+    template <typename String>
+    struct HashCString 
+      : Detail::HashCombine<
+      Detail::HashSequence<String>, 
+      boost::mpl::size_t<0>
+      >::type
+    { };
+  }
+}
Index: Include/Memory/Memory/ImportDir.hpp
===================================================================
--- Include/Memory/Memory/ImportDir.hpp	(revision 0)
+++ Include/Memory/Memory/ImportDir.hpp	(revision 0)
@@ -0,0 +1,148 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows
+#include <Windows.h>
+
+// C++ Standard Library
+#include <string>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/iterator/iterator_facade.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "PeFile.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Import directory wrapper
+    class ImportDir
+    {
+    public:
+      // ImportDir error type
+      class Error : public virtual HadesMemError
+      { };
+
+      // Constructor
+      explicit ImportDir(PeFile const& MyPeFile, 
+        PIMAGE_IMPORT_DESCRIPTOR pImpDesc = nullptr);
+
+      // Whether import directory is valid
+      bool IsValid() const;
+
+      // Ensure import directory is valid
+      void EnsureValid() const;
+
+      // Get import directory base
+      PBYTE GetBase() const;
+
+      // Advance to next descriptor
+      void Advance() const;
+
+      // Get characteristics
+      DWORD GetCharacteristics() const;
+
+      // Get time and date stamp
+      DWORD GetTimeDateStamp() const;
+
+      // Get forwarder chain
+      DWORD GetForwarderChain() const;
+
+      // Get name (raw)
+      DWORD GetNameRaw() const;
+
+      // Get name
+      std::string GetName() const;
+
+      // Get first think
+      DWORD GetFirstThunk() const;
+
+    private:
+      PeFile m_PeFile;
+
+      MemoryMgr m_Memory;
+
+      mutable PIMAGE_IMPORT_DESCRIPTOR m_pImpDesc;
+    };
+
+    // Import thunk wrapper
+    class ImportThunk
+    {
+    public:
+      // ImportDir error type
+      class Error : public virtual HadesMemError
+      { };
+
+      // Constructor
+      ImportThunk(PeFile const& MyPeFile, PVOID pThunk);
+
+      // Whether thunk is valid
+      bool IsValid() const;
+
+      // Advance to next thunk
+      void Advance() const;
+
+      // Get address of data
+      DWORD_PTR GetAddressOfData() const;
+
+      // Get ordinal (raw)
+      DWORD_PTR GetOrdinalRaw() const;
+      
+      // Whether import is by ordinal
+      bool ByOrdinal() const;
+
+      // Get ordinal
+      WORD GetOrdinal() const;
+
+      // Get function
+      DWORD_PTR GetFunction() const;
+
+      // Get hint
+      WORD GetHint() const;
+
+      // Get name
+      std::string GetName() const;
+
+      // Set function
+      void SetFunction(DWORD_PTR Function) const;
+
+    private:
+      PeFile m_PeFile;
+
+      MemoryMgr m_Memory;
+
+      mutable PIMAGE_THUNK_DATA m_pThunk;
+
+      mutable PBYTE m_pBase;
+    };
+  }
+}
Index: Include/Memory/Memory/ImportEnum.hpp
===================================================================
--- Include/Memory/Memory/ImportEnum.hpp	(revision 0)
+++ Include/Memory/Memory/ImportEnum.hpp	(revision 0)
@@ -0,0 +1,144 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows
+#include <Windows.h>
+
+// C++ Standard Library
+#include <memory>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/optional.hpp>
+#include <boost/iterator/iterator_facade.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "PeFile.hpp"
+#include "ImportDir.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Section iterator
+    class ImportDirIter : public boost::iterator_facade<ImportDirIter, 
+      boost::optional<ImportDir>, boost::incrementable_traversal_tag>
+    {
+    public:
+      // Constructor
+      explicit ImportDirIter(PeFile const& MyPeFile) 
+        : m_PeFile(MyPeFile), 
+        m_Current(m_PeFile)
+      {
+        if (!m_Current->GetCharacteristics())
+        {
+          m_Current = boost::optional<ImportDir>();
+        }
+      }
+
+    private:
+      // Allow Boost.Iterator access to internals
+      friend class boost::iterator_core_access;
+
+      // For Boost.Iterator
+      void increment() 
+      {
+        auto pImpDesc = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(
+          m_Current->GetBase());
+        m_Current = ImportDir(m_PeFile, ++pImpDesc);
+        if (!m_Current->GetCharacteristics())
+        {
+          m_Current = boost::optional<ImportDir>();
+        }
+      }
+
+      // For Boost.Iterator
+      boost::optional<ImportDir>& dereference() const
+      {
+        return m_Current;
+      }
+
+      // Memory instance
+      PeFile m_PeFile;
+
+      // Current thunk pointer
+      PIMAGE_IMPORT_DESCRIPTOR m_pImpDesc;
+
+      // Current import dir
+      mutable boost::optional<ImportDir> m_Current;
+    };
+
+    // Section iterator
+    class ImportThunkIter : public boost::iterator_facade<ImportThunkIter, 
+      boost::optional<ImportThunk>, boost::incrementable_traversal_tag>
+    {
+    public:
+      // Constructor
+      explicit ImportThunkIter(PeFile const& MyPeFile, DWORD FirstThunk) 
+        : m_PeFile(MyPeFile), 
+        m_pThunk(reinterpret_cast<PIMAGE_THUNK_DATA>(m_PeFile.RvaToVa(
+          FirstThunk))), 
+        m_Current(ImportThunk(m_PeFile, m_pThunk))
+      {
+        if (!m_Current->IsValid())
+        {
+          m_Current = boost::optional<ImportThunk>();
+        }
+      }
+
+    private:
+      // Allow Boost.Iterator access to internals
+      friend class boost::iterator_core_access;
+
+      // For Boost.Iterator
+      void increment() 
+      {
+        m_Current = ImportThunk(m_PeFile, ++m_pThunk);
+        if (!m_Current->IsValid())
+        {
+          m_Current = boost::optional<ImportThunk>();
+        }
+      }
+
+      // For Boost.Iterator
+      boost::optional<ImportThunk>& dereference() const
+      {
+        return m_Current;
+      }
+
+      // Memory instance
+      PeFile m_PeFile;
+
+      // Current thunk pointer
+      PIMAGE_THUNK_DATA m_pThunk;
+
+      // Current import thunk
+      mutable boost::optional<ImportThunk> m_Current;
+    };
+  }
+}
Index: Include/Memory/Memory/Injector.hpp
===================================================================
--- Include/Memory/Memory/Injector.hpp	(revision 0)
+++ Include/Memory/Memory/Injector.hpp	(revision 0)
@@ -0,0 +1,81 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <Windows.h>
+
+// C++ Standard Library
+#include <tuple>
+#include <string>
+#include <utility>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/filesystem.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "MemoryMgr.hpp"
+#include "Common/I18n.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // DLL injection class
+    class Injector
+    {
+    public:
+      // Injector exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      // Constructor
+      explicit Injector(MemoryMgr const& MyMemory);
+
+      // Inject DLL
+      HMODULE InjectDll(boost::filesystem::path const& Path, 
+        bool PathResolution = true) const;
+
+      // Call export
+      DWORD_PTR CallExport(boost::filesystem::path const& ModulePath, 
+        HMODULE ModuleRemote, std::string const& Export) const;
+
+    private:
+      // MemoryMgr instance
+      MemoryMgr m_Memory;
+    };
+    
+    // Create process (as suspended) and inject DLL
+    std::tuple<MemoryMgr, HMODULE, DWORD_PTR> CreateAndInject(
+      boost::filesystem::path const& Path, 
+      boost::filesystem::path const& WorkDir, 
+      std::basic_string<TCHAR> const& Args, 
+      std::basic_string<TCHAR> const& Module, 
+      std::string const& Export);
+  }
+}
Index: Include/Memory/Memory/ManualMap.hpp
===================================================================
--- Include/Memory/Memory/ManualMap.hpp	(revision 0)
+++ Include/Memory/Memory/ManualMap.hpp	(revision 0)
@@ -0,0 +1,75 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <Windows.h>
+
+// C++ Standard Library
+#include <string>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/filesystem.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Manual mapping class
+    class ManualMap
+    {
+    public:
+      // ManualMap exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      // Constructor
+      explicit ManualMap(MemoryMgr const& MyMemory);
+
+      // Manually map DLL
+      PVOID Map(boost::filesystem::path const& Path, 
+        std::string const& Export = "", bool InjectHelper = true) const;
+
+    private:
+      // Map sections
+      void MapSections(PeFile& MyPeFile, PVOID RemoteAddr) const;
+
+      // Fix imports
+      void FixImports(PeFile& MyPeFile) const;
+
+      // Fix relocations
+      void FixRelocations(PeFile& MyPeFile, PVOID RemoteAddr) const;
+
+      // MemoryMgr instance
+      MemoryMgr m_Memory;
+    };
+  }
+}
Index: Include/Memory/Memory/Memory.hpp
===================================================================
--- Include/Memory/Memory/Memory.hpp	(revision 0)
+++ Include/Memory/Memory/Memory.hpp	(revision 0)
@@ -0,0 +1,38 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Hades (External)
+#include "Module.hpp"
+#include "Region.hpp"
+#include "Symbol.hpp"
+#include "Process.hpp"
+#include "Scanner.hpp"
+#include "Injector.hpp"
+#include "ManualMap.hpp"
+#include "MemoryMgr.hpp"
+#include "FindPattern.hpp"
+#include "Disassembler.hpp"
+
+// Hades (Internal)
+#include "Patcher.hpp"
+
+// Hades (PeLib)
+#include "PeLib.hpp"
Index: Include/Memory/Memory/MemoryMgr.hpp
===================================================================
--- Include/Memory/Memory/MemoryMgr.hpp	(revision 0)
+++ Include/Memory/Memory/MemoryMgr.hpp	(revision 0)
@@ -0,0 +1,517 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <tchar.h>
+#include <Windows.h>
+
+// C++ Standard Library
+#include <memory>
+#include <string>
+#include <vector>
+#include <type_traits>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#pragma warning(disable: 4706)
+#endif // #ifdef _MSC_VER
+#include <boost/filesystem.hpp>
+#include <boost/noncopyable.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// AsmJit
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include "AsmJit/AsmJit.h"
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Error.hpp"
+#include "Process.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Memory managing class
+    class MemoryMgr
+    {
+    public:
+      // Memory exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      // Open process from process ID
+      explicit MemoryMgr(DWORD ProcID);
+
+      // Open process from process name
+      explicit MemoryMgr(std::basic_string<TCHAR> const& ProcName);
+
+      // Open process from window name and class
+      MemoryMgr(std::basic_string<TCHAR> const& WindowName, 
+        std::basic_string<TCHAR> const& ClassName);
+
+      // Calling conventions
+      enum CallConv
+      {
+        CallConv_CDECL, 
+        CallConv_STDCALL, 
+        CallConv_THISCALL, 
+        CallConv_FASTCALL, 
+        CallConv_X64, 
+        CallConv_Default
+      };
+
+      // Call remote function
+      DWORD_PTR Call(PVOID Address, std::vector<PVOID> const& Args, 
+        CallConv MyCallConv = CallConv_Default) const;
+
+      // Read memory (POD types)
+      template <typename T>
+      T Read(PVOID Address, typename std::enable_if<std::is_pod<T>::value, T>::
+        type* Dummy = 0) const;
+
+      // Read memory (string types)
+      template <typename T>
+      T Read(PVOID Address, typename std::enable_if<std::is_same<T, std::
+        basic_string<typename T::value_type>>::value, T>::type* Dummy = 0) 
+        const;
+
+      // Read memory (vector types)
+      template <typename T>
+      T Read(PVOID Address, std::size_t Size, typename std::enable_if<std::
+        is_same<T, std::vector<typename T::value_type>>::value, T>::type* 
+        Dummy = 0) const;
+
+      // Write memory (POD types)
+      template <typename T>
+      void Write(PVOID Address, T const& Data, typename std::enable_if<std::
+        is_pod<T>::value, T>::type* Dummy = 0) const;
+
+      // Write memory (string types)
+      template <typename T>
+      void Write(PVOID Address, T const& Data, typename std::enable_if<std::
+        is_same<T, std::basic_string<typename T::value_type>>::value, T>::
+        type* Dummy = 0) const;
+
+      // Write memory (vector types)
+      template <typename T>
+      void Write(PVOID Address, T const& Data, typename std::enable_if<std::
+        is_same<T, std::vector<typename T::value_type>>::value, T>::type* 
+        Dummy = 0) const;
+
+      // Whether an address is currently readable
+      bool CanRead(PVOID Address) const;
+
+      // Whether an address is currently writable
+      bool CanWrite(PVOID Address) const;
+
+      // Whether an address is contained within a guard page
+      bool  IsGuard(PVOID Address) const;
+
+      // Allocate memory
+      PVOID Alloc(SIZE_T Size) const;
+
+      // Free memory
+      void Free(PVOID Address) const;
+
+      // Get process ID of target
+      DWORD GetProcessID() const;
+
+      // Get process handle of target
+      HANDLE GetProcessHandle() const;
+
+      // Get address of export in remote process (by name)
+      FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
+        boost::filesystem::path const& Module, std::string const& Function) 
+        const;
+
+      // Get address of export in remote process (by ordinal)
+      FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
+        boost::filesystem::path const& Module, WORD Function) 
+        const;
+
+      // Flush instruction cache
+      void FlushCache(PVOID Address, SIZE_T Size) const;
+
+    private:
+      // Target process
+      Process m_Process;
+    };
+
+    // RAII class for remote memory allocation and freeing
+    class AllocAndFree : private boost::noncopyable
+    {
+    public:
+      AllocAndFree(MemoryMgr const& MyMemoryMgr, SIZE_T Size) 
+        : m_pMemory(&MyMemoryMgr), 
+        m_Address(m_pMemory->Alloc(Size)) 
+      { }
+      
+      void Free() const
+      {
+        m_pMemory->Free(m_Address);
+      }
+
+      ~AllocAndFree()
+      {
+        try
+        {
+          Free();
+        }
+        catch (MemoryMgr::Error const& /*e*/)
+        { }
+      }
+
+      PVOID GetAddress() const 
+      {
+        return m_Address;
+      }
+
+    private:
+      MemoryMgr const* m_pMemory;
+      PVOID m_Address;
+    };
+
+    // Read memory (POD types)
+    template <typename T>
+    T MemoryMgr::Read(PVOID Address, typename std::enable_if<std::is_pod<T>::
+      value, T>::type* /*Dummy*/) const 
+    {
+      // Treat attempt to read from a guard page as an error
+      if (IsGuard(Address))
+      {
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Read") << 
+          ErrorString("Attempt to read from guard page."));
+      }
+      
+      // Whether we can read the given address
+      bool const CanReadMem = CanRead(Address);
+
+      // Set page protection for reading
+      DWORD OldProtect = 0;
+      if (!CanReadMem)
+      {
+        if (!VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
+          PAGE_EXECUTE_READWRITE, &OldProtect))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Error() << 
+            ErrorFunction("MemoryMgr::Read") << 
+            ErrorString("Could not change process memory protection.") << 
+            ErrorCode(LastError));
+        }
+      }
+
+      // Read data
+      T Out = T();
+      SIZE_T BytesRead = 0;
+      if (!ReadProcessMemory(m_Process.GetHandle(), Address, &Out, sizeof(T), 
+        &BytesRead) || BytesRead != sizeof(T))
+      {
+        if (!CanReadMem)
+        {
+          // Restore original page protections
+          VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
+            OldProtect, &OldProtect);
+        }
+
+        std::error_code const LastError = GetLastErrorCode();
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Read") << 
+          ErrorString("Could not read process memory.") << 
+          ErrorCode(LastError));
+      }
+
+      // Restore original page protections
+      if (!CanReadMem)
+      {
+        if (!VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
+          OldProtect, &OldProtect))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Error() << 
+            ErrorFunction("MemoryMgr::Read") << 
+            ErrorString("Could not restore process memory protection.") << 
+            ErrorCode(LastError));
+        }
+      }
+
+      return Out;
+    }
+
+    // Read memory (string types)
+    template <typename T>
+    T MemoryMgr::Read(PVOID Address, typename std::enable_if<std::is_same<T, 
+      std::basic_string<typename T::value_type>>::value, T>::type* /*Dummy*/) 
+      const
+    {
+      // Character type
+      typedef typename T::value_type CharT;
+
+      // Create buffer to store results
+      std::basic_string<CharT> Buffer;
+
+      // Loop until a null terminator is found
+      for (CharT* AddressReal = static_cast<CharT*>(Address);; ++AddressReal)
+      {
+        // Read current character
+        CharT const Current = Read<CharT>(AddressReal);
+
+        // Return generated string on null terminator
+        if (Current == 0)
+        {
+          return Buffer;
+        }
+
+        // Add character to buffer
+        Buffer += Current;
+      }
+    }
+
+    // Read memory (vector types)
+    template <typename T>
+    T MemoryMgr::Read(PVOID Address, std::size_t Size, typename std::enable_if<
+      std::is_same<T, std::vector<typename T::value_type>>::value, T>::type* 
+      /*Dummy*/) const
+    {
+      // Ensure type to be read is POD
+      static_assert(std::is_pod<typename T::value_type>::value, 
+        "MemoryMgr::Read: Value type of vector must be POD.");
+
+      // Treat attempt to read from a guard page as an error
+      if (IsGuard(Address))
+      {
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Read") << 
+          ErrorString("Attempt to read from guard page."));
+      }
+
+      // Calculate 'raw' size of data
+      std::size_t RawSize = Size * sizeof(typename T::value_type);
+
+      // Whether we can read the given address
+      bool const CanReadMem = CanRead(Address);
+
+      // Set page protection for reading
+      DWORD OldProtect = 0;
+      if (!CanReadMem)
+      {
+        if (!VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
+          PAGE_EXECUTE_READWRITE, &OldProtect))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Error() << 
+            ErrorFunction("MemoryMgr::Read") << 
+            ErrorString("Could not change process memory protection.") << 
+            ErrorCode(LastError));
+        }
+      }
+
+      // Read data
+      T Buffer(Size);
+      SIZE_T BytesRead = 0;
+      if (!ReadProcessMemory(m_Process.GetHandle(), Address, &Buffer[0], 
+        RawSize, &BytesRead) || BytesRead != RawSize)
+      {
+        if (!CanReadMem)
+        {
+          // Restore original page protections
+          VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
+            OldProtect, &OldProtect);
+        }
+
+        std::error_code const LastError = GetLastErrorCode();
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Read") << 
+          ErrorString("Could not read process memory.") << 
+          ErrorCode(LastError));
+      }
+
+      // Restore original page protections
+      if (!CanReadMem)
+      {
+        if (!VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
+          OldProtect, &OldProtect))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Error() << 
+            ErrorFunction("MemoryMgr::Read") << 
+            ErrorString("Could not restore process memory protection.") << 
+            ErrorCode(LastError));
+        }
+      }
+
+      // Return buffer
+      return Buffer;
+    }
+
+    // Write memory (POD types)
+    template <typename T>
+    void MemoryMgr::Write(PVOID Address, T const& Data, typename std::
+      enable_if<std::is_pod<T>::value, T>::type* /*Dummy*/) const 
+    {
+      // Treat attempt to write to a guard page as an error
+      if (IsGuard(Address))
+      {
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Write") << 
+          ErrorString("Attempt to write to guard page."));
+      }
+
+      // Set page protections for writing
+      DWORD OldProtect = 0;
+      if (!VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
+        PAGE_EXECUTE_READWRITE, &OldProtect))
+      {
+        std::error_code const LastError = GetLastErrorCode();
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Write") << 
+          ErrorString("Could not change process memory protection.") << 
+          ErrorCode(LastError));
+      }
+
+      // Write data
+      SIZE_T BytesWritten = 0;
+      if (!WriteProcessMemory(m_Process.GetHandle(), Address, &Data, sizeof(T), 
+        &BytesWritten) || BytesWritten != sizeof(T))
+      {
+        // Restore original page protections
+        VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), OldProtect, 
+          &OldProtect);
+
+        std::error_code const LastError = GetLastErrorCode();
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Write") << 
+          ErrorString("Could not write process memory.") << 
+          ErrorCode(LastError));
+      }
+
+      // Restore original page protections
+      if (!VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
+        OldProtect, &OldProtect))
+      {
+        std::error_code const LastError = GetLastErrorCode();
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Write") << 
+          ErrorString("Could not restore process memory protection.") << 
+          ErrorCode(LastError));
+      }
+    }
+
+    // Write memory (string types)
+    template <typename T>
+    void MemoryMgr::Write(PVOID Address, T const& Data, 
+      typename std::enable_if<std::is_same<T, std::basic_string<typename T::
+      value_type>>::value, T>::type* /*Dummy*/) const
+    {
+      // Character type
+      typedef typename T::value_type CharT;
+
+      // Convert string to vector
+      std::vector<CharT> DataReal(Data.cbegin(), Data.cend());
+      DataReal.push_back(0);
+
+      // Write string to memory
+      this->Write(Address, DataReal);
+    }
+
+    // Write memory (vector types)
+    template <typename T>
+    void MemoryMgr::Write(PVOID Address, T const& Data, typename std::
+      enable_if<std::is_same<T, std::vector<typename T::value_type>>::value, 
+      T>::type* /*Dummy*/) const
+    {
+      // Ensure type to be written is POD
+      static_assert(std::is_pod<typename T::value_type>::value, 
+        "MemoryMgr::Write: Value type of vector must be POD.");
+
+      // Treat attempt to write to a guard page as an error
+      if (IsGuard(Address))
+      {
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Write") << 
+          ErrorString("Attempt to write to guard page."));
+      }
+
+      // Calculate 'raw' size of data
+      std::size_t RawSize = Data.size() * sizeof(typename T::value_type);
+
+      // Whether we can write to the given address
+      bool const CanWriteMem = CanWrite(Address);
+
+      // Set page protection for writing
+      DWORD OldProtect = 0;
+      if (!CanWriteMem)
+      {
+        if (!VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
+          PAGE_EXECUTE_READWRITE, &OldProtect))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Error() << 
+            ErrorFunction("MemoryMgr::Write") << 
+            ErrorString("Could not change process memory protection.") << 
+            ErrorCode(LastError));
+        }
+      }
+
+      // Read data
+      SIZE_T BytesWritten = 0;
+      if (!WriteProcessMemory(m_Process.GetHandle(), Address, &Data[0], 
+        RawSize, &BytesWritten) || BytesWritten != RawSize)
+      {
+        if (!CanWriteMem)
+        {
+          // Restore original page protections
+          VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
+            OldProtect, &OldProtect);
+        }
+
+        std::error_code const LastError = GetLastErrorCode();
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("MemoryMgr::Write") << 
+          ErrorString("Could not read process memory.") << 
+          ErrorCode(LastError));
+      }
+
+      // Restore original page protections
+      if (!CanWriteMem)
+      {
+        if (!VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
+          OldProtect, &OldProtect))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Error() << 
+            ErrorFunction("MemoryMgr::Write") << 
+            ErrorString("Could not restore process memory protection.") << 
+            ErrorCode(LastError));
+        }
+      }
+    }
+  }
+}
Index: Include/Memory/Memory/Module.hpp
===================================================================
--- Include/Memory/Memory/Module.hpp	(revision 0)
+++ Include/Memory/Memory/Module.hpp	(revision 0)
@@ -0,0 +1,174 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <tchar.h>
+#include <Windows.h>
+#include <TlHelp32.h>
+
+// C++ Standard Library
+#include <string>
+#include <memory>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/optional.hpp>
+#include <boost/iterator/iterator_facade.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "MemoryMgr.hpp"
+#include "Common/EnsureCleanup.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Module managing class
+    class Module
+    {
+    public:
+      // Module exception type
+      class Error : public virtual HadesMemError
+      { };
+
+      // Create module
+      Module(MemoryMgr const& MyMemory, MODULEENTRY32 const& ModuleEntry);
+
+      // Find module by handle
+      Module(MemoryMgr const& MyMemory, HMODULE Handle);
+
+      // Find module by name
+      Module(MemoryMgr const& MyMemory, 
+        std::basic_string<TCHAR> const& ModuleName);
+
+      // Get module base
+      HMODULE GetBase() const;
+      // Get module size
+      DWORD GetSize() const;
+
+      // Get module name
+      std::basic_string<TCHAR> GetName() const;
+      // Get module path
+      std::basic_string<TCHAR> GetPath() const;
+
+    private:
+      // Memory instance
+      MemoryMgr m_Memory;
+
+      // Module base address
+      HMODULE m_Base;
+      // Module size
+      DWORD m_Size;
+      // Module name
+      std::basic_string<TCHAR> m_Name;
+      // Module path
+      std::basic_string<TCHAR> m_Path;
+    };
+
+    // Module iterator
+    class ModuleListIter : public boost::iterator_facade<ModuleListIter, 
+      boost::optional<Module>, boost::incrementable_traversal_tag>, 
+      private boost::noncopyable
+    {
+    public:
+      // Constructor
+      ModuleListIter(MemoryMgr const& MyMemory) 
+        : m_Memory(MyMemory), 
+        m_Snap(), 
+        m_Current()
+      {
+        // Grab a new snapshot of the process
+        m_Snap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, m_Memory.
+          GetProcessID());
+        if (m_Snap == INVALID_HANDLE_VALUE)
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Module::Error() << 
+            ErrorFunction("ModuleEnum::First") << 
+            ErrorString("Could not get module snapshot.") << 
+            ErrorCode(LastError));
+        }
+
+        // Get first module entry
+        MODULEENTRY32 MyModuleEntry = { sizeof(MyModuleEntry) };
+        if (!Module32First(m_Snap, &MyModuleEntry))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Module::Error() << 
+            ErrorFunction("ModuleEnum::First") << 
+            ErrorString("Could not get module info.") << 
+            ErrorCode(LastError));
+        }
+
+        m_Current = Module(m_Memory, MyModuleEntry);
+      }
+
+    private:
+      // Allow Boost.Iterator access to internals
+      friend class boost::iterator_core_access;
+
+      // For Boost.Iterator
+      void increment() 
+      {
+        MODULEENTRY32 MyModuleEntry = { sizeof(MyModuleEntry) };
+        if (!Module32Next(m_Snap, &MyModuleEntry))
+        {
+          if (GetLastError() != ERROR_NO_MORE_FILES)
+          {
+            std::error_code const LastError = GetLastErrorCode();
+            BOOST_THROW_EXCEPTION(Module::Error() << 
+              ErrorFunction("ModuleEnum::Next") << 
+              ErrorString("Error enumerating module list.") << 
+              ErrorCode(LastError));
+          }
+
+          m_Current = boost::optional<Module>();
+        }
+        else
+        {
+          m_Current = Module(m_Memory, MyModuleEntry);
+        }
+      }
+
+      // For Boost.Iterator
+      boost::optional<Module>& dereference() const
+      {
+        return m_Current;
+      }
+
+      // Memory instance
+      MemoryMgr m_Memory;
+
+      // Toolhelp32 snapshot handle
+      Windows::EnsureCloseSnap m_Snap;
+
+      // Current module
+      mutable boost::optional<Module> m_Current;
+    };
+  }
+}
Index: Include/Memory/Memory/NtHeaders.hpp
===================================================================
--- Include/Memory/Memory/NtHeaders.hpp	(revision 0)
+++ Include/Memory/Memory/NtHeaders.hpp	(revision 0)
@@ -0,0 +1,335 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows
+#include <Windows.h>
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "PeFile.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // PE file NT headers
+    class NtHeaders
+    {
+    public:
+      // NT headers error class
+      class Error : public virtual HadesMemError
+      { };
+
+      // Data directory entries
+      enum DataDir
+      {
+        DataDir_Export, 
+        DataDir_Import, 
+        DataDir_Resource, 
+        DataDir_Exception, 
+        DataDir_Security, 
+        DataDir_BaseReloc, 
+        DataDir_Debug, 
+        DataDir_Architecture, 
+        DataDir_GlobalPTR, 
+        DataDir_TLS, 
+        DataDir_LoadConfig, 
+        DataDir_BoundImport, 
+        DataDir_IAT, 
+        DataDir_DelayImport, 
+        DataDir_COMDescriptor
+      };
+
+      // Constructor
+      explicit NtHeaders(PeFile const& MyPeFile);
+
+      // Get base of NT headers
+      PBYTE GetBase() const;
+
+      // Whether signature is valid
+      bool IsSignatureValid() const;
+
+      // Ensure signature is valid
+      void EnsureSignatureValid() const;
+
+      // Get signature
+      DWORD GetSignature() const;
+
+      // Set signature
+      void SetSignature(DWORD Signature) const;
+
+      // Get machine
+      WORD GetMachine() const;
+
+      // Set machine
+      void SetMachine(WORD Machine) const;
+
+      // Get number of sections
+      WORD GetNumberOfSections() const;
+
+      // Set number of sections
+      void SetNumberOfSections(WORD NumberOfSections) const;
+
+      // Get time date stamp
+      DWORD GetTimeDateStamp() const;
+
+      // Set time date stamp
+      void SetTimeDateStamp(DWORD TimeDateStamp) const;
+
+      // Get pointer to symbol table
+      DWORD GetPointerToSymbolTable() const;
+
+      // Set pointer to symbol table
+      void SetPointerToSymbolTable(DWORD PointerToSymbolTable) const;
+
+      // Get number of symbols
+      DWORD GetNumberOfSymbols() const;
+
+      // Set number of symbols
+      void SetNumberOfSymbols(DWORD NumberOfSymbols) const;
+
+      // Get size of optional header
+      WORD GetSizeOfOptionalHeader() const;
+
+      // Set size of optional header
+      void SetSizeOfOptionalHeader(WORD SizeOfOptionalHeader) const;
+
+      // Get characteristics
+      WORD GetCharacteristics() const;
+
+      // Set characteristics
+      void SetCharacteristics(WORD Characteristics) const;
+
+      // Get magic
+      WORD GetMagic() const;
+
+      // Set magic
+      void SetMagic(WORD Magic) const;
+
+      // Get major linker version
+      BYTE GetMajorLinkerVersion() const;
+
+      // Set major linker version
+      void SetMajorLinkerVersion(BYTE MajorLinkerVersion) const;
+
+      // Get minor linker version
+      BYTE GetMinorLinkerVersion() const;
+
+      // Set major linker version
+      void SetMinorLinkerVersion(BYTE MinorLinkerVersion) const;
+
+      // Get minor linker version
+      DWORD GetSizeOfCode() const;
+
+      // Set major linker version
+      void SetSizeOfCode(DWORD SizeOfCode) const;
+
+      // Get minor linker version
+      DWORD GetSizeOfInitializedData() const;
+
+      // Set major linker version
+      void SetSizeOfInitializedData(DWORD SizeOfInitializedData) const;
+
+      // Get minor linker version
+      DWORD GetSizeOfUninitializedData() const;
+
+      // Set major linker version
+      void SetSizeOfUninitializedData(DWORD SizeOfUninitializedData) const;
+
+      // Get minor linker version
+      DWORD GetAddressOfEntryPoint() const;
+
+      // Set major linker version
+      void SetAddressOfEntryPoint(DWORD AddressOfEntryPoint) const;
+
+      // Get base of code
+      DWORD GetBaseOfCode() const;
+
+      // Set base of code
+      void SetBaseOfCode(DWORD BaseOfCode) const;
+
+#if defined(_M_IX86) 
+      // Get base of data
+      DWORD GetBaseOfData() const;
+
+      // Set base of data
+      void SetBaseOfData(DWORD BaseOfData) const;
+#endif
+
+      // Get base of code
+      ULONG_PTR GetImageBase() const;
+
+      // Set base of code
+      void SetImageBase(ULONG_PTR ImageBase) const;
+
+      // Get base of code
+      DWORD GetSectionAlignment() const;
+
+      // Set base of code
+      void SetSectionAlignment(DWORD SectionAlignment) const;
+
+      // Get base of code
+      DWORD GetFileAlignment() const;
+
+      // Set base of code
+      void SetFileAlignment(DWORD FileAlignment) const;
+
+      // Get base of code
+      WORD GetMajorOperatingSystemVersion() const;
+
+      // Set base of code
+      void SetMajorOperatingSystemVersion(
+        WORD MajorOperatingSystemVersion) const;
+
+      // Get base of code
+      WORD GetMinorOperatingSystemVersion() const;
+
+      // Set base of code
+      void SetMinorOperatingSystemVersion(
+        WORD MinorOperatingSystemVersion) const;
+
+      // Get base of code
+      WORD GetMajorImageVersion() const;
+
+      // Set base of code
+      void SetMajorImageVersion(WORD MajorImageVersion) const;
+
+      // Get base of code
+      WORD GetMinorImageVersion() const;
+
+      // Set base of code
+      void SetMinorImageVersion(WORD MinorImageVersion) const;
+
+      // Get base of code
+      WORD GetMajorSubsystemVersion() const;
+
+      // Set base of code
+      void SetMajorSubsystemVersion(WORD MajorSubsystemVersion) const;
+
+      // Get base of code
+      WORD GetMinorSubsystemVersion() const;
+
+      // Set base of code
+      void SetMinorSubsystemVersion(WORD MinorSubsystemVersion) const;
+
+      // Get base of code
+      DWORD GetWin32VersionValue() const;
+
+      // Set base of code
+      void SetWin32VersionValue(DWORD Win32VersionValue) const;
+
+      // Get size of image
+      DWORD GetSizeOfImage() const;
+      
+      // Set size of image
+      void SetSizeOfImage(DWORD SizeOfImage) const;
+
+      // Get base of code
+      DWORD GetSizeOfHeaders() const;
+
+      // Set base of code
+      void SetSizeOfHeaders(DWORD SizeOfHeaders) const;
+
+      // Get base of code
+      DWORD GetCheckSum() const;
+
+      // Set base of code
+      void SetCheckSum(DWORD CheckSum) const;
+
+      // Get base of code
+      WORD GetSubsystem() const;
+
+      // Set base of code
+      void SetSubsystem(WORD Subsystem) const;
+
+      // Get base of code
+      WORD GetDllCharacteristics() const;
+
+      // Set base of code
+      void SetDllCharacteristics(WORD DllCharacteristics) const;
+
+      // Get base of code
+      ULONG_PTR GetSizeOfStackReserve() const;
+
+      // Set base of code
+      void SetSizeOfStackReserve(ULONG_PTR SizeOfStackReserve) const;
+
+      // Get base of code
+      ULONG_PTR GetSizeOfStackCommit() const;
+
+      // Set base of code
+      void SetSizeOfStackCommit(ULONG_PTR SizeOfStackCommit) const;
+
+      // Get base of code
+      ULONG_PTR GetSizeOfHeapReserve() const;
+
+      // Set base of code
+      void SetSizeOfHeapReserve(ULONG_PTR SizeOfHeapReserve) const;
+
+      // Get base of code
+      ULONG_PTR GetSizeOfHeapCommit() const;
+
+      // Set base of code
+      void SetSizeOfHeapCommit(ULONG_PTR SizeOfHeapCommit) const;
+
+      // Get base of code
+      DWORD GetLoaderFlags() const;
+
+      // Set base of code
+      void SetLoaderFlags(DWORD LoaderFlags) const;
+
+      // Get base of code
+      DWORD GetNumberOfRvaAndSizes() const;
+
+      // Set base of code
+      void SetNumberOfRvaAndSizes(DWORD NumberOfRvaAndSizes) const;
+
+      // Get base of code
+      DWORD GetDataDirectoryVirtualAddress(DataDir MyDataDir) const;
+
+      // Set base of code
+      void SetDataDirectoryVirtualAddress(DataDir MyDataDir, 
+        DWORD DataDirectoryVirtualAddress) const;
+
+      // Get base of code
+      DWORD GetDataDirectorySize(DataDir MyDataDir) const;
+
+      // Set base of code
+      void SetDataDirectorySize(DataDir MyDataDir, 
+        DWORD DataDirectorySize) const;
+
+      // Get raw NT headers
+      IMAGE_NT_HEADERS GetHeadersRaw() const;
+
+    private:
+      // PE file
+      PeFile m_PeFile;
+
+      // Memory instance
+      MemoryMgr m_Memory;
+
+      // Base address
+      mutable PBYTE m_pBase;
+    };
+  }
+}
Index: Include/Memory/Memory/Patcher.hpp
===================================================================
--- Include/Memory/Memory/Patcher.hpp	(revision 0)
+++ Include/Memory/Memory/Patcher.hpp	(revision 0)
@@ -0,0 +1,128 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <Windows.h>
+
+// C++ Standard Library
+#include <vector>
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Patch class.
+    // Abstract base class for different patch types.
+    class Patch
+    {
+    public:
+      // Patch exception type
+      class Error : public virtual HadesMemError
+      { };
+
+      // Constructor
+      explicit Patch(MemoryMgr const& MyMemory);
+
+      // Destructor
+      virtual ~Patch();
+
+      // Apply patch
+      virtual void Apply() = 0;
+      // Remove patch
+      virtual void Remove() = 0;
+
+      // Whether patch is currently applied
+      bool IsApplied() const;
+
+    protected:
+      // Memory manager instance
+      MemoryMgr m_Memory;
+
+      // Whether patch is currently applied
+      bool m_Applied;
+    };
+
+    // Raw patch (a.k.a. 'byte patch').
+    // Used to perform a simple byte patch on a target.
+    class PatchRaw : public Patch
+    {
+    public:
+      // Constructor
+      PatchRaw(MemoryMgr const& MyMemory, PVOID Target, 
+        std::vector<BYTE> const& Data);
+
+      // Apply patch
+      virtual void Apply();
+
+      // Remove patch
+      virtual void Remove();
+
+    private:
+      // Patch target
+      PVOID m_Target;
+
+      // New data
+      std::vector<BYTE> m_Data;
+
+      // Original data
+      std::vector<BYTE> m_Orig;
+    };
+
+    // Detour patch (a.k.a. 'hook').
+    // Performs an 'inline' or 'jump' hook on the target.
+    class PatchDetour : public Patch
+    {
+    public:
+      // Constructor
+      PatchDetour(MemoryMgr const& MyMemory, PVOID Target, PVOID Detour);
+
+      // Apply patch
+      virtual void Apply();
+      
+      // Remove patch
+      virtual void Remove();
+
+      // Get pointer to trampoline
+      PVOID GetTrampoline() const;
+
+    private:
+      // Write jump to target at address
+      void WriteJump(PVOID Address, PVOID Target);
+
+      // Get size of jump instruction for current platform
+      unsigned int GetJumpSize() const;
+
+      // Target address
+      PVOID m_Target;
+      // Detour address
+      PVOID m_Detour;
+      // Trampoline address
+      PVOID m_Trampoline;
+      // Backup code
+      std::vector<BYTE> m_Orig;
+    };
+  }
+}
Index: Include/Memory/Memory/PEFile.hpp
===================================================================
--- Include/Memory/Memory/PEFile.hpp	(revision 0)
+++ Include/Memory/Memory/PEFile.hpp	(revision 0)
@@ -0,0 +1,75 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows
+#include <Windows.h>
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // PE file format wrapper
+    class PeFile
+    {
+    public:
+      // PeFile exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      enum FileType
+      {
+        FileType_Image, 
+        FileType_Data
+      };
+
+      // Constructor
+      PeFile(MemoryMgr const& MyMemory, PVOID Address, 
+        FileType Type = FileType_Image);
+
+      // Get memory manager
+      MemoryMgr GetMemoryMgr() const;
+
+      // Get base address
+      PBYTE GetBase() const;
+
+      // Convert RVA to VA
+      PVOID RvaToVa(DWORD Rva) const;
+
+      // Get file type
+      FileType GetType() const;
+
+    protected:
+      // Memory instance
+      MemoryMgr m_Memory;
+
+      // Base address
+      PBYTE m_pBase;
+
+      // File type
+      FileType m_Type;
+    };
+  }
+}
Index: Include/Memory/Memory/PeLib.hpp
===================================================================
--- Include/Memory/Memory/PeLib.hpp	(revision 0)
+++ Include/Memory/Memory/PeLib.hpp	(revision 0)
@@ -0,0 +1,33 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Hades (PeLib)
+#include "PeFile.hpp"
+#include "TlsDir.hpp"
+#include "Section.hpp"
+#include "ImportDir.hpp"
+#include "ExportDir.hpp"
+#include "DosHeader.hpp"
+#include "ExportDir.hpp"
+#include "NtHeaders.hpp"
+#include "ImportEnum.hpp"
+#include "ExportEnum.hpp"
+#include "SectionEnum.hpp"
Index: Include/Memory/Memory/Process.hpp
===================================================================
--- Include/Memory/Memory/Process.hpp	(revision 0)
+++ Include/Memory/Memory/Process.hpp	(revision 0)
@@ -0,0 +1,278 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <tchar.h>
+#include <Windows.h>
+#include <TlHelp32.h>
+
+// C++ Standard Library
+#include <string>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/optional.hpp>
+#include <boost/filesystem.hpp>
+#include <boost/iterator/iterator_facade.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "Common/EnsureCleanup.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Process managing class
+    class Process
+    {
+    public:
+      // Process exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      // Open process from process ID
+      explicit Process(DWORD ProcID);
+
+      // Open process from process name
+      explicit Process(std::basic_string<TCHAR> const& ProcName);
+
+      // Open process from window name and class
+      Process(std::basic_string<TCHAR> const& WindowName, 
+        std::basic_string<TCHAR> const& ClassName);
+
+      // Copy constructor
+      Process(Process const& MyProcess);
+
+      // Copy assignment
+      Process& operator=(Process const& MyProcess);
+
+      // Move constructor
+      Process(Process&& MyProcess);
+
+      // Move assignment
+      Process& operator=(Process&& MyProcess);
+
+      // Get process handle
+      HANDLE GetHandle() const;
+      
+      // Get process ID
+      DWORD GetID() const;
+      
+      // Get process path
+      boost::filesystem::path GetPath() const;
+
+    private:
+      // Open process given process id
+      void Open(DWORD ProcID);
+
+      // Gets the SeDebugPrivilege
+      void GetSeDebugPrivilege();
+
+      // Process handle
+      Windows::EnsureCloseHandle m_Handle;
+
+      // Process ID
+      DWORD m_ID;
+    };
+    
+    // Create process
+    Process CreateProcess(boost::filesystem::path const& Path, 
+      boost::filesystem::path const& Params, 
+      boost::filesystem::path const& WorkingDir);
+
+    // Process iterator
+    // Fixme: Implement in a more rhobust manner. Currently just 'skips' 
+    // processes if something goes wrong...
+    class ProcessIter : public boost::iterator_facade<ProcessIter, 
+      boost::optional<Process>, boost::incrementable_traversal_tag>, 
+      private boost::noncopyable
+    {
+    public:
+      // Constructor
+      ProcessIter() 
+        : m_Snap(), 
+        m_Current()
+      {
+        // Grab a new snapshot of the process
+        m_Snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
+        if (m_Snap == INVALID_HANDLE_VALUE)
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Process::Error() << 
+            ErrorFunction("ProcessIter::First") << 
+            ErrorString("Could not get process snapshot.") << 
+            ErrorCode(LastError));
+        }
+
+        // Get first module entry
+        PROCESSENTRY32 ProcEntry = { sizeof(ProcEntry) };
+        if (!Process32First(m_Snap, &ProcEntry))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Process::Error() << 
+            ErrorFunction("ProcessIter::First") << 
+            ErrorString("Error enumerating process list.") << 
+            ErrorCode(LastError));
+        }
+        
+        // Get WoW64 status of self
+        BOOL IsWoW64Me = FALSE;
+        if (!IsWow64Process(GetCurrentProcess(), &IsWoW64Me))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Process::Error() << 
+            ErrorFunction("ProcessIter::First") << 
+            ErrorString("Could not detect WoW64 status of current process.") << 
+            ErrorCode(LastError));
+        }
+        
+        // Get handle to target
+        // Using more access flags than is strictly necessar, but if I don't 
+        // it will simply fail further down the chain
+        Windows::EnsureCloseHandle TargetProc(OpenProcess(PROCESS_CREATE_THREAD | 
+          PROCESS_QUERY_INFORMATION | 
+          PROCESS_VM_OPERATION | 
+          PROCESS_VM_READ | 
+          PROCESS_VM_WRITE, 
+          FALSE, ProcEntry.th32ProcessID));
+        if (!TargetProc)
+        {
+          increment();
+          return;
+        }
+  
+        // Get WoW64 status of target process
+        BOOL IsWoW64 = FALSE;
+        if (!IsWow64Process(TargetProc, &IsWoW64))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Process::Error() << 
+            ErrorFunction("ProcessIter::First") << 
+            ErrorString("Could not detect WoW64 status of target process.") << 
+            ErrorCode(LastError));
+        }
+  
+        // Ensure WoW64 status of both self and target match
+        if (IsWoW64Me != IsWoW64)
+        {
+          increment();
+        }
+        else
+        {
+          m_Current = Process(ProcEntry.th32ProcessID);
+        }
+      }
+
+    private:
+      // Allow Boost.Iterator access to internals
+      friend class boost::iterator_core_access;
+
+      // For Boost.Iterator
+      void increment() 
+      {
+        PROCESSENTRY32 ProcEntry = { sizeof(ProcEntry) };
+        if (!Process32Next(m_Snap, &ProcEntry))
+        {
+          if (GetLastError() != ERROR_NO_MORE_FILES)
+          {
+            std::error_code const LastError = GetLastErrorCode();
+            BOOST_THROW_EXCEPTION(Process::Error() << 
+              ErrorFunction("ProcessIter::Next") << 
+              ErrorString("Error enumerating process list.") << 
+              ErrorCode(LastError));
+          }
+
+          m_Current = boost::optional<Process>();
+        }
+        else
+        {
+          // Get WoW64 status of self
+          BOOL IsWoW64Me = FALSE;
+          if (!IsWow64Process(GetCurrentProcess(), &IsWoW64Me))
+          {
+            std::error_code const LastError = GetLastErrorCode();
+            BOOST_THROW_EXCEPTION(Process::Error() << 
+              ErrorFunction("ProcessIter::Next") << 
+              ErrorString("Could not detect WoW64 status of current "
+                "process.") << 
+              ErrorCode(LastError));
+          }
+        
+          // Get handle to target
+          // Using more access flags than is strictly necessar, but if I don't 
+          // it will simply fail further down the chain
+          Windows::EnsureCloseHandle TargetProc(OpenProcess(PROCESS_CREATE_THREAD | 
+            PROCESS_QUERY_INFORMATION | 
+            PROCESS_VM_OPERATION | 
+            PROCESS_VM_READ | 
+            PROCESS_VM_WRITE, 
+            FALSE, ProcEntry.th32ProcessID));
+          if (!TargetProc)
+          {
+            increment();
+            return;
+          }
+    
+          // Get WoW64 status of target process
+          BOOL IsWoW64 = FALSE;
+          if (!IsWow64Process(TargetProc, &IsWoW64))
+          {
+            std::error_code const LastError = GetLastErrorCode();
+            BOOST_THROW_EXCEPTION(Process::Error() << 
+              ErrorFunction("ProcessIter::Next") << 
+              ErrorString("Could not detect WoW64 status of target "
+                "process.") << 
+              ErrorCode(LastError));
+          }
+  
+          // Ensure WoW64 status of both self and target match
+          if (IsWoW64Me != IsWoW64)
+          {
+            increment();
+          }
+          else
+          {
+            m_Current = Process(ProcEntry.th32ProcessID);
+          }
+        }
+      }
+
+      // For Boost.Iterator
+      boost::optional<Process>& dereference() const
+      {
+        return m_Current;
+      }
+
+      // Toolhelp32 snapshot handle
+      Windows::EnsureCloseSnap m_Snap;
+
+      // Current module
+      mutable boost::optional<Process> m_Current;
+    };
+  }
+}
Index: Include/Memory/Memory/Region.hpp
===================================================================
--- Include/Memory/Memory/Region.hpp	(revision 0)
+++ Include/Memory/Memory/Region.hpp	(revision 0)
@@ -0,0 +1,164 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <Windows.h>
+
+// C++ Standard Library
+#include <memory>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/optional.hpp>
+#include <boost/iterator/iterator_facade.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Memory region managing class
+    class Region
+    {
+    public:
+      // MemRegion exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      // Constructor
+      Region(MemoryMgr const& MyMemory, PVOID Address);
+
+      // Constructor
+      Region(MemoryMgr const& MyMemory, MEMORY_BASIC_INFORMATION const& MyMbi);
+
+      // Get base address
+      PVOID GetBase() const;
+      
+      // Get allocation base
+      PVOID GetAllocBase() const;
+      
+      // Get allocation protection
+      DWORD GetAllocProtect() const;
+      
+      // Get size
+      SIZE_T GetSize() const;
+      
+      // Get state
+      DWORD GetState() const;
+      
+      // Get protection
+      DWORD GetProtect() const;
+      
+      // Get type
+      DWORD GetType() const;
+
+    private:
+      // MemoryMgr instance
+      MemoryMgr m_Memory;
+
+      // Region information
+      MEMORY_BASIC_INFORMATION m_RegionInfo;
+    };
+
+    // Region iterator
+    class RegionListIter : public boost::iterator_facade<RegionListIter, 
+      boost::optional<Region>, boost::incrementable_traversal_tag>
+    {
+    public:
+      // Constructor
+      RegionListIter(MemoryMgr const& MyMemory) 
+        : m_Memory(MyMemory), 
+        m_BaseAddress(nullptr), 
+        m_RegionSize(0), 
+        m_Current()
+      {
+        MEMORY_BASIC_INFORMATION MyMbi = { 0 };
+        if (!VirtualQueryEx(m_Memory.GetProcessHandle(), m_BaseAddress, &MyMbi, 
+          sizeof(MyMbi)))
+        {
+          std::error_code const LastError = GetLastErrorCode();
+          BOOST_THROW_EXCEPTION(Region::Error() << 
+            ErrorFunction("RegionEnum::First") << 
+            ErrorString("Could not get first memory region.") << 
+            ErrorCode(LastError));
+        }
+
+        m_BaseAddress = MyMbi.BaseAddress;
+        m_RegionSize = MyMbi.RegionSize;
+
+        m_Current = Region(m_Memory, MyMbi);
+      }
+
+    private:
+      // Allow Boost.Iterator access to internals
+      friend class boost::iterator_core_access;
+
+      // For Boost.Iterator
+      void increment() 
+      {
+        // Advance to next region
+        m_BaseAddress = static_cast<PBYTE>(m_BaseAddress) + m_RegionSize;
+
+        // Get region info
+        MEMORY_BASIC_INFORMATION MyMbi = { 0 };
+        if (VirtualQueryEx(m_Memory.GetProcessHandle(), m_BaseAddress, &MyMbi, 
+          sizeof(MyMbi)))
+        {
+          m_BaseAddress = MyMbi.BaseAddress;
+          m_RegionSize = MyMbi.RegionSize;
+
+          m_Current = Region(m_Memory, MyMbi);
+        }
+        else
+        {
+          m_Current = boost::optional<Region>();
+        }
+      }
+
+      // For Boost.Iterator
+      boost::optional<Region>& dereference() const
+      {
+        return m_Current;
+      }
+
+      // Memory instance
+      MemoryMgr m_Memory;
+
+      // Current address
+      PVOID m_BaseAddress;
+
+      // Current region size
+      SIZE_T m_RegionSize;
+
+      // Current region
+      mutable boost::optional<Region> m_Current;
+    };
+  }
+}
Index: Include/Memory/Memory/Scanner.hpp
===================================================================
--- Include/Memory/Memory/Scanner.hpp	(revision 0)
+++ Include/Memory/Memory/Scanner.hpp	(revision 0)
@@ -0,0 +1,286 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <tchar.h>
+#include <Windows.h>
+
+// C++ Standard Library
+#include <map>
+#include <string>
+#include <vector>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/filesystem.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Hades
+#include "Region.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Memory searching class
+    class Scanner
+    {
+    public:
+      // Scanner exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      // Constructor
+      Scanner(MemoryMgr const& MyMemory, PVOID Start, PVOID End);
+
+      // Search memory (POD types)
+      template <typename T>
+      PVOID Find(T const& Data, typename std::enable_if<std::is_pod<T>::value, 
+        T>::type* Dummy = 0) const;
+
+      // Search memory (string types)
+      template <typename T>
+      PVOID Find(T const& Data, typename std::enable_if<std::is_same<T, std::
+        basic_string<typename T::value_type>>::value, T>::type* Dummy = 0) 
+        const;
+
+      // Search memory (vector types)
+      template <typename T>
+      PVOID Find(T const& Data, typename std::enable_if<std::is_same<T, 
+        std::vector<typename T::value_type>>::value, T>::type* Dummy1 = 0) 
+        const;
+
+      // Search memory (POD types)
+      template <typename T>
+      std::vector<PVOID> FindAll(T const& data, typename std::enable_if<std::
+        is_pod<T>::value, T>::type* Dummy = 0) const;
+
+      // Search memory (string types)
+      template <typename T>
+      std::vector<PVOID> FindAll(T const& Data, typename std::enable_if<std::
+        is_same<T, std::basic_string<typename T::value_type>>::value, 
+        T>::type* Dummy = 0) const;
+
+      // Search memory (vector types)
+      template <typename T>
+      std::vector<PVOID> FindAll(T const& Data, typename std::enable_if<std::
+        is_same<T, std::vector<typename T::value_type>>::value, 
+        T>::type* Dummy1 = 0) const;
+
+    private:
+      // Memory manager instance
+      MemoryMgr m_Memory;
+
+      // Start and end addresses of search region
+      PBYTE m_Start;
+      PBYTE m_End;
+    };
+
+    // Search memory (POD types)
+    template <typename T>
+    PVOID Scanner::Find(T const& Data, typename std::enable_if<std::is_pod<
+      T>::value, T>:: type* /*Dummy*/) const
+    {
+      // Put data in container
+      std::vector<T> Buffer;
+      Buffer.push_back(Data);
+      // Use vector specialization of Find
+      return Find(Buffer);
+    }
+
+    // Search memory (string types)
+    template <typename T>
+    PVOID Scanner::Find(T const& Data, typename std::enable_if<std::is_same<
+      T, std::basic_string<typename T::value_type>>::value, 
+      T>::type* /*Dummy*/) const
+    {
+      // Convert string to character buffer
+      std::vector<typename T::value_type> const MyBuffer(Data.cbegin(), 
+        Data.cend());
+      // Use vector specialization of Find
+      return Find(MyBuffer);
+    }
+
+    // Search memory (vector types)
+    template <typename T>
+    PVOID Scanner::Find(T const& Data, typename std::enable_if<std::is_same<
+      T, std::vector<typename T::value_type>>::value, 
+      T>::type* /*Dummy1*/) const
+    {
+      static_assert(std::is_pod<typename T::value_type>::value, 
+        "Scanner::Find: Value type of vector must be POD.");
+
+      if (Data.empty())
+      {
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("Scanner::Find") << 
+          ErrorString("Data container is empty."));
+      }
+
+      LPCBYTE pDataRaw = reinterpret_cast<LPCBYTE>(&Data[0]);
+      std::size_t const DataRawSize = Data.size() * sizeof(
+        typename T::value_type);
+
+      std::vector<BYTE> DataRaw(pDataRaw, pDataRaw + DataRawSize);
+
+      for (RegionListIter i(m_Memory); *i; ++i)
+      {
+        Hades::Memory::Region const& MyRegion = **i;
+
+        if (static_cast<PBYTE>(MyRegion.GetBase()) + MyRegion.GetSize() < 
+          m_Start)
+        {
+          continue;
+        }
+
+        if (MyRegion.GetBase() > m_End)
+        {
+          break;
+        }
+
+        std::vector<BYTE> Buffer;
+
+        try
+        {
+          Buffer = m_Memory.Read<std::vector<BYTE>>(MyRegion.GetBase(), 
+            MyRegion.GetSize());
+        }
+        catch (MemoryMgr::Error const& /*e*/)
+        {
+          continue;
+        }
+
+        auto Iter = std::search(Buffer.cbegin(), Buffer.cend(), 
+          DataRaw.cbegin(), DataRaw.cend());
+        if (Iter != Buffer.cend())
+        {
+          PVOID AddressReal = static_cast<PBYTE>(MyRegion.GetBase()) + 
+            std::distance(Buffer.cbegin(), Iter);
+          if (AddressReal >= m_Start && AddressReal <= m_End)
+          {
+            return AddressReal;
+          }
+        }
+      }
+
+      return nullptr;
+    }
+
+    // Search memory (POD types)
+    template <typename T>
+    std::vector<PVOID> Scanner::FindAll(T const& Data, typename std::
+      enable_if<std::is_pod<T>::value, T>::type* /*Dummy*/) const
+    {
+      // Put data in container
+      std::vector<T> Buffer;
+      Buffer.push_back(Data);
+      // Use vector specialization of FindAll
+      return FindAll(Buffer);
+    }
+
+    template <typename T>
+    std::vector<PVOID> Scanner::FindAll(T const& Data, typename std::
+      enable_if<std::is_same<T, std::basic_string<typename T::value_type>>::
+      value, T>::type* /*Dummy*/) const
+    {
+      // Convert string to character buffer
+      std::vector<typename T::value_type> const MyBuffer(Data.cbegin(), 
+        Data.cend());
+      // Use vector specialization of find all
+      return FindAll(MyBuffer);
+    }
+
+    // Search memory (vector types)
+    // Fixme: This function is extremely inefficient and full of potential 
+    // bugs. Perform a thorough review and rewrite.
+    // Fixme: Refactor Find and FindAll to factor out duplicated code.
+    template <typename T>
+    std::vector<PVOID> Scanner::FindAll(T const& Data, typename std::
+      enable_if<std::is_same<T, std::vector<typename T::value_type>>::
+      value, T>::type* /*Dummy1*/) const
+    {
+      static_assert(std::is_pod<typename T::value_type>::value, 
+        "Scanner::Find: Value type of vector must be POD.");
+
+      if (Data.empty())
+      {
+        BOOST_THROW_EXCEPTION(Error() << 
+          ErrorFunction("Scanner::Find") << 
+          ErrorString("Data container is empty."));
+      }
+
+      LPCBYTE pDataRaw = reinterpret_cast<LPCBYTE>(&Data[0]);
+      std::size_t const DataRawSize = Data.size() * sizeof(
+        typename T::value_type);
+
+      std::vector<BYTE> DataRaw(pDataRaw, pDataRaw + DataRawSize);
+
+      std::vector<PVOID> Matches;
+
+      for (RegionListIter i(m_Memory); *i; ++i)
+      {
+        Hades::Memory::Region const& MyRegion = **i;
+
+        if (static_cast<PBYTE>(MyRegion.GetBase()) + MyRegion.GetSize() < 
+          m_Start)
+        {
+          continue;
+        }
+
+        if (MyRegion.GetBase() > m_End)
+        {
+          break;
+        }
+
+        std::vector<BYTE> Buffer;
+
+        try
+        {
+          Buffer = m_Memory.Read<std::vector<BYTE>>(MyRegion.GetBase(), 
+            MyRegion.GetSize());
+        }
+        catch (MemoryMgr::Error const& /*e*/)
+        {
+          continue;
+        }
+
+        auto Iter = std::search(Buffer.cbegin(), Buffer.cend(), 
+          DataRaw.cbegin(), DataRaw.cend());
+        if (Iter != Buffer.cend())
+        {
+          PVOID AddressReal = static_cast<PBYTE>(MyRegion.GetBase()) + 
+            std::distance(Buffer.cbegin(), Iter);
+          if (AddressReal >= m_Start && AddressReal <= m_End)
+          {
+            Matches.push_back(AddressReal);
+          }
+        }
+      }
+
+      return Matches;
+    }
+  }
+}
Index: Include/Memory/Memory/Section.hpp
===================================================================
--- Include/Memory/Memory/Section.hpp	(revision 0)
+++ Include/Memory/Memory/Section.hpp	(revision 0)
@@ -0,0 +1,96 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows
+#include <Windows.h>
+
+// C++ Standard Library
+#include <string>
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "PeFile.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // PE file section
+    class Section
+    {
+    public:
+      // Section error class
+      class Error : public virtual HadesMemError
+      { };
+
+      // Constructor
+      Section(PeFile const& MyPeFile, WORD Number);
+
+      // Get name
+      std::string GetName() const;
+
+      // Get virtual address
+      DWORD GetVirtualAddress() const;
+
+      // Get virtual size
+      DWORD GetVirtualSize() const;
+
+      // Get size of raw data
+      DWORD GetSizeOfRawData() const;
+
+      // Get pointer to raw data
+      DWORD GetPointerToRawData() const;
+
+      // Get pointer to relocations
+      DWORD GetPointerToRelocations() const;
+
+      // Get pointer to line numbers
+      DWORD GetPointerToLinenumbers() const;
+
+      // Get number of relocations
+      WORD GetNumberOfRelocations() const;
+
+      // Get number of line numbers
+      WORD GetNumberOfLinenumbers() const;
+
+      // Get characteristics
+      DWORD GetCharacteristics() const;
+
+      // Get section header base
+      PBYTE GetBase() const;
+
+      // Get raw section header
+      IMAGE_SECTION_HEADER GetSectionHeaderRaw() const;
+
+    private:
+      // PE file
+      PeFile m_PeFile;
+
+      // Memory instance
+      MemoryMgr m_Memory;
+
+      // Section number
+      WORD m_SectionNum;
+    };
+  }
+}
Index: Include/Memory/Memory/SectionEnum.hpp
===================================================================
--- Include/Memory/Memory/SectionEnum.hpp	(revision 0)
+++ Include/Memory/Memory/SectionEnum.hpp	(revision 0)
@@ -0,0 +1,102 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// C++ Standard Library
+#include <memory>
+
+// Boost
+#ifdef _MSC_VER
+#pragma warning(push, 1)
+#endif // #ifdef _MSC_VER
+#include <boost/optional.hpp>
+#include <boost/iterator/iterator_facade.hpp>
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif // #ifdef _MSC_VER
+
+// Windows API
+#include <Windows.h>
+
+// Hades
+#include "PeFile.hpp"
+#include "Section.hpp"
+#include "NtHeaders.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Section iterator
+    class SectionIter : public boost::iterator_facade<SectionIter, 
+      boost::optional<Section>, boost::incrementable_traversal_tag>
+    {
+    public:
+      // Constructor
+      explicit SectionIter(PeFile const& MyPeFile) 
+        : m_PeFile(MyPeFile), 
+        m_CurrentNum(0), 
+        m_Current()
+      {
+        NtHeaders const MyNtHeaders(m_PeFile);
+        WORD NumberOfSections = MyNtHeaders.GetNumberOfSections();
+        if (NumberOfSections)
+        {
+          m_Current = Section(m_PeFile, m_CurrentNum);
+        }
+      }
+
+    private:
+      // Allow Boost.Iterator access to internals
+      friend class boost::iterator_core_access;
+
+      // For Boost.Iterator
+      void increment() 
+      {
+        NtHeaders const MyNtHeaders(m_PeFile);
+        WORD const NumberOfSections = MyNtHeaders.GetNumberOfSections();
+
+        if (++m_CurrentNum < NumberOfSections)
+        {
+          m_Current = Section(m_PeFile, m_CurrentNum);
+        }
+        else
+        {
+          m_Current = boost::optional<Section>();
+        }
+      }
+
+      // For Boost.Iterator
+      boost::optional<Section>& dereference() const
+      {
+        return m_Current;
+      }
+
+      // Memory instance
+      PeFile m_PeFile;
+
+      // Current section number
+      WORD m_CurrentNum;
+
+      // Current section
+      mutable boost::optional<Section> m_Current;
+    };
+  }
+}
Index: Include/Memory/Memory/Symbol.hpp
===================================================================
--- Include/Memory/Memory/Symbol.hpp	(revision 0)
+++ Include/Memory/Memory/Symbol.hpp	(revision 0)
@@ -0,0 +1,75 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows API
+#include <Windows.h>
+#ifdef UNICODE
+#define DBGHELP_TRANSLATE_TCHAR
+#endif
+#include <DbgHelp.h>
+
+// C++ Standard Library
+#include <string>
+
+// Boost
+#include <boost/filesystem.hpp>
+#include <boost/noncopyable.hpp>
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "MemoryMgr.hpp"
+
+// Note: Symbol APIs provided by DbgHelp are NOT thread-safe. 
+// Todo: Implement optional synchronization.
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // Symbol handler
+    // Note: Thanks to _Mike on MMOwned for the idea and initial PoC base
+    class Symbols : private boost::noncopyable
+    {
+    public:
+      // Symbols exception type
+      class Error : public virtual HadesMemError 
+      { };
+
+      // Constructor
+      explicit Symbols(MemoryMgr const& MyMemory, 
+        boost::filesystem::path const& SearchPath = boost::filesystem::path());
+        
+      // Destructor
+      ~Symbols();
+      
+      // Load symbols for module
+      void LoadForModule(std::basic_string<TCHAR> const& ModuleName);
+      
+      // Get address for symbol
+      PVOID GetAddress(std::basic_string<TCHAR> const& Name);
+        
+    private:
+      // Memory instance
+      MemoryMgr m_Memory;
+    };
+  }
+}
Index: Include/Memory/Memory/TlsDir.hpp
===================================================================
--- Include/Memory/Memory/TlsDir.hpp	(revision 0)
+++ Include/Memory/Memory/TlsDir.hpp	(revision 0)
@@ -0,0 +1,90 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// Windows
+#include <Windows.h>
+
+// C++ Standard Library
+#include <vector>
+
+// Hades
+#include "Fwd.hpp"
+#include "Error.hpp"
+#include "PeFile.hpp"
+#include "MemoryMgr.hpp"
+
+namespace Hades
+{
+  namespace Memory
+  {
+    // PE file TLS directory
+    class TlsDir
+    {
+    public:
+      // TlsDir error class
+      class Error : public virtual HadesMemError
+      { };
+
+      // Constructor
+      explicit TlsDir(PeFile const& MyPeFile);
+
+      // Whether TLS directory is valid
+      bool IsValid() const;
+
+      // Ensure TLS directory is valid
+      void EnsureValid() const;
+
+      // Get start address of raw data
+      DWORD_PTR GetStartAddressOfRawData() const;
+
+      // Get end address of raw data
+      DWORD_PTR GetEndAddressOfRawData() const;
+
+      // Get address of index
+      DWORD_PTR GetAddressOfIndex() const;
+
+      // Get address of callbacks
+      DWORD_PTR GetAddressOfCallBacks() const;
+
+      // Get size of zero fill
+      DWORD GetSizeOfZeroFill() const;
+
+      // Get characteristics
+      DWORD GetCharacteristics() const;
+
+      // Get list of TLS callbacks
+      std::vector<PIMAGE_TLS_CALLBACK> GetCallbacks() const;
+
+      // Get base of TLS dir
+      PBYTE GetBase() const;
+
+      // Get raw TLS dir
+      IMAGE_TLS_DIRECTORY GetTlsDirRaw() const;
+
+    private:
+      // PE file
+      PeFile m_PeFile;
+
+      // Memory instance
+      MemoryMgr m_Memory;
+    };
+  }
+}
Index: Include/Memory/Memory/Types.hpp
===================================================================
--- Include/Memory/Memory/Types.hpp	(revision 0)
+++ Include/Memory/Memory/Types.hpp	(revision 0)
@@ -0,0 +1,62 @@
+/*
+This file is part of HadesMem.
+Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
+<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
+
+HadesMem is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+HadesMem is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#pragma once
+
+// C++ Standard Library
+#include <string>
+#include <cstdint>
+
+namespace Hades
+{
+  namespace Memory
+  {
+    namespace Types
+    {
+      // Declare fixed-size types
+      typedef std::int8_t     Int8;
+      typedef std::uint8_t    UInt8;
+      typedef std::int16_t    Int16;
+      typedef std::uint16_t   UInt16;
+      typedef std::int32_t    Int32;
+      typedef std::uint32_t   UInt32;
+      typedef std::int64_t    Int64;
+      typedef std::uint64_t   UInt64;
+      typedef float           Float;
+      typedef double          Double;
+      typedef char            CharA;
+      typedef wchar_t         CharW;
+      typedef std::string     StringA;
+      typedef std::wstring    StringW;
+      typedef void*           Pointer;
+
+      // Ensure data type are correct
+      static_assert(sizeof(Int8) == 1, "Size of Int8 is wrong.");
+      static_assert(sizeof(UInt8) == 1, "Size of UInt8 is wrong.");
+      static_assert(sizeof(Int16) == 2, "Size of Int16 is wrong.");
+      static_assert(sizeof(UInt16) == 2, "Size of UInt16 is wrong.");
+      static_assert(sizeof(Int32) == 4, "Size of Int32 is wrong.");
+      static_assert(sizeof(UInt32) == 4, "Size of UInt32 is wrong.");
+      static_assert(sizeof(Int64) == 8, "Size of Int64 is wrong.");
+      static_assert(sizeof(UInt64) == 8, "Size of UInt64 is wrong.");
+      static_assert(sizeof(Float) == 4, "Size of Float is wrong.");
+      static_assert(sizeof(Double) == 8, "Size of Double is wrong.");
+    }
+  }
+}
Index: Jamroot
===================================================================
--- Jamroot	(revision 830)
+++ Jamroot	(working copy)
@@ -1,13 +1,9 @@
-use-project /HadesMem
-  : Include/HadesMem
-  ;
- 
  use-project /Dependencies 
   : Src/Dependencies
   ;
   
 use-project /Common 
-  : Src/Common 
+  : Include/Common 
   ; 
   
 use-project /Memory 
Index: Src/Common/Common/EnsureCleanup.hpp
===================================================================
--- Src/Common/Common/EnsureCleanup.hpp	(revision 830)
+++ Src/Common/Common/EnsureCleanup.hpp	(working copy)
@@ -1,673 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher).
-<http://www.cypherjb.com/> <cypher.jb@gmail.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <Windows.h>
-#include <Objbase.h>
-
-// C++ Standard Library
-#include <string>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/noncopyable.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Notice: Modified version of EnsureCleanup library provided in the 'Windows
-// via C/C++' sample code. Originally copyright Jeffrey Richter and
-// Christophe Nasarre.
-
-namespace Hades
-{
-  namespace Windows
-  {
-    // Windows RAII helper class template
-    // HandleT = Handle type (e.g. 'HANDLE')
-    // FuncT = Function prototype (e.g. 'BOOL (WINAPI*) (HANDLE)' )
-    // CleanupFn = Cleanup function (e.g. 'CloseHandle')
-    // Invalid = Invalid handle value (e.g. '0')
-    template <typename HandleT, typename FuncT, FuncT CleanupFn, 
-      DWORD_PTR Invalid>
-    class EnsureCleanup : private boost::noncopyable
-    {
-    public:
-      // Ensure size of handle type is valid. Under Windows all handles are 
-      // the size of a pointer.
-      static_assert(sizeof(HandleT) == sizeof(DWORD_PTR), 
-        "Size of handle type is invalid.");
-
-      // Constructor
-      EnsureCleanup(HandleT Handle = reinterpret_cast<HandleT>(Invalid))
-        : m_Handle(Handle)
-      { }
-
-      // Move constructor
-      EnsureCleanup(EnsureCleanup&& MyEnsureCleanup)
-        : m_Handle(Invalid)
-      {
-        *this = std::move(MyEnsureCleanup);
-      }
-
-      // Move assignment operator
-      EnsureCleanup& operator= (EnsureCleanup&& MyEnsureCleanup)
-      {
-        Cleanup();
-
-        this->m_Handle = MyEnsureCleanup.m_Handle;
-        MyEnsureCleanup.m_Handle = Invalid;
-
-        return *this;
-      }
-
-      // Assignment operator (for HandleT values)
-      EnsureCleanup& operator= (HandleT Handle)
-      {
-        Cleanup();
-
-        m_Handle = Handle;
-
-        return *this;
-      }
-
-      // The destructor performs the cleanup.
-      ~EnsureCleanup()
-      {
-        Cleanup();
-      }
-
-      // Whether object is valid
-      BOOL IsValid() const
-      {
-        return m_Handle != reinterpret_cast<HandleT>(Invalid);
-      }
-
-      // Whether object is invalid
-      BOOL IsInvalid() const
-      {
-        return !IsValid();
-      }
-
-      // Implicit conversion operator for HandleT
-      operator HandleT() const
-      {
-        return m_Handle;
-      }
-
-      // Cleanup the object if the value represents a valid object
-      void Cleanup()
-      {
-        if (IsValid())
-        {
-          // Close the object.
-          CleanupFn(m_Handle);
-
-          // We no longer represent a valid object.
-          m_Handle = reinterpret_cast<HandleT>(Invalid);
-        }
-      }
-
-    private:
-      // Handle being managed
-      HandleT m_Handle;
-    };
-    
-    // GCC workaround
-    namespace
-    {
-      DWORD_PTR const INVALID_HANDLE_VALUE_CUSTOM = 
-        static_cast<DWORD_PTR>(-1);
-    }
-
-    // Instances of the template C++ class for common data types.
-    typedef EnsureCleanup<HANDLE, BOOL(WINAPI*)(HANDLE), FindClose, 0> 
-      EnsureFindClose;
-    typedef EnsureCleanup<HANDLE, BOOL(WINAPI*)(HANDLE), CloseHandle, 0> 
-      EnsureCloseHandle;
-    typedef EnsureCleanup<HANDLE, BOOL(WINAPI*)(HANDLE), CloseHandle, 
-      INVALID_HANDLE_VALUE_CUSTOM> EnsureCloseSnap;
-    typedef EnsureCleanup<HLOCAL, HLOCAL(WINAPI*)(HLOCAL), LocalFree, 0> 
-      EnsureLocalFree;
-    typedef EnsureCleanup<HGLOBAL, HGLOBAL(WINAPI*)(HGLOBAL), GlobalFree, 0> 
-      EnsureGlobalFree;
-    typedef EnsureCleanup<HGLOBAL, BOOL(WINAPI*)(HGLOBAL), GlobalUnlock, 0> 
-      EnsureGlobalUnlock;
-    typedef EnsureCleanup<HKEY, LONG(WINAPI*)(HKEY), RegCloseKey, 0> 
-      EnsureRegCloseKey;
-    typedef EnsureCleanup<SC_HANDLE, BOOL(WINAPI*)(SC_HANDLE), 
-      CloseServiceHandle, 0> EnsureCloseServiceHandle;
-    typedef EnsureCleanup<HWINSTA, BOOL(WINAPI*)(HWINSTA), CloseWindowStation, 
-      0> EnsureCloseWindowStation;
-    typedef EnsureCleanup<HDESK, BOOL(WINAPI*)(HDESK), CloseDesktop, 0> 
-      EnsureCloseDesktop;
-    typedef EnsureCleanup<LPCVOID, BOOL(WINAPI*)(LPCVOID), UnmapViewOfFile, 0> 
-      EnsureUnmapViewOfFile;
-    typedef EnsureCleanup<HMODULE, BOOL(WINAPI*)(HMODULE), FreeLibrary, 0> 
-      EnsureFreeLibrary;
-    typedef EnsureCleanup<PVOID, ULONG(WINAPI*)(PVOID), 
-      RemoveVectoredExceptionHandler, 0> EnsureRemoveVEH;
-    typedef EnsureCleanup<HANDLE, DWORD(WINAPI*)(HANDLE), ResumeThread, 0> 
-      EnsureResumeThread;
-    typedef EnsureCleanup<HANDLE, BOOL(WINAPI*)(HANDLE), CloseHandle, 
-      INVALID_HANDLE_VALUE_CUSTOM> EnsureCloseFile;
-    typedef EnsureCleanup<HHOOK, BOOL(WINAPI*)(HHOOK), UnhookWindowsHookEx, 0> 
-      EnsureUnhookWindowsHookEx;
-    typedef EnsureCleanup<HWND, BOOL(WINAPI*)(HWND), DestroyWindow, 0> 
-      EnsureDestroyWindow;
-    typedef EnsureCleanup<PSID, PVOID(WINAPI*)(PSID), FreeSid, 0> 
-      EnsureFreeSid;
-    typedef EnsureCleanup<HGLOBAL, BOOL(WINAPI*)(HGLOBAL), FreeResource, 0> 
-      EnsureFreeResource;
-    typedef EnsureCleanup<HDC, BOOL(WINAPI*)(HDC), DeleteDC, 0> 
-      EnsureDeleteDc;
-    typedef EnsureCleanup<HBITMAP, BOOL(WINAPI*)(HGDIOBJ), DeleteObject, 0> 
-      EnsureDeleteObject;
-    typedef EnsureCleanup<HICON, BOOL(WINAPI*)(HICON), DestroyIcon, 0> 
-      EnsureDestroyIcon;
-    typedef EnsureCleanup<HMENU, BOOL(WINAPI*)(HMENU), DestroyMenu, 0> 
-      EnsureDestroyMenu;
-
-    // Special class for ensuring COM is uninitialized
-    class EnsureCoUninitialize : private boost::noncopyable
-    {
-    public:
-      ~EnsureCoUninitialize()
-      {
-        CoUninitialize();
-      }
-    };
-
-    // Special class for releasing a reserved region.
-    class EnsureReleaseRegion : private boost::noncopyable
-    {
-    public:
-      // Constructor
-      EnsureReleaseRegion(PVOID pv = nullptr)
-        : m_pv(pv)
-      { }
-
-      // Destructor
-      ~EnsureReleaseRegion()
-      {
-        Cleanup();
-      }
-
-      // Move constructor
-      EnsureReleaseRegion(EnsureReleaseRegion&& MyEnsureCleanup)
-        : m_pv(nullptr)
-      {
-        *this = std::move(MyEnsureCleanup);
-      }
-
-      // Move assignment operator
-      EnsureReleaseRegion& operator= (EnsureReleaseRegion&& MyEnsureCleanup)
-      {
-        Cleanup();
-
-        m_pv = MyEnsureCleanup.m_pv;
-
-        MyEnsureCleanup.m_pv = 0;
-
-        return *this;
-      }
-
-      // Assignment operator (for PVOID values) 
-      EnsureReleaseRegion& operator= (PVOID pv)
-      {
-        Cleanup();
-
-        m_pv = pv;
-
-        return *this;
-      }
-
-      // Implicit conversion operator for PVOID
-      operator PVOID() const
-      {
-        return m_pv;
-      }
-
-      // Cleanup the object if the value represents a valid object
-      void Cleanup()
-      {
-        if (m_pv != nullptr)
-        {
-          VirtualFree(m_pv, 0, MEM_RELEASE);
-
-          m_pv = nullptr;
-        }
-      }
-
-    private:
-      // Handle being managed
-      PVOID m_pv;
-    };
-
-    // Special class for releasing a reserved region.
-    class EnsureEndUpdateResource : private boost::noncopyable
-    {
-    public:
-      // Constructor
-      EnsureEndUpdateResource(HANDLE File = nullptr) 
-        : m_File(File)
-      { }
-
-      // Move constructor
-      EnsureEndUpdateResource(EnsureEndUpdateResource&& MyEnsureCleanup)
-        : m_File(nullptr)
-      {
-        *this = std::move(MyEnsureCleanup);
-      }
-
-      // Move assignment operator
-      EnsureEndUpdateResource& operator= (EnsureEndUpdateResource&&
-        MyEnsureCleanup)
-      {
-        Cleanup();
-
-        m_File = MyEnsureCleanup.m_File;
-
-        MyEnsureCleanup.m_File = nullptr;
-
-        return *this;
-      }
-
-      // Destructor
-      ~EnsureEndUpdateResource()
-      {
-        Cleanup();
-      }
-
-      // Assignment operator (for HANDLE values) 
-      EnsureEndUpdateResource& operator= (HANDLE File)
-      {
-        Cleanup();
-
-        m_File = File;
-
-        return *this;
-      }
-
-      // Implicit conversion operator for HANDLE
-      operator HANDLE() const
-      {
-        return m_File;
-      }
-
-      // Cleanup the object if the value represents a valid object
-      void Cleanup()
-      {
-        if (m_File != nullptr)
-        {
-          EndUpdateResource(m_File, FALSE);
-
-          m_File = nullptr;
-        }
-      }
-
-    private:
-      // Handle being managed
-      HANDLE m_File;
-    };
-
-    // Special class for freeing a block from a heap
-    class EnsureHeapFree : private boost::noncopyable
-    {
-    public:
-      // Constructor
-      EnsureHeapFree(PVOID pv = nullptr, HANDLE hHeap = GetProcessHeap())
-        : m_pv(pv), m_hHeap(hHeap)
-      { }
-
-      // Move constructor
-      EnsureHeapFree(EnsureHeapFree&& MyEnsureCleanup)
-        : m_pv(nullptr),
-        m_hHeap(nullptr)
-      {
-        *this = std::move(MyEnsureCleanup);
-      }
-
-      // Move assignment operator
-      EnsureHeapFree& operator= (EnsureHeapFree&& MyEnsureCleanup)
-      {
-        Cleanup();
-
-        m_pv = MyEnsureCleanup.m_pv;
-        m_hHeap = MyEnsureCleanup.m_hHeap;
-
-        MyEnsureCleanup.m_pv = nullptr;
-        MyEnsureCleanup.m_hHeap = nullptr;
-
-        return *this;
-      }
-
-      // Destructor
-      ~EnsureHeapFree()
-      {
-        Cleanup();
-      }
-
-      // Assignment operator (for PVOID values)
-      EnsureHeapFree& operator= (PVOID pv)
-      {
-        Cleanup();
-
-        m_pv = pv;
-
-        return *this;
-      }
-
-      // Implicit conversion operator for PVOID
-      operator PVOID() const
-      {
-        return m_pv;
-      }
-
-      // Cleanup the object if the value represents a valid object
-      void Cleanup()
-      {
-        if (m_pv != nullptr)
-        {
-          HeapFree(m_hHeap, 0, m_pv);
-
-          m_pv = nullptr;
-        }
-      }
-
-    private:
-      // Handles being managed
-      PVOID m_pv;
-      HANDLE m_hHeap;
-    };
-
-    // Special class for releasing a remote reserved region
-    class EnsureReleaseRegionEx : private boost::noncopyable
-    {
-    public:
-      // Constructor
-      EnsureReleaseRegionEx(PVOID pv = nullptr, HANDLE proc = nullptr)
-        : m_pv(pv), 
-        m_proc(proc)
-      { }
-
-      // Move constructor
-      EnsureReleaseRegionEx(EnsureReleaseRegionEx&& MyEnsureCleanup)
-        : m_pv(nullptr),
-        m_proc(nullptr)
-      {
-        *this = std::move(MyEnsureCleanup);
-      }
-
-      // Move assignment operator
-      EnsureReleaseRegionEx& operator= (EnsureReleaseRegionEx&&
-        MyEnsureCleanup)
-      {
-        Cleanup();
-
-        m_pv = MyEnsureCleanup.m_pv;
-        m_proc = MyEnsureCleanup.m_proc;
-
-        MyEnsureCleanup.m_pv = nullptr;
-        MyEnsureCleanup.m_proc = nullptr;
-
-        return *this;
-      }
-
-      // Destructor
-      ~EnsureReleaseRegionEx()
-      {
-        Cleanup();
-      }
-
-      // Assignment operator (for PVOID values)
-      EnsureReleaseRegionEx& operator= (PVOID pv)
-      {
-        Cleanup();
-
-        m_pv = pv;
-
-        return *this;
-      }
-
-      // Implicit conversion operator for PVOID
-      operator PVOID() const
-      {
-        return m_pv;
-      }
-
-      // Cleanup the object if the value represents a valid object
-      void Cleanup()
-      {
-        if (m_pv != nullptr && m_proc != nullptr)
-        {
-          VirtualFreeEx(m_proc, m_pv, 0, MEM_RELEASE);
-
-          m_pv = nullptr;
-        }
-      }
-
-    private:
-      // Handles being managed
-      PVOID m_pv;
-      HANDLE m_proc;
-    };
-
-    // Special class for closing the clipboard
-    class EnsureCloseClipboard : private boost::noncopyable
-    {
-    public:
-      // Constructor
-      EnsureCloseClipboard(BOOL Success) 
-        : m_Success(Success)
-      { }
-      
-      // Move constructor
-      EnsureCloseClipboard(EnsureCloseClipboard&& MyEnsureCleanup)
-        : m_Success(FALSE)
-      {
-        *this = std::move(MyEnsureCleanup);
-      }
-
-      // Move assignment operator
-      EnsureCloseClipboard& operator= (EnsureCloseClipboard&& MyEnsureCleanup)
-      {
-        Cleanup();
-
-        m_Success = MyEnsureCleanup.m_Success;
-
-        MyEnsureCleanup.m_Success = FALSE;
-
-        return *this;
-      }
-
-      // Destructor
-      ~EnsureCloseClipboard()
-      {
-        Cleanup();
-      }
-
-      // Assignment operator (for BOOL values)
-      EnsureCloseClipboard& operator= (BOOL Success)
-      {
-        Cleanup();
-
-        m_Success = Success;
-
-        return *this;
-      }
-
-      // Implicit conversion operator for BOOL
-      operator BOOL() const
-      {
-        return m_Success;
-      }
-
-      // Cleanup the object if the value represents a valid object
-      void Cleanup()
-      {
-        if (m_Success)
-        {
-          CloseClipboard();
-
-          m_Success = FALSE;
-        }
-      }
-
-    private:
-      // 'Handle' being managed
-      BOOL m_Success;
-    };
-
-    // Special class for releasing a window class
-    class EnsureUnregisterClass : private boost::noncopyable
-    {
-    public:
-      // Constructor
-      EnsureUnregisterClass(std::basic_string<TCHAR> const& ClassName, 
-        HINSTANCE Instance)
-        : m_ClassName(ClassName),
-        m_Instance(Instance)
-      { }
-
-      // Move constructor
-      EnsureUnregisterClass(EnsureUnregisterClass&& MyEnsureCleanup)
-        : m_ClassName(),
-        m_Instance()
-      {
-        *this = std::move(MyEnsureCleanup);
-      }
-
-      // Move assignment operator
-      EnsureUnregisterClass& operator= (EnsureUnregisterClass&&
-        MyEnsureCleanup)
-      {
-        Cleanup();
-
-        m_ClassName = std::move(MyEnsureCleanup.m_ClassName);
-        m_Instance = MyEnsureCleanup.m_Instance;
-
-        MyEnsureCleanup.m_ClassName = std::basic_string<TCHAR>();
-        MyEnsureCleanup.m_Instance = nullptr;
-
-        return *this;
-      }
-
-      // Destructor
-      ~EnsureUnregisterClass()
-      {
-        Cleanup();
-      }
-
-      // Cleanup the object if the value represents a valid object
-      void Cleanup()
-      {
-        if (!m_ClassName.empty() && m_Instance)
-        {
-          UnregisterClass(m_ClassName.c_str(), m_Instance);
-
-          m_ClassName.clear();
-          m_Instance = 0;
-        }
-      }
-
-    private:
-      // 'Handles' being managed
-      std::basic_string<TCHAR> m_ClassName;
-      HINSTANCE m_Instance;
-    };
-
-
-    // Special class for releasing a DC
-    class EnsureReleaseDc
-    {
-    public:
-      // Constructor
-      EnsureReleaseDc(HWND Wnd = nullptr, HDC Dc = nullptr)
-        : m_Wnd(Wnd),
-        m_Dc(Dc)
-      { }
-
-      // Move constructor
-      EnsureReleaseDc(EnsureReleaseDc&& MyEnsureCleanup)
-        : m_Wnd(nullptr),
-        m_Dc(nullptr)
-      {
-        *this = std::move(MyEnsureCleanup);
-      }
-
-      // Move assignment operator
-      EnsureReleaseDc& operator= (EnsureReleaseDc&& MyEnsureCleanup)
-      {
-        Cleanup();
-
-        m_Wnd = MyEnsureCleanup.m_Wnd;
-        m_Dc = MyEnsureCleanup.m_Dc;
-
-        MyEnsureCleanup.m_Wnd = nullptr;
-        MyEnsureCleanup.m_Dc = nullptr;
-
-        return *this;
-      }
-
-      // Destructor
-      ~EnsureReleaseDc()
-      {
-        Cleanup();
-      }
-
-      // Assignment operator (for HDC values)
-      EnsureReleaseDc& operator= (HDC Dc)
-      {
-        Cleanup();
-
-        m_Dc = Dc;
-
-        return *this;
-      }
-
-      // Implicit conversion operator for BOOL
-      operator HDC() const
-      {
-        return m_Dc;
-      }
-
-      // Cleanup the object if the value represents a valid object
-      void Cleanup()
-      {
-        if (m_Wnd != nullptr && m_Dc != nullptr)
-        {
-          ReleaseDC(m_Wnd, m_Dc);
-
-          m_Wnd = nullptr;
-          m_Dc = nullptr;
-        }
-      }
-
-    private:
-      // Handles being managed
-      HWND m_Wnd;
-      HDC m_Dc;
-    };
-  }
-}
Index: Src/Common/Common/Error.hpp
===================================================================
--- Src/Common/Common/Error.hpp	(revision 830)
+++ Src/Common/Common/Error.hpp	(working copy)
@@ -1,60 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
-<http://www.cypherjb.com/> <cypher.jb@gmail.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows
-#include <Windows.h>
-
-// C++ Standard Library
-#include <string>
-#include <stdexcept>
-#include <system_error>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/exception/all.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-namespace Hades
-{
-  // Error info (function name)
-  typedef boost::error_info<struct TagErrorFunc, std::string> ErrorFunction;
-  // Error info (error string)
-  typedef boost::error_info<struct TagErrorString, std::string> ErrorString;
-  // Error info (Windows error code)
-  typedef boost::error_info<struct TagErrorCode, std::error_code> 
-    ErrorCode;
-    
-  // Call 'GetLastError' and convert result to error_code
-  inline std::error_code GetLastErrorCode()
-  {
-    DWORD const LastError = GetLastError();
-    return std::error_code(LastError, std::system_category());
-  }
-
-  // Base exception class
-  class HadesError : public virtual std::exception, 
-    public virtual boost::exception
-  { };
-}
Index: Src/Common/Common/Filesystem.hpp
===================================================================
--- Src/Common/Common/Filesystem.hpp	(revision 830)
+++ Src/Common/Common/Filesystem.hpp	(working copy)
@@ -1,123 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
-<http://www.cypherjb.com/> <cypher.jb@gmail.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// C++ Standard Library
-#include <string>
-#include <vector>
-#include <fstream>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/filesystem.hpp>
-#include <boost/filesystem/fstream.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Windows API
-#include <Windows.h>
-
-// Hades
-#include "Error.hpp"
-#include "WinAux.hpp"
-#include "StringBuffer.hpp"
-
-namespace Hades
-{
-  namespace Windows
-  {
-    // Filesystem error type
-    class FilesystemError : public virtual HadesError 
-    { };
-
-    // Load a buffer into a file
-    inline void BufferToFile(std::vector<BYTE> const& Buffer, 
-      boost::filesystem::path const& Path)
-    {
-      // Open file
-      boost::filesystem::basic_ofstream<BYTE> File(Path, std::ios::binary);
-      if (!File)
-      {
-        BOOST_THROW_EXCEPTION(FilesystemError() << 
-          ErrorFunction("BufferToFile") << 
-          ErrorString("Could not open file."));
-      }
-
-      // Copy buffer to file
-      File.write(&Buffer[0], Buffer.size());
-    }
-
-    // Load a file into a buffer
-    inline std::vector<BYTE> FileToBuffer(boost::filesystem::path const& Path)
-    {
-      // Open file
-      boost::filesystem::basic_ifstream<BYTE> File(Path, std::ios::binary | 
-        std::ios::ate);
-      if (!File)
-      {
-        BOOST_THROW_EXCEPTION(FilesystemError() << 
-          ErrorFunction("FileToBuffer") << 
-          ErrorString("Could not open file."));
-      }
-
-      // Copy file to buffer
-      std::vector<BYTE> Buffer(static_cast<std::size_t>(File.tellg()));
-      File.seekg(0, std::ios::beg);
-      File.read(&Buffer[0], Buffer.size());
-
-      // Return file as buffer
-      return Buffer;
-    }
-
-    // Get path to self (directory)
-    inline boost::filesystem::path GetSelfPath()
-    {
-      // Get self
-      HMODULE const ModMe(reinterpret_cast<HMODULE>(GetBaseOfSelf()));
-
-      // Get path to self
-      DWORD const SelfPathSize = MAX_PATH;
-      std::basic_string<TCHAR> SelfFullPath;
-      if (!GetModuleFileName(ModMe, Util::MakeStringBuffer(SelfFullPath, 
-        SelfPathSize), SelfPathSize) || GetLastError() == 
-        ERROR_INSUFFICIENT_BUFFER)
-      {
-        std::error_code const LastError = GetLastErrorCode();
-        BOOST_THROW_EXCEPTION(HadesError() << 
-          ErrorFunction("GetSelfPath") << 
-          ErrorString("Could not get path to self.") << 
-          ErrorCode(LastError));
-      }
-
-      // Path to self
-      return boost::filesystem::path(SelfFullPath);
-    }
-
-    // Get path to self (directory)
-    inline boost::filesystem::path GetSelfDirPath()
-    {
-      // Path to self dir
-      return GetSelfPath().parent_path();
-    }
-  }
-}
Index: Src/Common/Common/I18n.hpp
===================================================================
--- Src/Common/Common/I18n.hpp	(revision 830)
+++ Src/Common/Common/I18n.hpp	(working copy)
@@ -1,78 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
-<http://www.cypherjb.com/> <cypher.jb@gmail.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// C++ Standard Library
-#include <string>
-#ifdef _MSC_VER
-#include <cvt/wstring>
-#endif // #ifdef _MSC_VER
-
-// Boost
-#include <boost/lexical_cast.hpp>
-
-namespace boost
-{
-  // Boost.LexicalCast specialization to allow conversions from wide to narrow 
-  // strings.
-  template<> 
-  inline std::string lexical_cast<std::string, std::wstring>(
-    std::wstring const& Source)
-  {
-  #ifdef _MSC_VER
-    return stdext::cvt::wstring_convert<std::codecvt<wchar_t, char, 
-      mbstate_t>>().to_bytes(Source);
-  #else
-    // Fixme: Implement fully for non-MSVC
-    return std::string(Source.cbegin(), Source.cend());
-  #endif // #ifdef _MSC_VER
-  }
-  
-  // Boost.LexicalCast specialization to allow conversions from narrow to wide 
-  // strings.
-  template<> 
-  inline std::wstring lexical_cast<std::wstring, std::string>(
-    std::string const& Source)
-  {
-  #ifdef _MSC_VER
-    return stdext::cvt::wstring_convert<std::codecvt<wchar_t, char, 
-      mbstate_t>>().from_bytes(Source);
-  #else
-    // Fixme: Implement fully for non-MSVC
-    return std::wstring(Source.cbegin(), Source.cend());
-  #endif // #ifdef _MSC_VER
-  }
-  
-  // Turn attempts to convert between the same string types into a nullsub.
-  template<> 
-  inline std::wstring lexical_cast<std::wstring, std::wstring>(
-    std::wstring const& Source)
-  {
-    return Source;
-  }
-  
-  // Turn attempts to convert between the same string types into a nullsub.
-  template<> 
-  inline std::string lexical_cast<std::string, std::string>(
-    std::string const& Source)
-  {
-    return Source;
-  }
-}
Index: Src/Common/Common/Logger.hpp
===================================================================
--- Src/Common/Common/Logger.hpp	(revision 830)
+++ Src/Common/Common/Logger.hpp	(working copy)
@@ -1,205 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
-<http://www.cypherjb.com/> <cypher.jb@gmail.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <tchar.h>
-#include <Windows.h>
-
-// C++ Standard Library
-#include <string>
-#include <vector>
-#include <utility>
-#include <fstream>
-#include <iostream>
-
-// Boost C++ Libraries
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/thread.hpp>
-#include <boost/format.hpp>
-#include <boost/date_time.hpp>
-#include <boost/filesystem.hpp>
-#include <boost/iostreams/stream.hpp>
-#include <boost/filesystem/fstream.hpp>
-#include <boost/iostreams/categories.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Error.hpp"
-#include "Filesystem.hpp"
-
-#define HADES_LOG_THREAD_SAFE(x)\
-{\
-boost::lock_guard<boost::mutex> MyLock(Hades::Util::Logger<char>::GetMutex());\
-x;\
-}\
-
-
-namespace Hades
-{
-  namespace Util
-  {
-    // Logging class
-    template <typename CharT>
-    class Logger
-    {
-    public:
-      // Logger error type
-      class Error : public virtual HadesError 
-      { };
-
-      // Get logger mutex
-      static boost::mutex& GetMutex()
-      {
-        static boost::mutex MyMutex;
-        return MyMutex;
-      }
-
-      // Sink information
-      typedef CharT char_type;
-      typedef boost::iostreams::sink_tag category;
-
-      // STL typedefs
-      typedef boost::filesystem::basic_ofstream<char_type> tofstream;
-
-      // Stream typedef
-      typedef boost::iostreams::stream<Logger<CharT>> Stream;
-
-      // Constructor
-      Logger(boost::filesystem::path const& LogDirPath, 
-        std::basic_string<TCHAR> const& Filename) 
-        : m_LogPath(GeneratePath(LogDirPath, Filename))
-      { }
-
-      // Get path to log file
-      boost::filesystem::path GetLogPath() const 
-      {
-        return m_LogPath;
-      }
-
-      // Generate path to log file.
-      std::basic_string<TCHAR> GeneratePath(boost::filesystem::path const& 
-        LogDirPath, std::basic_string<TCHAR> const& Filename)
-      {
-        // Get local time
-        boost::posix_time::ptime const Time(boost::posix_time::second_clock::
-          local_time());
-        // Convert time to string YYYY-MM-DDTHH:MM:SS
-        std::basic_string<TCHAR> TimeStr(boost::posix_time::
-          to_iso_extended_string_type<TCHAR>(Time));
-        // Reformat time YYYY-MM-DD_HH-MM-SS
-        TimeStr[10] = _T('_'); TimeStr[13] = _T('-'); TimeStr[16] = _T('-');
-
-        // Generate file path relative to initial directory
-        std::basic_string<TCHAR> const LogFile(Filename + _T("-") + TimeStr + 
-          _T(".log"));
-
-        // Make full path to log file
-        boost::filesystem::path const LogPath(LogDirPath / LogFile);
-
-        // Return path to log file
-        return LogPath.string<std::basic_string<TCHAR>>();
-      }
-
-      // Writes n characters from s
-      std::streamsize write(const char_type* s, std::streamsize n)
-      {
-        // Get time
-        boost::posix_time::ptime const Time(boost::posix_time::second_clock::
-          local_time());
-        // Convert time to string YYYY-MM-DDTHH:MM:SS
-        std::basic_string<char_type> TimeStr(boost::posix_time::
-          to_iso_extended_string_type<char_type>(Time));
-        // Reformat time YYYY-MM-DD_HH-MM-SS
-        TimeStr[10] = '_'; TimeStr[13] = '-'; TimeStr[16] = '-';
-
-        // Open file
-        tofstream Out(m_LogPath, tofstream::out | tofstream::app);
-        if(!Out)
-        {
-          BOOST_THROW_EXCEPTION(Error() << 
-            ErrorFunction("Logger::write") << 
-            ErrorString("Could not open file."));
-        }
-
-        // Write time as string
-        Out << '[' << TimeStr << "]: ";
-
-        // Write data
-        Out.write(s, n);
-
-        // Return size
-        return n;
-      }
-
-    private:
-      // Path to log file
-      boost::filesystem::path m_LogPath;
-    };
-
-    // Initialize logging. Returns wide path to self.
-    inline void InitLogger(std::basic_string<TCHAR> const& OutName, 
-      std::basic_string<TCHAR> const& LogName)
-    {
-      // Check if we actually need to continue
-      if (OutName.empty() && LogName.empty())
-      {
-        return;
-      }
-
-      // Path to self dir
-      boost::filesystem::path const SelfDirPath(Windows::GetSelfDirPath());
-
-      // Ensure Logs directory exists
-      boost::filesystem::path const LogsPath(SelfDirPath / L"/Logs/");
-      boost::filesystem::create_directory(LogsPath);
-
-      // Redirect standard output streams to file
-      if (!OutName.empty())
-      {
-        static Logger<char> AnsiLogger(LogsPath, OutName);
-        static Logger<char>::Stream AnsiStream(AnsiLogger);
-        static Logger<wchar_t> WideLogger(LogsPath, OutName);
-        static Logger<wchar_t>::Stream WideStream(WideLogger);
-        std::cout.rdbuf(AnsiStream.rdbuf());
-        std::wcout.rdbuf(WideStream.rdbuf());
-
-        std::wcout << "Logger initialized." << std::endl;
-      }
-
-      // Redirect standard log output streams to file
-      if (!LogName.empty())
-      {
-        static Logger<char> AnsiLogger(LogsPath, LogName);
-        static Logger<char>::Stream AnsiStream(AnsiLogger);
-        static Logger<wchar_t> WideLogger(LogsPath, LogName);
-        static Logger<wchar_t>::Stream WideStream(WideLogger);
-        std::clog.rdbuf(AnsiStream.rdbuf());
-        std::wclog.rdbuf(WideStream.rdbuf());
-
-        std::wclog << "Logger initialized." << std::endl;
-      }
-    }
-  }
-}
Index: Src/Common/Common/StringBuffer.hpp
===================================================================
--- Src/Common/Common/StringBuffer.hpp	(revision 830)
+++ Src/Common/Common/StringBuffer.hpp	(working copy)
@@ -1,121 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
-<http://www.cypherjb.com/> <cypher.jb@gmail.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// C++ Standard Library
-#include <string>
-#include <vector>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/noncopyable.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-namespace Hades
-{
-  namespace Util
-  {
-    // Utility class to 'bind' a temporary buffer to a string and allow 
-    // easy interoperability with C-style APIs.
-    template <class CharT>
-    class StringBuffer : private boost::noncopyable
-    {
-    public:
-      // Constructor
-      StringBuffer(std::basic_string<CharT>& String, std::size_t Size) 
-        : m_String(&String), 
-        m_Buffer(Size + 1) 
-      { }
-
-      // Move constructor
-      StringBuffer(StringBuffer&& Other)
-      {
-        *this = std::move(Other);
-      }
-
-      // Move assignment operator
-      StringBuffer& operator=(StringBuffer&& Other)
-      {
-        this->m_String = Other.m_String;
-        Other.m_String = 0;
-
-        this->m_Buffer = std::move(Other.m_Buffer);
-
-        return *this;
-      }
-
-      // Destructor
-      ~StringBuffer()
-      {
-        // Commit current buffer
-        Commit();
-      }
-
-      // Get pointer to internal buffer
-      CharT* Get()
-      {
-        return &m_Buffer[0];
-      }
-
-      // Implicit conversion operator to allow for easy C-style API 
-      // interoperability
-      operator CharT* ()
-      {
-        return Get();
-      }
-
-      // Commit current buffer to target string
-      void Commit()
-      {
-        if (!m_Buffer.empty())
-        {
-          *m_String = &m_Buffer[0];
-          m_Buffer.clear();
-        }
-      }
-
-      // Clear current buffer
-      void Abort()
-      {
-        m_Buffer.clear();
-      }
-
-    private:
-      // Target string
-      std::basic_string<CharT>* m_String;
-
-      // Temporary buffer
-      std::vector<CharT> m_Buffer;
-    };
-
-    // Make string buffer class. Function is simply used to automatically 
-    // deduce and forward template argument type.
-    template <class CharT>
-    StringBuffer<CharT> MakeStringBuffer(std::basic_string<CharT>& String, 
-      std::size_t Size)
-    {
-      return StringBuffer<CharT>(String, Size);
-    }
-  }
-}
Index: Src/Common/Common/VecN.hpp
===================================================================
--- Src/Common/Common/VecN.hpp	(revision 830)
+++ Src/Common/Common/VecN.hpp	(working copy)
@@ -1,334 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
-<http://www.cypherjb.com/> <cypher.jb@gmail.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// C++ Standard Library
-#include <array>
-#include <cmath>
-#include <vector>
-#include <numeric>
-#include <cassert>
-#include <iterator>
-#include <stdexcept>
-#include <algorithm>
-#include <functional>
-
-namespace Hades
-{
-  namespace Math
-  {
-    // N-Dimensional Vector
-    template <class ElemT, std::size_t Num>
-    class VecN
-    {
-    public:
-      // ElemT used to store elements
-      typedef std::array<ElemT, Num> DataT;    
-
-      // Element placeholders. For convenience only.
-      enum Elems
-      {
-        XElem,
-        YElem,
-        ZElem
-      };
-
-      // Default constructor. 
-      // All dimensions default initialized.
-      VecN() 
-        : m_Data() 
-      {
-        std::fill(m_Data.begin(), m_Data.end(), static_cast<ElemT>(0)); 
-      }
-
-      // Vec1 constructor
-      VecN(ElemT X) 
-        : m_Data()
-      {
-        static_assert(Num == 1, "Wrong constructor used for VecN");
-        m_Data[XElem] = X;
-      }
-
-      // Vec2 constructor
-      VecN(ElemT X, ElemT Y) 
-        : m_Data()
-      {
-        static_assert(Num == 2, "Wrong constructor used for VecN");
-        m_Data[XElem] = X; m_Data[YElem] = Y;
-      }
-
-      // Vec3 constructor
-      VecN(ElemT X, ElemT Y, ElemT Z) 
-        : m_Data()
-      {
-        static_assert(Num == 3, "Wrong constructor used for VecN");
-        m_Data[XElem] = X; m_Data[YElem] = Y; m_Data[ZElem] = Z;
-      }
-
-      // Vec4 constructor
-      VecN(ElemT X, ElemT Y, ElemT Z, ElemT N) 
-        : m_Data()
-      {
-        static_assert(Num == 4, "Wrong constructor used for VecN");
-        m_Data[XElem] = X; m_Data[YElem] = Y; m_Data[ZElem] = Z; m_Data[3] = N;
-      }
-
-      // Get reference to vector element
-      // Implemented by calling const version of function and const_cast'ing 
-      // the returned reference. Safe in this scenario. For more information 
-      // see [Myers].
-      ElemT& operator[] (unsigned int Index)
-      {
-        assert(Index < Num && "Out of range element access in VecN");
-        return const_cast<ElemT&>(static_cast<const VecN<ElemT, Num>& >(*this).
-          operator[](Index));
-      }
-
-      // Get const reference to vector element
-      const ElemT& operator[] (unsigned int Index) const
-      {
-        assert(Index < Num && "Out of range element access in VecN");
-        return m_Data[Index]; 
-      }
-
-      // Get negated vector
-      VecN<ElemT, Num> operator- () const
-      {
-        VecN<ElemT, Num> Result;
-        std::transform(m_Data.begin(), m_Data.end(), Result.m_Data.begin(), 
-          std::negate<ElemT>());
-        return Result;
-      }
-
-      // Vector subtraction
-      VecN<ElemT, Num> operator- (const VecN<ElemT, Num>& Rhs) const
-      {
-        VecN<ElemT, Num> Result(*this);
-        Result -= Rhs;
-        return Result;
-      }
-
-      // Vector subtraction
-      VecN<ElemT, Num> operator-= (const VecN<ElemT, Num>& Rhs) 
-      {
-        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
-          m_Data.begin(), std::minus<ElemT>());
-        return *this;
-      }
-
-      // Vector addition
-      VecN<ElemT, Num> operator+ (const VecN<ElemT, Num>& Rhs) const
-      {
-        VecN<ElemT, Num> Result(*this);
-        Result += Rhs;
-        return Result;
-      }
-
-      // Vector addition
-      VecN<ElemT, Num> operator+= (const VecN<ElemT, Num>& Rhs) 
-      {
-        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
-          m_Data.begin(), std::plus<ElemT>());
-        return *this;
-      }
-
-      // Vector multiplication (scales elements)
-      VecN<ElemT, Num> operator* (ElemT Rhs) const
-      {
-        VecN<ElemT, Num> Result(*this);
-        Result *= Rhs;
-        return Result;
-      }
-
-      // Vector multiplication (scales elements)
-      // Mixed mode version
-      friend inline VecN<ElemT, Num> operator* (ElemT Lhs, 
-        const VecN<ElemT, Num>& Rhs)
-      {
-        return Rhs * Lhs;
-      }
-
-      // Vector multiplication (scalar/dot product)
-      ElemT operator* (const VecN<ElemT, Num>& Rhs) const
-      {
-        DataT Result(Num);
-        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
-          Result.begin(), std::multiplies<ElemT>());
-        return std::accumulate(Result.begin(), Result.end(), 
-          static_cast<ElemT>(0));
-      }
-
-      // Vector multiplication (scales elements)
-      VecN<ElemT, Num> operator*= (ElemT Rhs) 
-      {
-        std::transform(m_Data.begin(), m_Data.end(), m_Data.begin(), 
-          std::bind(std::multiplies<ElemT>(), std::placeholders::_1, Rhs));
-        return *this;
-      }
-
-      // Vector division (scalar/dot division)
-      ElemT operator/ (const VecN<ElemT, Num>& Rhs) const
-      {
-        DataT Result(Num);
-        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
-          Result.begin(), std::divides<ElemT>());
-        return std::accumulate(Result.begin(), Result.end(), 
-          static_cast<ElemT>(0));
-      }
-
-      // Vector division (scalar/dot division)
-      VecN<ElemT, Num> operator/= (const VecN<ElemT, Num>& Rhs) 
-      {
-        std::transform(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin(), 
-          m_Data.begin(), std::divides<ElemT>());
-        return *this;
-      }
-
-      // Equality test
-      bool operator == (const VecN<ElemT, Num>& Rhs) const
-      {
-        return std::equal(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin());
-      }
-
-      // Inequality check
-      bool operator != (const VecN<ElemT, Num>& Rhs) const
-      {
-        return !std::equal(m_Data.begin(), m_Data.end(), Rhs.m_Data.begin());
-      }
-
-      // Output stream overload
-      // Prints in format:
-      // E1 E2 ... EN
-      friend inline std::ostream& operator << (std::ostream& Lhs, 
-        const VecN<ElemT, Num>& Rhs)
-      {
-        std::copy(Rhs.m_Data.begin(), Rhs.m_Data.end(), 
-          std::ostream_iterator<ElemT>(Lhs, " "));
-        return Lhs;
-      }
-
-      // Output stream overload
-      // Prints in format:
-      // E1 E2 ... EN
-      friend inline std::wostream& operator << (std::wostream& Lhs, 
-        const VecN<ElemT, Num>& Rhs)
-      {
-        std::copy(Rhs.m_Data.begin(), Rhs.m_Data.end(), 
-          std::ostream_iterator<ElemT, wchar_t>(Lhs, L" "));
-        return Lhs;
-      }
-
-      // Gets the squared length of a vector
-      friend inline ElemT LengthSquared(const VecN<ElemT, Num>& v)
-      {
-        VecN<ElemT, Num> Temp;
-        std::transform(v.m_Data.begin(), v.m_Data.end(), v.m_Data.begin(), 
-          Temp.m_Data.begin(), std::multiplies<ElemT>());
-        return std::accumulate(Temp.m_Data.begin(), Temp.m_Data.end(), 
-          static_cast<ElemT>(0));
-      }
-
-      // Gets the length of a vector
-      friend inline ElemT Length(const VecN<ElemT, Num>& v)
-      {
-        return static_cast<ElemT>(sqrt(static_cast<long double>(
-          LengthSquared(v))));
-      }
-
-      // Normalizes a vector
-      friend inline ElemT Normalize(VecN<ElemT, Num>& v)
-      {
-        ElemT Len = Length(v);
-        if (Len != static_cast<ElemT>(0))
-        {
-          std::transform(v.m_Data.cbegin(), v.m_Data.end(), v.m_Data.begin(), 
-            std::bind(std::divides<ElemT>(), std::placeholders::_1, Len));
-        }
-        return Len;
-      }
-
-      // Tests if a vector is normalized
-      friend inline bool IsNormalized(const VecN<ElemT, Num>& v, 
-        ElemT Eps = static_cast<ElemT>(1.0001f))
-      {
-        return static_cast<ElemT>(fabs(static_cast<long double>(
-          LengthSquared(v) - static_cast<ElemT>(1)))) 
-          <= static_cast<ElemT>(Eps);
-      }
-
-      // Reflection
-      friend inline VecN<ElemT, Num> Reflect(const VecN<ElemT, Num>& v, 
-        const VecN<ElemT, Num>& Normal)
-      {
-        return v - (static_cast<ElemT>(2.0) * ((v * Normal) * Normal));
-      }
-
-      // Distance
-      friend inline ElemT Distance(const VecN<ElemT, Num>& v1, 
-        const VecN<ElemT, Num>& v2)
-      {
-        return Length(v1 - v2);
-      }
-
-    private:
-      // Vector elements
-      DataT m_Data;
-    };
-
-    // Cross product
-    template <typename ElemT>
-    inline VecN<ElemT, 3> Cross(const VecN<ElemT, 3>& v1, 
-      const VecN<ElemT, 3>& v2)
-    {
-      typedef VecN<ElemT, 3> VecT;
-      return VecT(
-        (v1[VecT::YElem] * v2[VecT::ZElem]) - 
-        (v1[VecT::ZElem] * v2[VecT::YElem]), 
-        (v1[VecT::ZElem] * v2[VecT::XElem]) - 
-        (v1[VecT::XElem] * v2[VecT::ZElem]), 
-        (v1[VecT::XElem] * v2[VecT::YElem]) - 
-        (v1[VecT::YElem] * v2[VecT::XElem])
-        );
-    }
-
-    // Ease of use typedefs
-    typedef VecN<int, 2> Vec2i;
-    typedef VecN<float, 2> Vec2f;
-    typedef VecN<double, 2> Vec2d;
-    typedef VecN<int, 3> Vec3i;
-    typedef VecN<float, 3> Vec3f;
-    typedef VecN<double, 3> Vec3d;
-
-    // Assert assumptions
-    static_assert(sizeof(Vec2f) == (sizeof(float) * 2), 
-      "Size of Vec2f is incorrect!");
-    static_assert(sizeof(Vec2d) == (sizeof(double) * 2), 
-      "Size of Vec2d is incorrect!");
-    static_assert(sizeof(Vec2i) == (sizeof(int) * 2), 
-      "Size of Vec2i is incorrect!");
-
-    static_assert(sizeof(Vec3f) == (sizeof(float) * 3), 
-      "Size of Vec3f is incorrect!");
-    static_assert(sizeof(Vec3d) == (sizeof(double) * 3), 
-      "Size of Vec3d is incorrect!");
-    static_assert(sizeof(Vec3i) == (sizeof(int) * 3), 
-      "Size of Vec3i is incorrect!");
-  }
-}
Index: Src/Common/Common/WinAux.hpp
===================================================================
--- Src/Common/Common/WinAux.hpp	(revision 830)
+++ Src/Common/Common/WinAux.hpp	(working copy)
@@ -1,53 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 Cypherjb (aka Chazwazza, aka Cypher). 
-<http://www.cypherjb.com/> <cypher.jb@gmail.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <Windows.h>
-
-// Hades
-#include "Error.hpp"
-
-namespace Hades
-{
-  namespace Windows
-  {
-    // WinAux error type
-    class WinAuxError : public virtual HadesError 
-    { };
-
-    // Get base of self
-    inline PVOID GetBaseOfSelf()
-    {
-      MEMORY_BASIC_INFORMATION MemInfo = { 0 };
-      if (!VirtualQuery(reinterpret_cast<PVOID>(&GetBaseOfSelf), &MemInfo, 
-        sizeof(MemInfo)))
-      {
-        std::error_code const LastError = GetLastErrorCode();
-        BOOST_THROW_EXCEPTION(WinAuxError() << 
-          ErrorFunction("GetBaseOfSelf") << 
-          ErrorString("Failed to query memory.") << 
-          ErrorCode(LastError));
-      }
-
-      return MemInfo.AllocationBase;
-    }
-  }
-}
Index: Src/Common/Jamfile.v2
===================================================================
--- Src/Common/Jamfile.v2	(revision 830)
+++ Src/Common/Jamfile.v2	(working copy)
@@ -1,12 +0,0 @@
-# Common/Jamfile.v2
-
-project
-  : requirements <library>/boost//date_time/<link>static 
-  ;
-
-alias Common 
-  : /boost//date_time/<link>static 
-  : 
-  : 
-  : <include>"."
-  ;
Index: Src/Memory/Jamfile.v2
===================================================================
--- Src/Memory/Jamfile.v2	(revision 830)
+++ Src/Memory/Jamfile.v2	(working copy)
@@ -31,9 +31,9 @@
 
 lib Memory 
   : [ glob Memory/*.cpp ] /Common//Common /Dependencies//AsmJit /Dependencies//BeaEngine /Dependencies//RapidXML user32 advapi32 dbghelp shell32 psapi 
-  : <link>static 
+  : <link>static <include>"../../Include/Memory/Memory"
   : 
-  : <include>"." 
+  : <include>"../../Include/Memory"
   ;
 
 lib MMHelper 
Index: Src/Memory/Memory/Disassembler.hpp
===================================================================
--- Src/Memory/Memory/Disassembler.hpp	(revision 830)
+++ Src/Memory/Memory/Disassembler.hpp	(working copy)
@@ -1,79 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <Windows.h>
-
-// C++ Standard Library
-#include <string>
-#include <vector>
-
-// BeaEngine
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include "BeaEngine/BeaEngine.h"
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Disassembler data
-    struct DisasmData
-    {
-      DISASM Disasm;
-      int Len;
-      std::vector<BYTE> Raw;
-    };
-
-    // Disassembler managing class
-    class Disassembler
-    {
-    public:
-      // Disassembler exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      // Constructor
-      explicit Disassembler(MemoryMgr const& MyMemory);
-
-      // Disassemble target to string
-      std::vector<std::basic_string<TCHAR>> DisassembleToStr(PVOID Address, 
-        DWORD_PTR NumInstructions) const;
-
-      // Disassemble target
-      std::vector<DisasmData> Disassemble(PVOID Address, 
-        DWORD_PTR NumInstructions) const;
-
-    private:
-      // MemoryMgr instance
-      MemoryMgr m_MemoryMgr;
-    };
-  }
-}
Index: Src/Memory/Memory/DosHeader.hpp
===================================================================
--- Src/Memory/Memory/DosHeader.hpp	(revision 830)
+++ Src/Memory/Memory/DosHeader.hpp	(working copy)
@@ -1,180 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows
-#include <Windows.h>
-
-// C++ Standard Library
-#include <array>
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "PeFile.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // PE file DOS header
-    class DosHeader
-    {
-    public:
-      // DOS header error class
-      class Error : public virtual HadesMemError
-      { };
-
-      // Constructor
-      explicit DosHeader(PeFile const& MyPeFile);
-
-      // Whether magic is valid
-      bool IsMagicValid() const;
-
-      // Ensure magic is valid
-      void EnsureMagicValid() const;
-
-      // Get magic
-      WORD GetMagic() const;
-
-      // Get bytes on last page
-      WORD GetBytesOnLastPage() const;
-
-      // Get pages in file
-      WORD GetPagesInFile() const;
-
-      // Get relocations
-      WORD GetRelocations() const;
-
-      // Get size of header in paragraphs
-      WORD GetSizeOfHeaderInParagraphs() const;
-
-      // Get minimum extra paragraphs needed
-      WORD GetMinExtraParagraphs() const;
-
-      // Get maximum extra paragraphs needed
-      WORD GetMaxExtraParagraphs() const;
-
-      // Get initial SS value
-      WORD GetInitialSS() const;
-
-      // Get initial SP value
-      WORD GetInitialSP() const;
-
-      // Get checksum
-      WORD GetChecksum() const;
-
-      // Get initial IP value
-      WORD GetInitialIP() const;
-
-      // Get initial CS value
-      WORD GetInitialCS() const;
-
-      // Get file address of reloc table
-      WORD GetRelocTableFileAddr() const;
-
-      // Get overlay number
-      WORD GetOverlayNum() const;
-
-      // Get first set of reserved words
-      std::array<WORD, 4> GetReservedWords1() const;
-
-      // Get OEM ID
-      WORD GetOEMID() const;
-
-      // Get OEM info
-      WORD GetOEMInfo() const;
-
-      // Get second set of reserved words
-      std::array<WORD, 10> GetReservedWords2() const;
-
-      // Get new header offset
-      LONG GetNewHeaderOffset() const;
-
-      // Set magic
-      void SetMagic(WORD Magic) const;
-
-      // Set bytes on last page
-      void SetBytesOnLastPage(WORD BytesOnLastPage) const;
-
-      // Set pages in file
-      void SetPagesInFile(WORD PagesInFile) const;
-
-      // Set relocations
-      void SetRelocations(WORD Relocations) const;
-
-      // Set size of header in paragraphs
-      void SetSizeOfHeaderInParagraphs(WORD SizeOfHeaderInParagraphs) const;
-
-      // Set minimum extra paragraphs needed
-      void SetMinExtraParagraphs(WORD MinExtraParagraphs) const;
-
-      // Set maximum extra paragraphs needed
-      void SetMaxExtraParagraphs(WORD MaxExtraParagraphs) const;
-
-      // Set initial SS value
-      void SetInitialSS(WORD InitialSS) const;
-
-      // Set initial SP value
-      void SetInitialSP(WORD InitialSP) const;
-
-      // Set checksum
-      void SetChecksum(WORD Checksum) const;
-
-      // Set initial IP value
-      void SetInitialIP(WORD InitialIP) const;
-
-      // Set initial CS value
-      void SetInitialCS(WORD InitialCS) const;
-
-      // Set file address of reloc table
-      void SetRelocTableFileAddr(WORD RelocTableFileAddr) const;
-
-      // Set overlay number
-      void SetOverlayNum(WORD OverlayNum) const;
-
-      // Set first set of reserved words
-      void SetReservedWords1(std::array<WORD, 4> const& ReservedWords1) const;
-
-      // Set OEM ID
-      void SetOEMID(WORD OEMID) const;
-
-      // Set OEM info
-      void SetOEMInfo(WORD OEMInfo) const;
-
-      // Set second set of reserved words
-      void SetReservedWords2(std::array<WORD, 10> const& ReservedWords2) const;
-
-      // Set new header offset
-      void SetNewHeaderOffset(LONG Offset) const;
-
-    private:
-      // PE file
-      PeFile m_PeFile;
-
-      // Memory instance
-      MemoryMgr m_Memory;
-
-      // DOS header base
-      PBYTE m_pBase;
-    };
-  }
-}
Index: Src/Memory/Memory/Error.hpp
===================================================================
--- Src/Memory/Memory/Error.hpp	(revision 830)
+++ Src/Memory/Memory/Error.hpp	(working copy)
@@ -1,33 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Hades
-#include "Common/Error.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Base exception class
-    class HadesMemError : public virtual HadesError
-    { };
-  }
-}
Index: Src/Memory/Memory/ExportDir.hpp
===================================================================
--- Src/Memory/Memory/ExportDir.hpp	(revision 830)
+++ Src/Memory/Memory/ExportDir.hpp	(working copy)
@@ -1,202 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows
-#include <Windows.h>
-
-// C++ Standard Library
-#include <string>
-#include <utility>
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "PeFile.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // PE file export directory
-    class ExportDir
-    {
-    public:
-      // ExportDir error class
-      class Error : public virtual HadesMemError
-      { };
-
-      // Constructor
-      explicit ExportDir(PeFile const& MyPeFile);
-
-      // Whether export directory is valid
-      bool IsValid() const;
-
-      // Ensure export directory is valid
-      void EnsureValid() const;
-
-      // Get characteristics
-      DWORD GetCharacteristics() const;
-
-      // Set characteristics
-      void SetCharacteristics(DWORD Characteristics) const;
-
-      // Get time date stamp
-      DWORD GetTimeDateStamp() const;
-
-      // Set time date stamp
-      void SetTimeDateStamp(DWORD TimeDateStamp) const;
-
-      // Get major version
-      WORD GetMajorVersion() const;
-
-      // Set major version
-      void SetMajorVersion(WORD MajorVersion) const;
-
-      // Get minor version
-      WORD GetMinorVersion() const;
-
-      // Set minor version
-      void SetMinorVersion(WORD MinorVersion) const;
-
-      // Get module name
-      std::string GetName() const;
-
-      // Get ordinal base
-      DWORD GetOrdinalBase() const;
-
-      // Set ordinal base
-      void SetOrdinalBase(DWORD OrdinalBase) const;
-
-      // Get number of functions
-      DWORD GetNumberOfFunctions() const;
-
-      // Set number of functions
-      void SetNumberOfFunctions(DWORD NumberOfFunctions) const;
-
-      // Get number of names
-      DWORD GetNumberOfNames() const;
-
-      // Set number of names
-      void SetNumberOfNames(DWORD NumberOfNames) const;
-
-      // Get address of functions
-      DWORD GetAddressOfFunctions() const;
-
-      // Set address of functions
-      void SetAddressOfFunctions(DWORD AddressOfFunctions) const;
-
-      // Get address of names
-      DWORD GetAddressOfNames() const;
-
-      // Set address of names
-      void SetAddressOfNames(DWORD AddressOfNames) const;
-
-      // Get address of name ordinals
-      DWORD GetAddressOfNameOrdinals() const;
-
-      // Set address of name ordinals
-      void SetAddressOfNameOrdinals(DWORD AddressOfNameOrdinals) const;
-
-      // Get base of export dir
-      PBYTE GetBase() const;
-
-      // Get raw export dir
-      IMAGE_EXPORT_DIRECTORY GetExportDirRaw() const;
-
-    private:
-      // PE file
-      PeFile m_PeFile;
-
-      // Memory instance
-      MemoryMgr m_Memory;
-
-      // Base of export dir
-      mutable PBYTE m_pBase;
-    };
-
-    // PE file export data
-    class Export
-    {
-    public:
-      // Constructor
-      Export(PeFile const& MyPeFile, DWORD Ordinal);
-
-      // Get RVA
-      DWORD GetRva() const;
-
-      // Get VA
-      PVOID GetVa() const;
-
-      // Get name
-      std::string GetName() const;
-
-      // Get forwarder
-      std::string GetForwarder() const;
-      
-      // Get forwarder module name
-      std::string GetForwarderModule() const;
-      
-      // Get forwarder function name
-      std::string GetForwarderFunction() const;
-
-      // Get ordinal
-      WORD GetOrdinal() const;
-
-      // If entry is exported by name
-      bool ByName() const;
-
-      // If entry is forwarded
-      bool Forwarded() const;
-
-    private:
-      // PE file instance
-      PeFile m_PeFile;
-      
-      // Memory instance
-      MemoryMgr m_Memory;
-
-      // RVA
-      DWORD m_Rva;
-      
-      // VA
-      PVOID m_Va;
-      
-      // Name
-      std::string m_Name;
-      
-      // Forwarder
-      std::string m_Forwarder;
-      
-      // Split forwarder
-      std::pair<std::string, std::string> m_ForwarderSplit;
-      
-      // Ordinal
-      WORD m_Ordinal;
-      
-      // If entry is exported by name
-      bool m_ByName;
-      
-      // If entry is forwarded
-      bool m_Forwarded;
-    };
-  }
-}
Index: Src/Memory/Memory/ExportEnum.hpp
===================================================================
--- Src/Memory/Memory/ExportEnum.hpp	(revision 830)
+++ Src/Memory/Memory/ExportEnum.hpp	(working copy)
@@ -1,96 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// C++ Standard Library
-#include <memory>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/optional.hpp>
-#include <boost/iterator/iterator_facade.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Windows API
-#include <Windows.h>
-
-// Hades
-#include "ExportDir.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Section iterator
-    class ExportIter : public boost::iterator_facade<ExportIter, 
-      boost::optional<Export>, boost::incrementable_traversal_tag>
-    {
-    public:
-      // Constructor
-      explicit ExportIter(PeFile const& MyPeFile)
-        : m_PeFile(MyPeFile), 
-        m_Current()
-      {
-        ExportDir const MyExportDir(m_PeFile);
-        DWORD const NumberOfFunctions = MyExportDir.GetNumberOfFunctions();
-        if (NumberOfFunctions)
-        {
-          m_Current = Export(m_PeFile, MyExportDir.GetOrdinalBase());
-        }
-      }
-
-    private:
-      // Allow Boost.Iterator access to internals
-      friend class boost::iterator_core_access;
-
-      // For Boost.Iterator
-      void increment() 
-      {
-        ExportDir const MyExportDir(m_PeFile);
-        DWORD const NumberOfFunctions = MyExportDir.GetNumberOfFunctions();
-        DWORD const NextOrdinal = m_Current->GetOrdinal() + 1;
-        if (NextOrdinal - MyExportDir.GetOrdinalBase() < NumberOfFunctions)
-        {
-          m_Current = Export(m_PeFile, NextOrdinal);
-        }
-        else
-        {
-          m_Current = boost::optional<Export>();
-        }
-      }
-
-      // For Boost.Iterator
-      boost::optional<Export>& dereference() const
-      {
-        return m_Current;
-      }
-
-      // Memory instance
-      PeFile m_PeFile;
-
-      // Current section
-      mutable boost::optional<Export> m_Current;
-    };
-  }
-}
Index: Src/Memory/Memory/FindPattern.hpp
===================================================================
--- Src/Memory/Memory/FindPattern.hpp	(revision 830)
+++ Src/Memory/Memory/FindPattern.hpp	(working copy)
@@ -1,90 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <tchar.h>
-#include <Windows.h>
-
-// C++ Standard Library
-#include <map>
-#include <string>
-#include <vector>
-#include <utility>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/filesystem.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Pattern finding class
-    class FindPattern
-    {
-    public:
-      // FindPattern exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      // Constructor
-      explicit FindPattern(MemoryMgr const& MyMemory);
-      FindPattern(MemoryMgr const& MyMemory, HMODULE Module);
-
-      // Find pattern
-      PVOID Find(std::basic_string<TCHAR> const& Data, 
-        std::basic_string<TCHAR> const& Mask) const;
-
-      // Load patterns from XML file
-      void LoadFromXML(boost::filesystem::path const& Path);
-
-      // Get address map
-      std::map<std::basic_string<TCHAR>, PVOID> GetAddresses() const;
-
-      // Operator[] overload to allow retrieving addresses by name
-      PVOID operator[](std::basic_string<TCHAR> const& Name) const;
-
-    private:
-      // Search memory
-      PVOID Find(std::vector<std::pair<BYTE, bool>> const& Data) const;
-
-      // Memory manager instance
-      MemoryMgr m_Memory;
-
-      // Start and end addresses of search region
-      PBYTE m_Start;
-      PBYTE m_End;
-
-      // Map to hold addresses
-      std::map<std::basic_string<TCHAR>, PVOID> m_Addresses;
-    };
-  }
-}
Index: Src/Memory/Memory/Fwd.hpp
===================================================================
--- Src/Memory/Memory/Fwd.hpp	(revision 830)
+++ Src/Memory/Memory/Fwd.hpp	(working copy)
@@ -1,51 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Hades (External)
-    class Module;
-    class Region;
-    class Scanner;
-    class Process;
-    class Injector;
-    class MemoryMgr;
-    class ManualMap;
-    class FindPattern;
-    class Disassembler;
-    class Symbols;
-    
-    // Hades (Internal)
-    class Patch;
-    class PatchRaw;
-    class PatchDetour;
-    
-    // Hades (PeLib)
-    class PeFile;
-    class TlsDir;
-    class Section;
-    class DosHeader;
-    class ExportDir;
-    class NtHeaders;
-  }
-}
Index: Src/Memory/Memory/HashString.hpp
===================================================================
--- Src/Memory/Memory/HashString.hpp	(revision 830)
+++ Src/Memory/Memory/HashString.hpp	(working copy)
@@ -1,90 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-// IMPORTANT NOTE:
-// This is a modified version of work by 'Tor Brede Vekterli' who has licensed 
-// the original code under the Boost Software license[1]. As such, all 
-// compile-time string hashing code is licensed under the Boost Software 
-// License.
-// [1] http://www.boost.org/LICENSE_1_0.txt
-// The GPL notice above is present to cover any other code which is unrelated 
-// to the compile-time string hashing.
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/mpl/string.hpp>
-#include <boost/mpl/fold.hpp>
-#include <boost/mpl/size_t.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-namespace Hades
-{
-  namespace Memory
-  {
-    namespace Detail
-    {
-#ifdef _MSC_VER
-      // Disable 'integral constant overflow' warning.
-#pragma warning(push)
-#pragma warning(disable: 4307)
-#endif // #ifdef _MSC_VER
-
-      // Perform hashing
-      template <typename Seed, typename Value>
-      struct HashCombine
-      {
-        typedef boost::mpl::size_t<Seed::value ^ (Value::value + 0x9e3779b9 + 
-          (Seed::value << 6) + (Seed::value >> 2))> type;
-      };
-
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-      // Hash any sequence of integral wrapper types
-      template <typename Sequence>
-      struct HashSequence
-        : boost::mpl::fold<
-        Sequence, 
-        boost::mpl::size_t<0>, 
-        HashCombine<boost::mpl::_1, boost::mpl::_2>
-        >::type
-      { };
-    }
-
-    // Hash WITHOUT terminating null
-    template <typename String>
-    struct HashString 
-      : Detail::HashSequence<String>
-    { };
-
-    // Hash WITH terminating null
-    template <typename String>
-    struct HashCString 
-      : Detail::HashCombine<
-      Detail::HashSequence<String>, 
-      boost::mpl::size_t<0>
-      >::type
-    { };
-  }
-}
Index: Src/Memory/Memory/ImportDir.hpp
===================================================================
--- Src/Memory/Memory/ImportDir.hpp	(revision 830)
+++ Src/Memory/Memory/ImportDir.hpp	(working copy)
@@ -1,148 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows
-#include <Windows.h>
-
-// C++ Standard Library
-#include <string>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/iterator/iterator_facade.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "PeFile.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Import directory wrapper
-    class ImportDir
-    {
-    public:
-      // ImportDir error type
-      class Error : public virtual HadesMemError
-      { };
-
-      // Constructor
-      explicit ImportDir(PeFile const& MyPeFile, 
-        PIMAGE_IMPORT_DESCRIPTOR pImpDesc = nullptr);
-
-      // Whether import directory is valid
-      bool IsValid() const;
-
-      // Ensure import directory is valid
-      void EnsureValid() const;
-
-      // Get import directory base
-      PBYTE GetBase() const;
-
-      // Advance to next descriptor
-      void Advance() const;
-
-      // Get characteristics
-      DWORD GetCharacteristics() const;
-
-      // Get time and date stamp
-      DWORD GetTimeDateStamp() const;
-
-      // Get forwarder chain
-      DWORD GetForwarderChain() const;
-
-      // Get name (raw)
-      DWORD GetNameRaw() const;
-
-      // Get name
-      std::string GetName() const;
-
-      // Get first think
-      DWORD GetFirstThunk() const;
-
-    private:
-      PeFile m_PeFile;
-
-      MemoryMgr m_Memory;
-
-      mutable PIMAGE_IMPORT_DESCRIPTOR m_pImpDesc;
-    };
-
-    // Import thunk wrapper
-    class ImportThunk
-    {
-    public:
-      // ImportDir error type
-      class Error : public virtual HadesMemError
-      { };
-
-      // Constructor
-      ImportThunk(PeFile const& MyPeFile, PVOID pThunk);
-
-      // Whether thunk is valid
-      bool IsValid() const;
-
-      // Advance to next thunk
-      void Advance() const;
-
-      // Get address of data
-      DWORD_PTR GetAddressOfData() const;
-
-      // Get ordinal (raw)
-      DWORD_PTR GetOrdinalRaw() const;
-      
-      // Whether import is by ordinal
-      bool ByOrdinal() const;
-
-      // Get ordinal
-      WORD GetOrdinal() const;
-
-      // Get function
-      DWORD_PTR GetFunction() const;
-
-      // Get hint
-      WORD GetHint() const;
-
-      // Get name
-      std::string GetName() const;
-
-      // Set function
-      void SetFunction(DWORD_PTR Function) const;
-
-    private:
-      PeFile m_PeFile;
-
-      MemoryMgr m_Memory;
-
-      mutable PIMAGE_THUNK_DATA m_pThunk;
-
-      mutable PBYTE m_pBase;
-    };
-  }
-}
Index: Src/Memory/Memory/ImportEnum.hpp
===================================================================
--- Src/Memory/Memory/ImportEnum.hpp	(revision 830)
+++ Src/Memory/Memory/ImportEnum.hpp	(working copy)
@@ -1,144 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows
-#include <Windows.h>
-
-// C++ Standard Library
-#include <memory>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/optional.hpp>
-#include <boost/iterator/iterator_facade.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "PeFile.hpp"
-#include "ImportDir.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Section iterator
-    class ImportDirIter : public boost::iterator_facade<ImportDirIter, 
-      boost::optional<ImportDir>, boost::incrementable_traversal_tag>
-    {
-    public:
-      // Constructor
-      explicit ImportDirIter(PeFile const& MyPeFile) 
-        : m_PeFile(MyPeFile), 
-        m_Current(m_PeFile)
-      {
-        if (!m_Current->GetCharacteristics())
-        {
-          m_Current = boost::optional<ImportDir>();
-        }
-      }
-
-    private:
-      // Allow Boost.Iterator access to internals
-      friend class boost::iterator_core_access;
-
-      // For Boost.Iterator
-      void increment() 
-      {
-        auto pImpDesc = reinterpret_cast<PIMAGE_IMPORT_DESCRIPTOR>(
-          m_Current->GetBase());
-        m_Current = ImportDir(m_PeFile, ++pImpDesc);
-        if (!m_Current->GetCharacteristics())
-        {
-          m_Current = boost::optional<ImportDir>();
-        }
-      }
-
-      // For Boost.Iterator
-      boost::optional<ImportDir>& dereference() const
-      {
-        return m_Current;
-      }
-
-      // Memory instance
-      PeFile m_PeFile;
-
-      // Current thunk pointer
-      PIMAGE_IMPORT_DESCRIPTOR m_pImpDesc;
-
-      // Current import dir
-      mutable boost::optional<ImportDir> m_Current;
-    };
-
-    // Section iterator
-    class ImportThunkIter : public boost::iterator_facade<ImportThunkIter, 
-      boost::optional<ImportThunk>, boost::incrementable_traversal_tag>
-    {
-    public:
-      // Constructor
-      explicit ImportThunkIter(PeFile const& MyPeFile, DWORD FirstThunk) 
-        : m_PeFile(MyPeFile), 
-        m_pThunk(reinterpret_cast<PIMAGE_THUNK_DATA>(m_PeFile.RvaToVa(
-          FirstThunk))), 
-        m_Current(ImportThunk(m_PeFile, m_pThunk))
-      {
-        if (!m_Current->IsValid())
-        {
-          m_Current = boost::optional<ImportThunk>();
-        }
-      }
-
-    private:
-      // Allow Boost.Iterator access to internals
-      friend class boost::iterator_core_access;
-
-      // For Boost.Iterator
-      void increment() 
-      {
-        m_Current = ImportThunk(m_PeFile, ++m_pThunk);
-        if (!m_Current->IsValid())
-        {
-          m_Current = boost::optional<ImportThunk>();
-        }
-      }
-
-      // For Boost.Iterator
-      boost::optional<ImportThunk>& dereference() const
-      {
-        return m_Current;
-      }
-
-      // Memory instance
-      PeFile m_PeFile;
-
-      // Current thunk pointer
-      PIMAGE_THUNK_DATA m_pThunk;
-
-      // Current import thunk
-      mutable boost::optional<ImportThunk> m_Current;
-    };
-  }
-}
Index: Src/Memory/Memory/Injector.hpp
===================================================================
--- Src/Memory/Memory/Injector.hpp	(revision 830)
+++ Src/Memory/Memory/Injector.hpp	(working copy)
@@ -1,81 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <Windows.h>
-
-// C++ Standard Library
-#include <tuple>
-#include <string>
-#include <utility>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/filesystem.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "MemoryMgr.hpp"
-#include "Common/I18n.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // DLL injection class
-    class Injector
-    {
-    public:
-      // Injector exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      // Constructor
-      explicit Injector(MemoryMgr const& MyMemory);
-
-      // Inject DLL
-      HMODULE InjectDll(boost::filesystem::path const& Path, 
-        bool PathResolution = true) const;
-
-      // Call export
-      DWORD_PTR CallExport(boost::filesystem::path const& ModulePath, 
-        HMODULE ModuleRemote, std::string const& Export) const;
-
-    private:
-      // MemoryMgr instance
-      MemoryMgr m_Memory;
-    };
-    
-    // Create process (as suspended) and inject DLL
-    std::tuple<MemoryMgr, HMODULE, DWORD_PTR> CreateAndInject(
-      boost::filesystem::path const& Path, 
-      boost::filesystem::path const& WorkDir, 
-      std::basic_string<TCHAR> const& Args, 
-      std::basic_string<TCHAR> const& Module, 
-      std::string const& Export);
-  }
-}
Index: Src/Memory/Memory/ManualMap.hpp
===================================================================
--- Src/Memory/Memory/ManualMap.hpp	(revision 830)
+++ Src/Memory/Memory/ManualMap.hpp	(working copy)
@@ -1,75 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <Windows.h>
-
-// C++ Standard Library
-#include <string>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/filesystem.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Manual mapping class
-    class ManualMap
-    {
-    public:
-      // ManualMap exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      // Constructor
-      explicit ManualMap(MemoryMgr const& MyMemory);
-
-      // Manually map DLL
-      PVOID Map(boost::filesystem::path const& Path, 
-        std::string const& Export = "", bool InjectHelper = true) const;
-
-    private:
-      // Map sections
-      void MapSections(PeFile& MyPeFile, PVOID RemoteAddr) const;
-
-      // Fix imports
-      void FixImports(PeFile& MyPeFile) const;
-
-      // Fix relocations
-      void FixRelocations(PeFile& MyPeFile, PVOID RemoteAddr) const;
-
-      // MemoryMgr instance
-      MemoryMgr m_Memory;
-    };
-  }
-}
Index: Src/Memory/Memory/Memory.hpp
===================================================================
--- Src/Memory/Memory/Memory.hpp	(revision 830)
+++ Src/Memory/Memory/Memory.hpp	(working copy)
@@ -1,38 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Hades (External)
-#include "Module.hpp"
-#include "Region.hpp"
-#include "Symbol.hpp"
-#include "Process.hpp"
-#include "Scanner.hpp"
-#include "Injector.hpp"
-#include "ManualMap.hpp"
-#include "MemoryMgr.hpp"
-#include "FindPattern.hpp"
-#include "Disassembler.hpp"
-
-// Hades (Internal)
-#include "Patcher.hpp"
-
-// Hades (PeLib)
-#include "PeLib.hpp"
Index: Src/Memory/Memory/MemoryMgr.hpp
===================================================================
--- Src/Memory/Memory/MemoryMgr.hpp	(revision 830)
+++ Src/Memory/Memory/MemoryMgr.hpp	(working copy)
@@ -1,517 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <tchar.h>
-#include <Windows.h>
-
-// C++ Standard Library
-#include <memory>
-#include <string>
-#include <vector>
-#include <type_traits>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#pragma warning(disable: 4706)
-#endif // #ifdef _MSC_VER
-#include <boost/filesystem.hpp>
-#include <boost/noncopyable.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// AsmJit
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include "AsmJit/AsmJit.h"
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Error.hpp"
-#include "Process.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Memory managing class
-    class MemoryMgr
-    {
-    public:
-      // Memory exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      // Open process from process ID
-      explicit MemoryMgr(DWORD ProcID);
-
-      // Open process from process name
-      explicit MemoryMgr(std::basic_string<TCHAR> const& ProcName);
-
-      // Open process from window name and class
-      MemoryMgr(std::basic_string<TCHAR> const& WindowName, 
-        std::basic_string<TCHAR> const& ClassName);
-
-      // Calling conventions
-      enum CallConv
-      {
-        CallConv_CDECL, 
-        CallConv_STDCALL, 
-        CallConv_THISCALL, 
-        CallConv_FASTCALL, 
-        CallConv_X64, 
-        CallConv_Default
-      };
-
-      // Call remote function
-      DWORD_PTR Call(PVOID Address, std::vector<PVOID> const& Args, 
-        CallConv MyCallConv = CallConv_Default) const;
-
-      // Read memory (POD types)
-      template <typename T>
-      T Read(PVOID Address, typename std::enable_if<std::is_pod<T>::value, T>::
-        type* Dummy = 0) const;
-
-      // Read memory (string types)
-      template <typename T>
-      T Read(PVOID Address, typename std::enable_if<std::is_same<T, std::
-        basic_string<typename T::value_type>>::value, T>::type* Dummy = 0) 
-        const;
-
-      // Read memory (vector types)
-      template <typename T>
-      T Read(PVOID Address, std::size_t Size, typename std::enable_if<std::
-        is_same<T, std::vector<typename T::value_type>>::value, T>::type* 
-        Dummy = 0) const;
-
-      // Write memory (POD types)
-      template <typename T>
-      void Write(PVOID Address, T const& Data, typename std::enable_if<std::
-        is_pod<T>::value, T>::type* Dummy = 0) const;
-
-      // Write memory (string types)
-      template <typename T>
-      void Write(PVOID Address, T const& Data, typename std::enable_if<std::
-        is_same<T, std::basic_string<typename T::value_type>>::value, T>::
-        type* Dummy = 0) const;
-
-      // Write memory (vector types)
-      template <typename T>
-      void Write(PVOID Address, T const& Data, typename std::enable_if<std::
-        is_same<T, std::vector<typename T::value_type>>::value, T>::type* 
-        Dummy = 0) const;
-
-      // Whether an address is currently readable
-      bool CanRead(PVOID Address) const;
-
-      // Whether an address is currently writable
-      bool CanWrite(PVOID Address) const;
-
-      // Whether an address is contained within a guard page
-      bool  IsGuard(PVOID Address) const;
-
-      // Allocate memory
-      PVOID Alloc(SIZE_T Size) const;
-
-      // Free memory
-      void Free(PVOID Address) const;
-
-      // Get process ID of target
-      DWORD GetProcessID() const;
-
-      // Get process handle of target
-      HANDLE GetProcessHandle() const;
-
-      // Get address of export in remote process (by name)
-      FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
-        boost::filesystem::path const& Module, std::string const& Function) 
-        const;
-
-      // Get address of export in remote process (by ordinal)
-      FARPROC GetRemoteProcAddress(HMODULE RemoteMod, 
-        boost::filesystem::path const& Module, WORD Function) 
-        const;
-
-      // Flush instruction cache
-      void FlushCache(PVOID Address, SIZE_T Size) const;
-
-    private:
-      // Target process
-      Process m_Process;
-    };
-
-    // RAII class for remote memory allocation and freeing
-    class AllocAndFree : private boost::noncopyable
-    {
-    public:
-      AllocAndFree(MemoryMgr const& MyMemoryMgr, SIZE_T Size) 
-        : m_pMemory(&MyMemoryMgr), 
-        m_Address(m_pMemory->Alloc(Size)) 
-      { }
-      
-      void Free() const
-      {
-        m_pMemory->Free(m_Address);
-      }
-
-      ~AllocAndFree()
-      {
-        try
-        {
-          Free();
-        }
-        catch (MemoryMgr::Error const& /*e*/)
-        { }
-      }
-
-      PVOID GetAddress() const 
-      {
-        return m_Address;
-      }
-
-    private:
-      MemoryMgr const* m_pMemory;
-      PVOID m_Address;
-    };
-
-    // Read memory (POD types)
-    template <typename T>
-    T MemoryMgr::Read(PVOID Address, typename std::enable_if<std::is_pod<T>::
-      value, T>::type* /*Dummy*/) const 
-    {
-      // Treat attempt to read from a guard page as an error
-      if (IsGuard(Address))
-      {
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Read") << 
-          ErrorString("Attempt to read from guard page."));
-      }
-      
-      // Whether we can read the given address
-      bool const CanReadMem = CanRead(Address);
-
-      // Set page protection for reading
-      DWORD OldProtect = 0;
-      if (!CanReadMem)
-      {
-        if (!VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
-          PAGE_EXECUTE_READWRITE, &OldProtect))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Error() << 
-            ErrorFunction("MemoryMgr::Read") << 
-            ErrorString("Could not change process memory protection.") << 
-            ErrorCode(LastError));
-        }
-      }
-
-      // Read data
-      T Out = T();
-      SIZE_T BytesRead = 0;
-      if (!ReadProcessMemory(m_Process.GetHandle(), Address, &Out, sizeof(T), 
-        &BytesRead) || BytesRead != sizeof(T))
-      {
-        if (!CanReadMem)
-        {
-          // Restore original page protections
-          VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
-            OldProtect, &OldProtect);
-        }
-
-        std::error_code const LastError = GetLastErrorCode();
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Read") << 
-          ErrorString("Could not read process memory.") << 
-          ErrorCode(LastError));
-      }
-
-      // Restore original page protections
-      if (!CanReadMem)
-      {
-        if (!VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
-          OldProtect, &OldProtect))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Error() << 
-            ErrorFunction("MemoryMgr::Read") << 
-            ErrorString("Could not restore process memory protection.") << 
-            ErrorCode(LastError));
-        }
-      }
-
-      return Out;
-    }
-
-    // Read memory (string types)
-    template <typename T>
-    T MemoryMgr::Read(PVOID Address, typename std::enable_if<std::is_same<T, 
-      std::basic_string<typename T::value_type>>::value, T>::type* /*Dummy*/) 
-      const
-    {
-      // Character type
-      typedef typename T::value_type CharT;
-
-      // Create buffer to store results
-      std::basic_string<CharT> Buffer;
-
-      // Loop until a null terminator is found
-      for (CharT* AddressReal = static_cast<CharT*>(Address);; ++AddressReal)
-      {
-        // Read current character
-        CharT const Current = Read<CharT>(AddressReal);
-
-        // Return generated string on null terminator
-        if (Current == 0)
-        {
-          return Buffer;
-        }
-
-        // Add character to buffer
-        Buffer += Current;
-      }
-    }
-
-    // Read memory (vector types)
-    template <typename T>
-    T MemoryMgr::Read(PVOID Address, std::size_t Size, typename std::enable_if<
-      std::is_same<T, std::vector<typename T::value_type>>::value, T>::type* 
-      /*Dummy*/) const
-    {
-      // Ensure type to be read is POD
-      static_assert(std::is_pod<typename T::value_type>::value, 
-        "MemoryMgr::Read: Value type of vector must be POD.");
-
-      // Treat attempt to read from a guard page as an error
-      if (IsGuard(Address))
-      {
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Read") << 
-          ErrorString("Attempt to read from guard page."));
-      }
-
-      // Calculate 'raw' size of data
-      std::size_t RawSize = Size * sizeof(typename T::value_type);
-
-      // Whether we can read the given address
-      bool const CanReadMem = CanRead(Address);
-
-      // Set page protection for reading
-      DWORD OldProtect = 0;
-      if (!CanReadMem)
-      {
-        if (!VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
-          PAGE_EXECUTE_READWRITE, &OldProtect))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Error() << 
-            ErrorFunction("MemoryMgr::Read") << 
-            ErrorString("Could not change process memory protection.") << 
-            ErrorCode(LastError));
-        }
-      }
-
-      // Read data
-      T Buffer(Size);
-      SIZE_T BytesRead = 0;
-      if (!ReadProcessMemory(m_Process.GetHandle(), Address, &Buffer[0], 
-        RawSize, &BytesRead) || BytesRead != RawSize)
-      {
-        if (!CanReadMem)
-        {
-          // Restore original page protections
-          VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
-            OldProtect, &OldProtect);
-        }
-
-        std::error_code const LastError = GetLastErrorCode();
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Read") << 
-          ErrorString("Could not read process memory.") << 
-          ErrorCode(LastError));
-      }
-
-      // Restore original page protections
-      if (!CanReadMem)
-      {
-        if (!VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
-          OldProtect, &OldProtect))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Error() << 
-            ErrorFunction("MemoryMgr::Read") << 
-            ErrorString("Could not restore process memory protection.") << 
-            ErrorCode(LastError));
-        }
-      }
-
-      // Return buffer
-      return Buffer;
-    }
-
-    // Write memory (POD types)
-    template <typename T>
-    void MemoryMgr::Write(PVOID Address, T const& Data, typename std::
-      enable_if<std::is_pod<T>::value, T>::type* /*Dummy*/) const 
-    {
-      // Treat attempt to write to a guard page as an error
-      if (IsGuard(Address))
-      {
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Write") << 
-          ErrorString("Attempt to write to guard page."));
-      }
-
-      // Set page protections for writing
-      DWORD OldProtect = 0;
-      if (!VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
-        PAGE_EXECUTE_READWRITE, &OldProtect))
-      {
-        std::error_code const LastError = GetLastErrorCode();
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Write") << 
-          ErrorString("Could not change process memory protection.") << 
-          ErrorCode(LastError));
-      }
-
-      // Write data
-      SIZE_T BytesWritten = 0;
-      if (!WriteProcessMemory(m_Process.GetHandle(), Address, &Data, sizeof(T), 
-        &BytesWritten) || BytesWritten != sizeof(T))
-      {
-        // Restore original page protections
-        VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), OldProtect, 
-          &OldProtect);
-
-        std::error_code const LastError = GetLastErrorCode();
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Write") << 
-          ErrorString("Could not write process memory.") << 
-          ErrorCode(LastError));
-      }
-
-      // Restore original page protections
-      if (!VirtualProtectEx(m_Process.GetHandle(), Address, sizeof(T), 
-        OldProtect, &OldProtect))
-      {
-        std::error_code const LastError = GetLastErrorCode();
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Write") << 
-          ErrorString("Could not restore process memory protection.") << 
-          ErrorCode(LastError));
-      }
-    }
-
-    // Write memory (string types)
-    template <typename T>
-    void MemoryMgr::Write(PVOID Address, T const& Data, 
-      typename std::enable_if<std::is_same<T, std::basic_string<typename T::
-      value_type>>::value, T>::type* /*Dummy*/) const
-    {
-      // Character type
-      typedef typename T::value_type CharT;
-
-      // Convert string to vector
-      std::vector<CharT> DataReal(Data.cbegin(), Data.cend());
-      DataReal.push_back(0);
-
-      // Write string to memory
-      this->Write(Address, DataReal);
-    }
-
-    // Write memory (vector types)
-    template <typename T>
-    void MemoryMgr::Write(PVOID Address, T const& Data, typename std::
-      enable_if<std::is_same<T, std::vector<typename T::value_type>>::value, 
-      T>::type* /*Dummy*/) const
-    {
-      // Ensure type to be written is POD
-      static_assert(std::is_pod<typename T::value_type>::value, 
-        "MemoryMgr::Write: Value type of vector must be POD.");
-
-      // Treat attempt to write to a guard page as an error
-      if (IsGuard(Address))
-      {
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Write") << 
-          ErrorString("Attempt to write to guard page."));
-      }
-
-      // Calculate 'raw' size of data
-      std::size_t RawSize = Data.size() * sizeof(typename T::value_type);
-
-      // Whether we can write to the given address
-      bool const CanWriteMem = CanWrite(Address);
-
-      // Set page protection for writing
-      DWORD OldProtect = 0;
-      if (!CanWriteMem)
-      {
-        if (!VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
-          PAGE_EXECUTE_READWRITE, &OldProtect))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Error() << 
-            ErrorFunction("MemoryMgr::Write") << 
-            ErrorString("Could not change process memory protection.") << 
-            ErrorCode(LastError));
-        }
-      }
-
-      // Read data
-      SIZE_T BytesWritten = 0;
-      if (!WriteProcessMemory(m_Process.GetHandle(), Address, &Data[0], 
-        RawSize, &BytesWritten) || BytesWritten != RawSize)
-      {
-        if (!CanWriteMem)
-        {
-          // Restore original page protections
-          VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
-            OldProtect, &OldProtect);
-        }
-
-        std::error_code const LastError = GetLastErrorCode();
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("MemoryMgr::Write") << 
-          ErrorString("Could not read process memory.") << 
-          ErrorCode(LastError));
-      }
-
-      // Restore original page protections
-      if (!CanWriteMem)
-      {
-        if (!VirtualProtectEx(m_Process.GetHandle(), Address, RawSize, 
-          OldProtect, &OldProtect))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Error() << 
-            ErrorFunction("MemoryMgr::Write") << 
-            ErrorString("Could not restore process memory protection.") << 
-            ErrorCode(LastError));
-        }
-      }
-    }
-  }
-}
Index: Src/Memory/Memory/Module.hpp
===================================================================
--- Src/Memory/Memory/Module.hpp	(revision 830)
+++ Src/Memory/Memory/Module.hpp	(working copy)
@@ -1,174 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <tchar.h>
-#include <Windows.h>
-#include <TlHelp32.h>
-
-// C++ Standard Library
-#include <string>
-#include <memory>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/optional.hpp>
-#include <boost/iterator/iterator_facade.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "MemoryMgr.hpp"
-#include "Common/EnsureCleanup.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Module managing class
-    class Module
-    {
-    public:
-      // Module exception type
-      class Error : public virtual HadesMemError
-      { };
-
-      // Create module
-      Module(MemoryMgr const& MyMemory, MODULEENTRY32 const& ModuleEntry);
-
-      // Find module by handle
-      Module(MemoryMgr const& MyMemory, HMODULE Handle);
-
-      // Find module by name
-      Module(MemoryMgr const& MyMemory, 
-        std::basic_string<TCHAR> const& ModuleName);
-
-      // Get module base
-      HMODULE GetBase() const;
-      // Get module size
-      DWORD GetSize() const;
-
-      // Get module name
-      std::basic_string<TCHAR> GetName() const;
-      // Get module path
-      std::basic_string<TCHAR> GetPath() const;
-
-    private:
-      // Memory instance
-      MemoryMgr m_Memory;
-
-      // Module base address
-      HMODULE m_Base;
-      // Module size
-      DWORD m_Size;
-      // Module name
-      std::basic_string<TCHAR> m_Name;
-      // Module path
-      std::basic_string<TCHAR> m_Path;
-    };
-
-    // Module iterator
-    class ModuleListIter : public boost::iterator_facade<ModuleListIter, 
-      boost::optional<Module>, boost::incrementable_traversal_tag>, 
-      private boost::noncopyable
-    {
-    public:
-      // Constructor
-      ModuleListIter(MemoryMgr const& MyMemory) 
-        : m_Memory(MyMemory), 
-        m_Snap(), 
-        m_Current()
-      {
-        // Grab a new snapshot of the process
-        m_Snap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, m_Memory.
-          GetProcessID());
-        if (m_Snap == INVALID_HANDLE_VALUE)
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Module::Error() << 
-            ErrorFunction("ModuleEnum::First") << 
-            ErrorString("Could not get module snapshot.") << 
-            ErrorCode(LastError));
-        }
-
-        // Get first module entry
-        MODULEENTRY32 MyModuleEntry = { sizeof(MyModuleEntry) };
-        if (!Module32First(m_Snap, &MyModuleEntry))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Module::Error() << 
-            ErrorFunction("ModuleEnum::First") << 
-            ErrorString("Could not get module info.") << 
-            ErrorCode(LastError));
-        }
-
-        m_Current = Module(m_Memory, MyModuleEntry);
-      }
-
-    private:
-      // Allow Boost.Iterator access to internals
-      friend class boost::iterator_core_access;
-
-      // For Boost.Iterator
-      void increment() 
-      {
-        MODULEENTRY32 MyModuleEntry = { sizeof(MyModuleEntry) };
-        if (!Module32Next(m_Snap, &MyModuleEntry))
-        {
-          if (GetLastError() != ERROR_NO_MORE_FILES)
-          {
-            std::error_code const LastError = GetLastErrorCode();
-            BOOST_THROW_EXCEPTION(Module::Error() << 
-              ErrorFunction("ModuleEnum::Next") << 
-              ErrorString("Error enumerating module list.") << 
-              ErrorCode(LastError));
-          }
-
-          m_Current = boost::optional<Module>();
-        }
-        else
-        {
-          m_Current = Module(m_Memory, MyModuleEntry);
-        }
-      }
-
-      // For Boost.Iterator
-      boost::optional<Module>& dereference() const
-      {
-        return m_Current;
-      }
-
-      // Memory instance
-      MemoryMgr m_Memory;
-
-      // Toolhelp32 snapshot handle
-      Windows::EnsureCloseSnap m_Snap;
-
-      // Current module
-      mutable boost::optional<Module> m_Current;
-    };
-  }
-}
Index: Src/Memory/Memory/NtHeaders.hpp
===================================================================
--- Src/Memory/Memory/NtHeaders.hpp	(revision 830)
+++ Src/Memory/Memory/NtHeaders.hpp	(working copy)
@@ -1,335 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows
-#include <Windows.h>
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "PeFile.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // PE file NT headers
-    class NtHeaders
-    {
-    public:
-      // NT headers error class
-      class Error : public virtual HadesMemError
-      { };
-
-      // Data directory entries
-      enum DataDir
-      {
-        DataDir_Export, 
-        DataDir_Import, 
-        DataDir_Resource, 
-        DataDir_Exception, 
-        DataDir_Security, 
-        DataDir_BaseReloc, 
-        DataDir_Debug, 
-        DataDir_Architecture, 
-        DataDir_GlobalPTR, 
-        DataDir_TLS, 
-        DataDir_LoadConfig, 
-        DataDir_BoundImport, 
-        DataDir_IAT, 
-        DataDir_DelayImport, 
-        DataDir_COMDescriptor
-      };
-
-      // Constructor
-      explicit NtHeaders(PeFile const& MyPeFile);
-
-      // Get base of NT headers
-      PBYTE GetBase() const;
-
-      // Whether signature is valid
-      bool IsSignatureValid() const;
-
-      // Ensure signature is valid
-      void EnsureSignatureValid() const;
-
-      // Get signature
-      DWORD GetSignature() const;
-
-      // Set signature
-      void SetSignature(DWORD Signature) const;
-
-      // Get machine
-      WORD GetMachine() const;
-
-      // Set machine
-      void SetMachine(WORD Machine) const;
-
-      // Get number of sections
-      WORD GetNumberOfSections() const;
-
-      // Set number of sections
-      void SetNumberOfSections(WORD NumberOfSections) const;
-
-      // Get time date stamp
-      DWORD GetTimeDateStamp() const;
-
-      // Set time date stamp
-      void SetTimeDateStamp(DWORD TimeDateStamp) const;
-
-      // Get pointer to symbol table
-      DWORD GetPointerToSymbolTable() const;
-
-      // Set pointer to symbol table
-      void SetPointerToSymbolTable(DWORD PointerToSymbolTable) const;
-
-      // Get number of symbols
-      DWORD GetNumberOfSymbols() const;
-
-      // Set number of symbols
-      void SetNumberOfSymbols(DWORD NumberOfSymbols) const;
-
-      // Get size of optional header
-      WORD GetSizeOfOptionalHeader() const;
-
-      // Set size of optional header
-      void SetSizeOfOptionalHeader(WORD SizeOfOptionalHeader) const;
-
-      // Get characteristics
-      WORD GetCharacteristics() const;
-
-      // Set characteristics
-      void SetCharacteristics(WORD Characteristics) const;
-
-      // Get magic
-      WORD GetMagic() const;
-
-      // Set magic
-      void SetMagic(WORD Magic) const;
-
-      // Get major linker version
-      BYTE GetMajorLinkerVersion() const;
-
-      // Set major linker version
-      void SetMajorLinkerVersion(BYTE MajorLinkerVersion) const;
-
-      // Get minor linker version
-      BYTE GetMinorLinkerVersion() const;
-
-      // Set major linker version
-      void SetMinorLinkerVersion(BYTE MinorLinkerVersion) const;
-
-      // Get minor linker version
-      DWORD GetSizeOfCode() const;
-
-      // Set major linker version
-      void SetSizeOfCode(DWORD SizeOfCode) const;
-
-      // Get minor linker version
-      DWORD GetSizeOfInitializedData() const;
-
-      // Set major linker version
-      void SetSizeOfInitializedData(DWORD SizeOfInitializedData) const;
-
-      // Get minor linker version
-      DWORD GetSizeOfUninitializedData() const;
-
-      // Set major linker version
-      void SetSizeOfUninitializedData(DWORD SizeOfUninitializedData) const;
-
-      // Get minor linker version
-      DWORD GetAddressOfEntryPoint() const;
-
-      // Set major linker version
-      void SetAddressOfEntryPoint(DWORD AddressOfEntryPoint) const;
-
-      // Get base of code
-      DWORD GetBaseOfCode() const;
-
-      // Set base of code
-      void SetBaseOfCode(DWORD BaseOfCode) const;
-
-#if defined(_M_IX86) 
-      // Get base of data
-      DWORD GetBaseOfData() const;
-
-      // Set base of data
-      void SetBaseOfData(DWORD BaseOfData) const;
-#endif
-
-      // Get base of code
-      ULONG_PTR GetImageBase() const;
-
-      // Set base of code
-      void SetImageBase(ULONG_PTR ImageBase) const;
-
-      // Get base of code
-      DWORD GetSectionAlignment() const;
-
-      // Set base of code
-      void SetSectionAlignment(DWORD SectionAlignment) const;
-
-      // Get base of code
-      DWORD GetFileAlignment() const;
-
-      // Set base of code
-      void SetFileAlignment(DWORD FileAlignment) const;
-
-      // Get base of code
-      WORD GetMajorOperatingSystemVersion() const;
-
-      // Set base of code
-      void SetMajorOperatingSystemVersion(
-        WORD MajorOperatingSystemVersion) const;
-
-      // Get base of code
-      WORD GetMinorOperatingSystemVersion() const;
-
-      // Set base of code
-      void SetMinorOperatingSystemVersion(
-        WORD MinorOperatingSystemVersion) const;
-
-      // Get base of code
-      WORD GetMajorImageVersion() const;
-
-      // Set base of code
-      void SetMajorImageVersion(WORD MajorImageVersion) const;
-
-      // Get base of code
-      WORD GetMinorImageVersion() const;
-
-      // Set base of code
-      void SetMinorImageVersion(WORD MinorImageVersion) const;
-
-      // Get base of code
-      WORD GetMajorSubsystemVersion() const;
-
-      // Set base of code
-      void SetMajorSubsystemVersion(WORD MajorSubsystemVersion) const;
-
-      // Get base of code
-      WORD GetMinorSubsystemVersion() const;
-
-      // Set base of code
-      void SetMinorSubsystemVersion(WORD MinorSubsystemVersion) const;
-
-      // Get base of code
-      DWORD GetWin32VersionValue() const;
-
-      // Set base of code
-      void SetWin32VersionValue(DWORD Win32VersionValue) const;
-
-      // Get size of image
-      DWORD GetSizeOfImage() const;
-      
-      // Set size of image
-      void SetSizeOfImage(DWORD SizeOfImage) const;
-
-      // Get base of code
-      DWORD GetSizeOfHeaders() const;
-
-      // Set base of code
-      void SetSizeOfHeaders(DWORD SizeOfHeaders) const;
-
-      // Get base of code
-      DWORD GetCheckSum() const;
-
-      // Set base of code
-      void SetCheckSum(DWORD CheckSum) const;
-
-      // Get base of code
-      WORD GetSubsystem() const;
-
-      // Set base of code
-      void SetSubsystem(WORD Subsystem) const;
-
-      // Get base of code
-      WORD GetDllCharacteristics() const;
-
-      // Set base of code
-      void SetDllCharacteristics(WORD DllCharacteristics) const;
-
-      // Get base of code
-      ULONG_PTR GetSizeOfStackReserve() const;
-
-      // Set base of code
-      void SetSizeOfStackReserve(ULONG_PTR SizeOfStackReserve) const;
-
-      // Get base of code
-      ULONG_PTR GetSizeOfStackCommit() const;
-
-      // Set base of code
-      void SetSizeOfStackCommit(ULONG_PTR SizeOfStackCommit) const;
-
-      // Get base of code
-      ULONG_PTR GetSizeOfHeapReserve() const;
-
-      // Set base of code
-      void SetSizeOfHeapReserve(ULONG_PTR SizeOfHeapReserve) const;
-
-      // Get base of code
-      ULONG_PTR GetSizeOfHeapCommit() const;
-
-      // Set base of code
-      void SetSizeOfHeapCommit(ULONG_PTR SizeOfHeapCommit) const;
-
-      // Get base of code
-      DWORD GetLoaderFlags() const;
-
-      // Set base of code
-      void SetLoaderFlags(DWORD LoaderFlags) const;
-
-      // Get base of code
-      DWORD GetNumberOfRvaAndSizes() const;
-
-      // Set base of code
-      void SetNumberOfRvaAndSizes(DWORD NumberOfRvaAndSizes) const;
-
-      // Get base of code
-      DWORD GetDataDirectoryVirtualAddress(DataDir MyDataDir) const;
-
-      // Set base of code
-      void SetDataDirectoryVirtualAddress(DataDir MyDataDir, 
-        DWORD DataDirectoryVirtualAddress) const;
-
-      // Get base of code
-      DWORD GetDataDirectorySize(DataDir MyDataDir) const;
-
-      // Set base of code
-      void SetDataDirectorySize(DataDir MyDataDir, 
-        DWORD DataDirectorySize) const;
-
-      // Get raw NT headers
-      IMAGE_NT_HEADERS GetHeadersRaw() const;
-
-    private:
-      // PE file
-      PeFile m_PeFile;
-
-      // Memory instance
-      MemoryMgr m_Memory;
-
-      // Base address
-      mutable PBYTE m_pBase;
-    };
-  }
-}
Index: Src/Memory/Memory/Patcher.hpp
===================================================================
--- Src/Memory/Memory/Patcher.hpp	(revision 830)
+++ Src/Memory/Memory/Patcher.hpp	(working copy)
@@ -1,128 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <Windows.h>
-
-// C++ Standard Library
-#include <vector>
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Patch class.
-    // Abstract base class for different patch types.
-    class Patch
-    {
-    public:
-      // Patch exception type
-      class Error : public virtual HadesMemError
-      { };
-
-      // Constructor
-      explicit Patch(MemoryMgr const& MyMemory);
-
-      // Destructor
-      virtual ~Patch();
-
-      // Apply patch
-      virtual void Apply() = 0;
-      // Remove patch
-      virtual void Remove() = 0;
-
-      // Whether patch is currently applied
-      bool IsApplied() const;
-
-    protected:
-      // Memory manager instance
-      MemoryMgr m_Memory;
-
-      // Whether patch is currently applied
-      bool m_Applied;
-    };
-
-    // Raw patch (a.k.a. 'byte patch').
-    // Used to perform a simple byte patch on a target.
-    class PatchRaw : public Patch
-    {
-    public:
-      // Constructor
-      PatchRaw(MemoryMgr const& MyMemory, PVOID Target, 
-        std::vector<BYTE> const& Data);
-
-      // Apply patch
-      virtual void Apply();
-
-      // Remove patch
-      virtual void Remove();
-
-    private:
-      // Patch target
-      PVOID m_Target;
-
-      // New data
-      std::vector<BYTE> m_Data;
-
-      // Original data
-      std::vector<BYTE> m_Orig;
-    };
-
-    // Detour patch (a.k.a. 'hook').
-    // Performs an 'inline' or 'jump' hook on the target.
-    class PatchDetour : public Patch
-    {
-    public:
-      // Constructor
-      PatchDetour(MemoryMgr const& MyMemory, PVOID Target, PVOID Detour);
-
-      // Apply patch
-      virtual void Apply();
-      
-      // Remove patch
-      virtual void Remove();
-
-      // Get pointer to trampoline
-      PVOID GetTrampoline() const;
-
-    private:
-      // Write jump to target at address
-      void WriteJump(PVOID Address, PVOID Target);
-
-      // Get size of jump instruction for current platform
-      unsigned int GetJumpSize() const;
-
-      // Target address
-      PVOID m_Target;
-      // Detour address
-      PVOID m_Detour;
-      // Trampoline address
-      PVOID m_Trampoline;
-      // Backup code
-      std::vector<BYTE> m_Orig;
-    };
-  }
-}
Index: Src/Memory/Memory/PEFile.hpp
===================================================================
--- Src/Memory/Memory/PEFile.hpp	(revision 830)
+++ Src/Memory/Memory/PEFile.hpp	(working copy)
@@ -1,75 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows
-#include <Windows.h>
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // PE file format wrapper
-    class PeFile
-    {
-    public:
-      // PeFile exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      enum FileType
-      {
-        FileType_Image, 
-        FileType_Data
-      };
-
-      // Constructor
-      PeFile(MemoryMgr const& MyMemory, PVOID Address, 
-        FileType Type = FileType_Image);
-
-      // Get memory manager
-      MemoryMgr GetMemoryMgr() const;
-
-      // Get base address
-      PBYTE GetBase() const;
-
-      // Convert RVA to VA
-      PVOID RvaToVa(DWORD Rva) const;
-
-      // Get file type
-      FileType GetType() const;
-
-    protected:
-      // Memory instance
-      MemoryMgr m_Memory;
-
-      // Base address
-      PBYTE m_pBase;
-
-      // File type
-      FileType m_Type;
-    };
-  }
-}
Index: Src/Memory/Memory/PeLib.hpp
===================================================================
--- Src/Memory/Memory/PeLib.hpp	(revision 830)
+++ Src/Memory/Memory/PeLib.hpp	(working copy)
@@ -1,33 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Hades (PeLib)
-#include "PeFile.hpp"
-#include "TlsDir.hpp"
-#include "Section.hpp"
-#include "ImportDir.hpp"
-#include "ExportDir.hpp"
-#include "DosHeader.hpp"
-#include "ExportDir.hpp"
-#include "NtHeaders.hpp"
-#include "ImportEnum.hpp"
-#include "ExportEnum.hpp"
-#include "SectionEnum.hpp"
Index: Src/Memory/Memory/Process.hpp
===================================================================
--- Src/Memory/Memory/Process.hpp	(revision 830)
+++ Src/Memory/Memory/Process.hpp	(working copy)
@@ -1,278 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <tchar.h>
-#include <Windows.h>
-#include <TlHelp32.h>
-
-// C++ Standard Library
-#include <string>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/optional.hpp>
-#include <boost/filesystem.hpp>
-#include <boost/iterator/iterator_facade.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "Common/EnsureCleanup.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Process managing class
-    class Process
-    {
-    public:
-      // Process exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      // Open process from process ID
-      explicit Process(DWORD ProcID);
-
-      // Open process from process name
-      explicit Process(std::basic_string<TCHAR> const& ProcName);
-
-      // Open process from window name and class
-      Process(std::basic_string<TCHAR> const& WindowName, 
-        std::basic_string<TCHAR> const& ClassName);
-
-      // Copy constructor
-      Process(Process const& MyProcess);
-
-      // Copy assignment
-      Process& operator=(Process const& MyProcess);
-
-      // Move constructor
-      Process(Process&& MyProcess);
-
-      // Move assignment
-      Process& operator=(Process&& MyProcess);
-
-      // Get process handle
-      HANDLE GetHandle() const;
-      
-      // Get process ID
-      DWORD GetID() const;
-      
-      // Get process path
-      boost::filesystem::path GetPath() const;
-
-    private:
-      // Open process given process id
-      void Open(DWORD ProcID);
-
-      // Gets the SeDebugPrivilege
-      void GetSeDebugPrivilege();
-
-      // Process handle
-      Windows::EnsureCloseHandle m_Handle;
-
-      // Process ID
-      DWORD m_ID;
-    };
-    
-    // Create process
-    Process CreateProcess(boost::filesystem::path const& Path, 
-      boost::filesystem::path const& Params, 
-      boost::filesystem::path const& WorkingDir);
-
-    // Process iterator
-    // Fixme: Implement in a more rhobust manner. Currently just 'skips' 
-    // processes if something goes wrong...
-    class ProcessIter : public boost::iterator_facade<ProcessIter, 
-      boost::optional<Process>, boost::incrementable_traversal_tag>, 
-      private boost::noncopyable
-    {
-    public:
-      // Constructor
-      ProcessIter() 
-        : m_Snap(), 
-        m_Current()
-      {
-        // Grab a new snapshot of the process
-        m_Snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
-        if (m_Snap == INVALID_HANDLE_VALUE)
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Process::Error() << 
-            ErrorFunction("ProcessIter::First") << 
-            ErrorString("Could not get process snapshot.") << 
-            ErrorCode(LastError));
-        }
-
-        // Get first module entry
-        PROCESSENTRY32 ProcEntry = { sizeof(ProcEntry) };
-        if (!Process32First(m_Snap, &ProcEntry))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Process::Error() << 
-            ErrorFunction("ProcessIter::First") << 
-            ErrorString("Error enumerating process list.") << 
-            ErrorCode(LastError));
-        }
-        
-        // Get WoW64 status of self
-        BOOL IsWoW64Me = FALSE;
-        if (!IsWow64Process(GetCurrentProcess(), &IsWoW64Me))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Process::Error() << 
-            ErrorFunction("ProcessIter::First") << 
-            ErrorString("Could not detect WoW64 status of current process.") << 
-            ErrorCode(LastError));
-        }
-        
-        // Get handle to target
-        // Using more access flags than is strictly necessar, but if I don't 
-        // it will simply fail further down the chain
-        Windows::EnsureCloseHandle TargetProc(OpenProcess(PROCESS_CREATE_THREAD | 
-          PROCESS_QUERY_INFORMATION | 
-          PROCESS_VM_OPERATION | 
-          PROCESS_VM_READ | 
-          PROCESS_VM_WRITE, 
-          FALSE, ProcEntry.th32ProcessID));
-        if (!TargetProc)
-        {
-          increment();
-          return;
-        }
-  
-        // Get WoW64 status of target process
-        BOOL IsWoW64 = FALSE;
-        if (!IsWow64Process(TargetProc, &IsWoW64))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Process::Error() << 
-            ErrorFunction("ProcessIter::First") << 
-            ErrorString("Could not detect WoW64 status of target process.") << 
-            ErrorCode(LastError));
-        }
-  
-        // Ensure WoW64 status of both self and target match
-        if (IsWoW64Me != IsWoW64)
-        {
-          increment();
-        }
-        else
-        {
-          m_Current = Process(ProcEntry.th32ProcessID);
-        }
-      }
-
-    private:
-      // Allow Boost.Iterator access to internals
-      friend class boost::iterator_core_access;
-
-      // For Boost.Iterator
-      void increment() 
-      {
-        PROCESSENTRY32 ProcEntry = { sizeof(ProcEntry) };
-        if (!Process32Next(m_Snap, &ProcEntry))
-        {
-          if (GetLastError() != ERROR_NO_MORE_FILES)
-          {
-            std::error_code const LastError = GetLastErrorCode();
-            BOOST_THROW_EXCEPTION(Process::Error() << 
-              ErrorFunction("ProcessIter::Next") << 
-              ErrorString("Error enumerating process list.") << 
-              ErrorCode(LastError));
-          }
-
-          m_Current = boost::optional<Process>();
-        }
-        else
-        {
-          // Get WoW64 status of self
-          BOOL IsWoW64Me = FALSE;
-          if (!IsWow64Process(GetCurrentProcess(), &IsWoW64Me))
-          {
-            std::error_code const LastError = GetLastErrorCode();
-            BOOST_THROW_EXCEPTION(Process::Error() << 
-              ErrorFunction("ProcessIter::Next") << 
-              ErrorString("Could not detect WoW64 status of current "
-                "process.") << 
-              ErrorCode(LastError));
-          }
-        
-          // Get handle to target
-          // Using more access flags than is strictly necessar, but if I don't 
-          // it will simply fail further down the chain
-          Windows::EnsureCloseHandle TargetProc(OpenProcess(PROCESS_CREATE_THREAD | 
-            PROCESS_QUERY_INFORMATION | 
-            PROCESS_VM_OPERATION | 
-            PROCESS_VM_READ | 
-            PROCESS_VM_WRITE, 
-            FALSE, ProcEntry.th32ProcessID));
-          if (!TargetProc)
-          {
-            increment();
-            return;
-          }
-    
-          // Get WoW64 status of target process
-          BOOL IsWoW64 = FALSE;
-          if (!IsWow64Process(TargetProc, &IsWoW64))
-          {
-            std::error_code const LastError = GetLastErrorCode();
-            BOOST_THROW_EXCEPTION(Process::Error() << 
-              ErrorFunction("ProcessIter::Next") << 
-              ErrorString("Could not detect WoW64 status of target "
-                "process.") << 
-              ErrorCode(LastError));
-          }
-  
-          // Ensure WoW64 status of both self and target match
-          if (IsWoW64Me != IsWoW64)
-          {
-            increment();
-          }
-          else
-          {
-            m_Current = Process(ProcEntry.th32ProcessID);
-          }
-        }
-      }
-
-      // For Boost.Iterator
-      boost::optional<Process>& dereference() const
-      {
-        return m_Current;
-      }
-
-      // Toolhelp32 snapshot handle
-      Windows::EnsureCloseSnap m_Snap;
-
-      // Current module
-      mutable boost::optional<Process> m_Current;
-    };
-  }
-}
Index: Src/Memory/Memory/Region.hpp
===================================================================
--- Src/Memory/Memory/Region.hpp	(revision 830)
+++ Src/Memory/Memory/Region.hpp	(working copy)
@@ -1,164 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <Windows.h>
-
-// C++ Standard Library
-#include <memory>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/optional.hpp>
-#include <boost/iterator/iterator_facade.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Memory region managing class
-    class Region
-    {
-    public:
-      // MemRegion exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      // Constructor
-      Region(MemoryMgr const& MyMemory, PVOID Address);
-
-      // Constructor
-      Region(MemoryMgr const& MyMemory, MEMORY_BASIC_INFORMATION const& MyMbi);
-
-      // Get base address
-      PVOID GetBase() const;
-      
-      // Get allocation base
-      PVOID GetAllocBase() const;
-      
-      // Get allocation protection
-      DWORD GetAllocProtect() const;
-      
-      // Get size
-      SIZE_T GetSize() const;
-      
-      // Get state
-      DWORD GetState() const;
-      
-      // Get protection
-      DWORD GetProtect() const;
-      
-      // Get type
-      DWORD GetType() const;
-
-    private:
-      // MemoryMgr instance
-      MemoryMgr m_Memory;
-
-      // Region information
-      MEMORY_BASIC_INFORMATION m_RegionInfo;
-    };
-
-    // Region iterator
-    class RegionListIter : public boost::iterator_facade<RegionListIter, 
-      boost::optional<Region>, boost::incrementable_traversal_tag>
-    {
-    public:
-      // Constructor
-      RegionListIter(MemoryMgr const& MyMemory) 
-        : m_Memory(MyMemory), 
-        m_BaseAddress(nullptr), 
-        m_RegionSize(0), 
-        m_Current()
-      {
-        MEMORY_BASIC_INFORMATION MyMbi = { 0 };
-        if (!VirtualQueryEx(m_Memory.GetProcessHandle(), m_BaseAddress, &MyMbi, 
-          sizeof(MyMbi)))
-        {
-          std::error_code const LastError = GetLastErrorCode();
-          BOOST_THROW_EXCEPTION(Region::Error() << 
-            ErrorFunction("RegionEnum::First") << 
-            ErrorString("Could not get first memory region.") << 
-            ErrorCode(LastError));
-        }
-
-        m_BaseAddress = MyMbi.BaseAddress;
-        m_RegionSize = MyMbi.RegionSize;
-
-        m_Current = Region(m_Memory, MyMbi);
-      }
-
-    private:
-      // Allow Boost.Iterator access to internals
-      friend class boost::iterator_core_access;
-
-      // For Boost.Iterator
-      void increment() 
-      {
-        // Advance to next region
-        m_BaseAddress = static_cast<PBYTE>(m_BaseAddress) + m_RegionSize;
-
-        // Get region info
-        MEMORY_BASIC_INFORMATION MyMbi = { 0 };
-        if (VirtualQueryEx(m_Memory.GetProcessHandle(), m_BaseAddress, &MyMbi, 
-          sizeof(MyMbi)))
-        {
-          m_BaseAddress = MyMbi.BaseAddress;
-          m_RegionSize = MyMbi.RegionSize;
-
-          m_Current = Region(m_Memory, MyMbi);
-        }
-        else
-        {
-          m_Current = boost::optional<Region>();
-        }
-      }
-
-      // For Boost.Iterator
-      boost::optional<Region>& dereference() const
-      {
-        return m_Current;
-      }
-
-      // Memory instance
-      MemoryMgr m_Memory;
-
-      // Current address
-      PVOID m_BaseAddress;
-
-      // Current region size
-      SIZE_T m_RegionSize;
-
-      // Current region
-      mutable boost::optional<Region> m_Current;
-    };
-  }
-}
Index: Src/Memory/Memory/Scanner.hpp
===================================================================
--- Src/Memory/Memory/Scanner.hpp	(revision 830)
+++ Src/Memory/Memory/Scanner.hpp	(working copy)
@@ -1,286 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <tchar.h>
-#include <Windows.h>
-
-// C++ Standard Library
-#include <map>
-#include <string>
-#include <vector>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/filesystem.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Hades
-#include "Region.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Memory searching class
-    class Scanner
-    {
-    public:
-      // Scanner exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      // Constructor
-      Scanner(MemoryMgr const& MyMemory, PVOID Start, PVOID End);
-
-      // Search memory (POD types)
-      template <typename T>
-      PVOID Find(T const& Data, typename std::enable_if<std::is_pod<T>::value, 
-        T>::type* Dummy = 0) const;
-
-      // Search memory (string types)
-      template <typename T>
-      PVOID Find(T const& Data, typename std::enable_if<std::is_same<T, std::
-        basic_string<typename T::value_type>>::value, T>::type* Dummy = 0) 
-        const;
-
-      // Search memory (vector types)
-      template <typename T>
-      PVOID Find(T const& Data, typename std::enable_if<std::is_same<T, 
-        std::vector<typename T::value_type>>::value, T>::type* Dummy1 = 0) 
-        const;
-
-      // Search memory (POD types)
-      template <typename T>
-      std::vector<PVOID> FindAll(T const& data, typename std::enable_if<std::
-        is_pod<T>::value, T>::type* Dummy = 0) const;
-
-      // Search memory (string types)
-      template <typename T>
-      std::vector<PVOID> FindAll(T const& Data, typename std::enable_if<std::
-        is_same<T, std::basic_string<typename T::value_type>>::value, 
-        T>::type* Dummy = 0) const;
-
-      // Search memory (vector types)
-      template <typename T>
-      std::vector<PVOID> FindAll(T const& Data, typename std::enable_if<std::
-        is_same<T, std::vector<typename T::value_type>>::value, 
-        T>::type* Dummy1 = 0) const;
-
-    private:
-      // Memory manager instance
-      MemoryMgr m_Memory;
-
-      // Start and end addresses of search region
-      PBYTE m_Start;
-      PBYTE m_End;
-    };
-
-    // Search memory (POD types)
-    template <typename T>
-    PVOID Scanner::Find(T const& Data, typename std::enable_if<std::is_pod<
-      T>::value, T>:: type* /*Dummy*/) const
-    {
-      // Put data in container
-      std::vector<T> Buffer;
-      Buffer.push_back(Data);
-      // Use vector specialization of Find
-      return Find(Buffer);
-    }
-
-    // Search memory (string types)
-    template <typename T>
-    PVOID Scanner::Find(T const& Data, typename std::enable_if<std::is_same<
-      T, std::basic_string<typename T::value_type>>::value, 
-      T>::type* /*Dummy*/) const
-    {
-      // Convert string to character buffer
-      std::vector<typename T::value_type> const MyBuffer(Data.cbegin(), 
-        Data.cend());
-      // Use vector specialization of Find
-      return Find(MyBuffer);
-    }
-
-    // Search memory (vector types)
-    template <typename T>
-    PVOID Scanner::Find(T const& Data, typename std::enable_if<std::is_same<
-      T, std::vector<typename T::value_type>>::value, 
-      T>::type* /*Dummy1*/) const
-    {
-      static_assert(std::is_pod<typename T::value_type>::value, 
-        "Scanner::Find: Value type of vector must be POD.");
-
-      if (Data.empty())
-      {
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("Scanner::Find") << 
-          ErrorString("Data container is empty."));
-      }
-
-      LPCBYTE pDataRaw = reinterpret_cast<LPCBYTE>(&Data[0]);
-      std::size_t const DataRawSize = Data.size() * sizeof(
-        typename T::value_type);
-
-      std::vector<BYTE> DataRaw(pDataRaw, pDataRaw + DataRawSize);
-
-      for (RegionListIter i(m_Memory); *i; ++i)
-      {
-        Hades::Memory::Region const& MyRegion = **i;
-
-        if (static_cast<PBYTE>(MyRegion.GetBase()) + MyRegion.GetSize() < 
-          m_Start)
-        {
-          continue;
-        }
-
-        if (MyRegion.GetBase() > m_End)
-        {
-          break;
-        }
-
-        std::vector<BYTE> Buffer;
-
-        try
-        {
-          Buffer = m_Memory.Read<std::vector<BYTE>>(MyRegion.GetBase(), 
-            MyRegion.GetSize());
-        }
-        catch (MemoryMgr::Error const& /*e*/)
-        {
-          continue;
-        }
-
-        auto Iter = std::search(Buffer.cbegin(), Buffer.cend(), 
-          DataRaw.cbegin(), DataRaw.cend());
-        if (Iter != Buffer.cend())
-        {
-          PVOID AddressReal = static_cast<PBYTE>(MyRegion.GetBase()) + 
-            std::distance(Buffer.cbegin(), Iter);
-          if (AddressReal >= m_Start && AddressReal <= m_End)
-          {
-            return AddressReal;
-          }
-        }
-      }
-
-      return nullptr;
-    }
-
-    // Search memory (POD types)
-    template <typename T>
-    std::vector<PVOID> Scanner::FindAll(T const& Data, typename std::
-      enable_if<std::is_pod<T>::value, T>::type* /*Dummy*/) const
-    {
-      // Put data in container
-      std::vector<T> Buffer;
-      Buffer.push_back(Data);
-      // Use vector specialization of FindAll
-      return FindAll(Buffer);
-    }
-
-    template <typename T>
-    std::vector<PVOID> Scanner::FindAll(T const& Data, typename std::
-      enable_if<std::is_same<T, std::basic_string<typename T::value_type>>::
-      value, T>::type* /*Dummy*/) const
-    {
-      // Convert string to character buffer
-      std::vector<typename T::value_type> const MyBuffer(Data.cbegin(), 
-        Data.cend());
-      // Use vector specialization of find all
-      return FindAll(MyBuffer);
-    }
-
-    // Search memory (vector types)
-    // Fixme: This function is extremely inefficient and full of potential 
-    // bugs. Perform a thorough review and rewrite.
-    // Fixme: Refactor Find and FindAll to factor out duplicated code.
-    template <typename T>
-    std::vector<PVOID> Scanner::FindAll(T const& Data, typename std::
-      enable_if<std::is_same<T, std::vector<typename T::value_type>>::
-      value, T>::type* /*Dummy1*/) const
-    {
-      static_assert(std::is_pod<typename T::value_type>::value, 
-        "Scanner::Find: Value type of vector must be POD.");
-
-      if (Data.empty())
-      {
-        BOOST_THROW_EXCEPTION(Error() << 
-          ErrorFunction("Scanner::Find") << 
-          ErrorString("Data container is empty."));
-      }
-
-      LPCBYTE pDataRaw = reinterpret_cast<LPCBYTE>(&Data[0]);
-      std::size_t const DataRawSize = Data.size() * sizeof(
-        typename T::value_type);
-
-      std::vector<BYTE> DataRaw(pDataRaw, pDataRaw + DataRawSize);
-
-      std::vector<PVOID> Matches;
-
-      for (RegionListIter i(m_Memory); *i; ++i)
-      {
-        Hades::Memory::Region const& MyRegion = **i;
-
-        if (static_cast<PBYTE>(MyRegion.GetBase()) + MyRegion.GetSize() < 
-          m_Start)
-        {
-          continue;
-        }
-
-        if (MyRegion.GetBase() > m_End)
-        {
-          break;
-        }
-
-        std::vector<BYTE> Buffer;
-
-        try
-        {
-          Buffer = m_Memory.Read<std::vector<BYTE>>(MyRegion.GetBase(), 
-            MyRegion.GetSize());
-        }
-        catch (MemoryMgr::Error const& /*e*/)
-        {
-          continue;
-        }
-
-        auto Iter = std::search(Buffer.cbegin(), Buffer.cend(), 
-          DataRaw.cbegin(), DataRaw.cend());
-        if (Iter != Buffer.cend())
-        {
-          PVOID AddressReal = static_cast<PBYTE>(MyRegion.GetBase()) + 
-            std::distance(Buffer.cbegin(), Iter);
-          if (AddressReal >= m_Start && AddressReal <= m_End)
-          {
-            Matches.push_back(AddressReal);
-          }
-        }
-      }
-
-      return Matches;
-    }
-  }
-}
Index: Src/Memory/Memory/Section.hpp
===================================================================
--- Src/Memory/Memory/Section.hpp	(revision 830)
+++ Src/Memory/Memory/Section.hpp	(working copy)
@@ -1,96 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows
-#include <Windows.h>
-
-// C++ Standard Library
-#include <string>
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "PeFile.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // PE file section
-    class Section
-    {
-    public:
-      // Section error class
-      class Error : public virtual HadesMemError
-      { };
-
-      // Constructor
-      Section(PeFile const& MyPeFile, WORD Number);
-
-      // Get name
-      std::string GetName() const;
-
-      // Get virtual address
-      DWORD GetVirtualAddress() const;
-
-      // Get virtual size
-      DWORD GetVirtualSize() const;
-
-      // Get size of raw data
-      DWORD GetSizeOfRawData() const;
-
-      // Get pointer to raw data
-      DWORD GetPointerToRawData() const;
-
-      // Get pointer to relocations
-      DWORD GetPointerToRelocations() const;
-
-      // Get pointer to line numbers
-      DWORD GetPointerToLinenumbers() const;
-
-      // Get number of relocations
-      WORD GetNumberOfRelocations() const;
-
-      // Get number of line numbers
-      WORD GetNumberOfLinenumbers() const;
-
-      // Get characteristics
-      DWORD GetCharacteristics() const;
-
-      // Get section header base
-      PBYTE GetBase() const;
-
-      // Get raw section header
-      IMAGE_SECTION_HEADER GetSectionHeaderRaw() const;
-
-    private:
-      // PE file
-      PeFile m_PeFile;
-
-      // Memory instance
-      MemoryMgr m_Memory;
-
-      // Section number
-      WORD m_SectionNum;
-    };
-  }
-}
Index: Src/Memory/Memory/SectionEnum.hpp
===================================================================
--- Src/Memory/Memory/SectionEnum.hpp	(revision 830)
+++ Src/Memory/Memory/SectionEnum.hpp	(working copy)
@@ -1,102 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// C++ Standard Library
-#include <memory>
-
-// Boost
-#ifdef _MSC_VER
-#pragma warning(push, 1)
-#endif // #ifdef _MSC_VER
-#include <boost/optional.hpp>
-#include <boost/iterator/iterator_facade.hpp>
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif // #ifdef _MSC_VER
-
-// Windows API
-#include <Windows.h>
-
-// Hades
-#include "PeFile.hpp"
-#include "Section.hpp"
-#include "NtHeaders.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Section iterator
-    class SectionIter : public boost::iterator_facade<SectionIter, 
-      boost::optional<Section>, boost::incrementable_traversal_tag>
-    {
-    public:
-      // Constructor
-      explicit SectionIter(PeFile const& MyPeFile) 
-        : m_PeFile(MyPeFile), 
-        m_CurrentNum(0), 
-        m_Current()
-      {
-        NtHeaders const MyNtHeaders(m_PeFile);
-        WORD NumberOfSections = MyNtHeaders.GetNumberOfSections();
-        if (NumberOfSections)
-        {
-          m_Current = Section(m_PeFile, m_CurrentNum);
-        }
-      }
-
-    private:
-      // Allow Boost.Iterator access to internals
-      friend class boost::iterator_core_access;
-
-      // For Boost.Iterator
-      void increment() 
-      {
-        NtHeaders const MyNtHeaders(m_PeFile);
-        WORD const NumberOfSections = MyNtHeaders.GetNumberOfSections();
-
-        if (++m_CurrentNum < NumberOfSections)
-        {
-          m_Current = Section(m_PeFile, m_CurrentNum);
-        }
-        else
-        {
-          m_Current = boost::optional<Section>();
-        }
-      }
-
-      // For Boost.Iterator
-      boost::optional<Section>& dereference() const
-      {
-        return m_Current;
-      }
-
-      // Memory instance
-      PeFile m_PeFile;
-
-      // Current section number
-      WORD m_CurrentNum;
-
-      // Current section
-      mutable boost::optional<Section> m_Current;
-    };
-  }
-}
Index: Src/Memory/Memory/Symbol.hpp
===================================================================
--- Src/Memory/Memory/Symbol.hpp	(revision 830)
+++ Src/Memory/Memory/Symbol.hpp	(working copy)
@@ -1,75 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows API
-#include <Windows.h>
-#ifdef UNICODE
-#define DBGHELP_TRANSLATE_TCHAR
-#endif
-#include <DbgHelp.h>
-
-// C++ Standard Library
-#include <string>
-
-// Boost
-#include <boost/filesystem.hpp>
-#include <boost/noncopyable.hpp>
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "MemoryMgr.hpp"
-
-// Note: Symbol APIs provided by DbgHelp are NOT thread-safe. 
-// Todo: Implement optional synchronization.
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // Symbol handler
-    // Note: Thanks to _Mike on MMOwned for the idea and initial PoC base
-    class Symbols : private boost::noncopyable
-    {
-    public:
-      // Symbols exception type
-      class Error : public virtual HadesMemError 
-      { };
-
-      // Constructor
-      explicit Symbols(MemoryMgr const& MyMemory, 
-        boost::filesystem::path const& SearchPath = boost::filesystem::path());
-        
-      // Destructor
-      ~Symbols();
-      
-      // Load symbols for module
-      void LoadForModule(std::basic_string<TCHAR> const& ModuleName);
-      
-      // Get address for symbol
-      PVOID GetAddress(std::basic_string<TCHAR> const& Name);
-        
-    private:
-      // Memory instance
-      MemoryMgr m_Memory;
-    };
-  }
-}
Index: Src/Memory/Memory/TlsDir.hpp
===================================================================
--- Src/Memory/Memory/TlsDir.hpp	(revision 830)
+++ Src/Memory/Memory/TlsDir.hpp	(working copy)
@@ -1,90 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// Windows
-#include <Windows.h>
-
-// C++ Standard Library
-#include <vector>
-
-// Hades
-#include "Fwd.hpp"
-#include "Error.hpp"
-#include "PeFile.hpp"
-#include "MemoryMgr.hpp"
-
-namespace Hades
-{
-  namespace Memory
-  {
-    // PE file TLS directory
-    class TlsDir
-    {
-    public:
-      // TlsDir error class
-      class Error : public virtual HadesMemError
-      { };
-
-      // Constructor
-      explicit TlsDir(PeFile const& MyPeFile);
-
-      // Whether TLS directory is valid
-      bool IsValid() const;
-
-      // Ensure TLS directory is valid
-      void EnsureValid() const;
-
-      // Get start address of raw data
-      DWORD_PTR GetStartAddressOfRawData() const;
-
-      // Get end address of raw data
-      DWORD_PTR GetEndAddressOfRawData() const;
-
-      // Get address of index
-      DWORD_PTR GetAddressOfIndex() const;
-
-      // Get address of callbacks
-      DWORD_PTR GetAddressOfCallBacks() const;
-
-      // Get size of zero fill
-      DWORD GetSizeOfZeroFill() const;
-
-      // Get characteristics
-      DWORD GetCharacteristics() const;
-
-      // Get list of TLS callbacks
-      std::vector<PIMAGE_TLS_CALLBACK> GetCallbacks() const;
-
-      // Get base of TLS dir
-      PBYTE GetBase() const;
-
-      // Get raw TLS dir
-      IMAGE_TLS_DIRECTORY GetTlsDirRaw() const;
-
-    private:
-      // PE file
-      PeFile m_PeFile;
-
-      // Memory instance
-      MemoryMgr m_Memory;
-    };
-  }
-}
Index: Src/Memory/Memory/Types.hpp
===================================================================
--- Src/Memory/Memory/Types.hpp	(revision 830)
+++ Src/Memory/Memory/Types.hpp	(working copy)
@@ -1,62 +0,0 @@
-/*
-This file is part of HadesMem.
-Copyright © 2010 RaptorFactor (aka Cypherjb, Cypher, Chazwazza). 
-<http://www.raptorfactor.com/> <raptorfactor@raptorfactor.com>
-
-HadesMem is free software: you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation, either version 3 of the License, or
-(at your option) any later version.
-
-HadesMem is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with HadesMem.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#pragma once
-
-// C++ Standard Library
-#include <string>
-#include <cstdint>
-
-namespace Hades
-{
-  namespace Memory
-  {
-    namespace Types
-    {
-      // Declare fixed-size types
-      typedef std::int8_t     Int8;
-      typedef std::uint8_t    UInt8;
-      typedef std::int16_t    Int16;
-      typedef std::uint16_t   UInt16;
-      typedef std::int32_t    Int32;
-      typedef std::uint32_t   UInt32;
-      typedef std::int64_t    Int64;
-      typedef std::uint64_t   UInt64;
-      typedef float           Float;
-      typedef double          Double;
-      typedef char            CharA;
-      typedef wchar_t         CharW;
-      typedef std::string     StringA;
-      typedef std::wstring    StringW;
-      typedef void*           Pointer;
-
-      // Ensure data type are correct
-      static_assert(sizeof(Int8) == 1, "Size of Int8 is wrong.");
-      static_assert(sizeof(UInt8) == 1, "Size of UInt8 is wrong.");
-      static_assert(sizeof(Int16) == 2, "Size of Int16 is wrong.");
-      static_assert(sizeof(UInt16) == 2, "Size of UInt16 is wrong.");
-      static_assert(sizeof(Int32) == 4, "Size of Int32 is wrong.");
-      static_assert(sizeof(UInt32) == 4, "Size of UInt32 is wrong.");
-      static_assert(sizeof(Int64) == 8, "Size of Int64 is wrong.");
-      static_assert(sizeof(UInt64) == 8, "Size of UInt64 is wrong.");
-      static_assert(sizeof(Float) == 4, "Size of Float is wrong.");
-      static_assert(sizeof(Double) == 8, "Size of Double is wrong.");
-    }
-  }
-}
