* General
  * Documentation via Boost.QuickBook.
    * Write full source docs simultaneously.
    * Write threading docs simultaneously.
    * Write exception guarantee docs simultaneously.
  * Unit tests (Boost.Test?).
    * Cleanup and docs.
    * Extend and improve.
    * Pass app verifier.
    * Leak testing.
  * Example programs.
    * All components.
    * Documented.
    * Comprehensive and targetted at providing useful utilities for remote 
    processes out of the box.
    * Pass app verifier.
    * Leak testing.
  * Improve quality of existing code.
    * Improved and documented exception-safety guarantees, incl rollback 
    support (RAII? Boost.ScopeExit?).
    * Improved and documented thread-safety guarantees.
    * Rethink and reimplement threading model.
    * Fix all 'fixme' items in code.
    * Const correctness.
      * Fix API to support pointers to constant data where possible (rather 
      than using PVOID everywhere).
    * Proper localization and internationalization support/framework.
      * Consider moving from UTF-16 internally to UTF-8, and only using 
      UTF-16 at API boundaries. If implemented, all files written should be 
      UTF-8.
    * Template concept checking and improved error messages.
    * Compile time checks to ensure MSVC, Boost, etc versions meet the minimum 
    requirements.
    * Assertions where appropriate.
    * Config header to account for differences in compilers (or compiler 
    versions). Consider using Boost.Config.
    * Readd GCC experimental support.
    * Improved error reporting via exceptions.
    * Move support where appropriate.
  * Improved binary generation and distribution.
    * Binaries with update server.
    * Automatic binary versioning using SVN revision.
    * Automatic build bot.
    * Digital signature (for build bot, WER, etc).
  * Shared library build option.
    * Including building dependencies as shared libraries.
  * Improve API
    * Clean up APIs returning pairs/tuples/etc to return objects with named 
    fields and/or getters.
    * STL compatible function objects. (e.g. MemoryMgr::Read<T> should return 
    a functor for use in algorithms such as generate_n)
      * Consider using Boost.Phoenix to provide lazy expression evaluation and 
      allow richer functionality. (e.g. MemoryMgr::Read<T>(Addr++) where the 
      expression 'Addr++' is evaluated on every call, and state is maintained 
      across calls, or something to that effect. Needs more investigation.)
      * Should probably be implemented as separate API, to avoid problems 
      caused by implicit conversions and type deduction. (e.g. auto will not 
      behave as expected, function template type deduction will not behave as 
      expected, nor will some other minor things.)
    * Add support for optional error reporing via error codes to avoid 
    littering user code with try-catch blocks.
    * Investigate policy based design where appropriate. (e.g. FindPattern 
    offset style, PeFile file type, MemoryMgr 'bitness', PeFile 'bitness', 
    etc).
    * Make APIs more generic where possible.
      * Instead of taking or returning 
      a vector<T>, instead use C<T> where 'C' is a template param representing 
      an arbitrary container.
      * Use 'ranges' over direct containers where possible.
  * Explicit x64 -> x86 process manipulation support for all components.
  * Reduce compile time.
    * Reduce include dependencies.
    * Pointer-to-impl idiom.
    * Forward declarations where possible. (Boost? STL?)
    * PCH support when using Boost.Build.
    * Decouple components if possible.
    * Ensure all headers are self-sufficient.
  * Todo list
    * Prioritize.
    * Port to Google Code issue tracker.
  * Maintain a changelog.
  * Performance improvements in potential bottlenecks (e.g. iterators).
  
* New Modules
  * Helper service to run HadesMem as 'SYSTEM' for when manipulating certain 
  protected/critical processes (running in separate desktops, sessions, etc).
  * Debugging APIs.
    * Software breakpoint.
    * Hardware breakpoint (incl read/write detection).
    * Conditional breakpoints.
    * Single-stepping.
    * Stack trace APIs.
  * Anti-anti-cheat APIs.
  * Thread/process information APIs.
  * Manual mapper.
    * Windows PE loader reversing.
    * TLS support.
    * Exception handling support.
    * No 'external' (read: MMHelper) dependencies.
  * Remote code 'emulator'.
  * Custom GetModuleHandle, GetProcAddress, etc.
  * Cheat Engine 'replacement'.
  
* Tests
  * In tests such as PeLib etc ensure at least one module is processed per 
  test, in case the validity check function is the one with a regression.
  * Extra sanity checks to ensure not only that the functions return 
  without exception, but also that the returned data is valid. e.g. GetName in 
  ImpThunk etc.
  * Cleanup and document.

* Process
  * Constructors that take window/process name should throw if multiple 
  processes match the criteria. In this case, the PID constructor should be 
  used.
  * Fix process enumeration code to allow x64 -> x86 enumeration.

* MemoryMgr
  * Clean up memory reading/writing API to reduce use of TMP in public 
  interface.
  * Improve 'safety' of remote function caller via EH to minimize risk of 
  crashing target.
  * Improve genericity of parameter passing in remote function caller.
  * Memory reading via expression templates.
  * Improved type genericity via type decay to ensure templates function 
  correctly in the face of const, volatile, references, etc.

* Disassembler
  * Decode calls/jumps to function names where possible.
  * NOP/UnNOP support.
  * ASM searching API with 'wildcards'. (Metasm?)
  * String based assembler with x64 support.
  
* Scanner
  * Use a file view with a small memory cache rather than consuming large 
  amounts of RAM.
  * Multi-threaded scanning option.
  * Wildcard support for vector/string scanning.
  * Regex support for string scanning.
  * Memory protection filters (read, write, exec).
  * Memory type filters (private, mapped, image).
  * Pause target while scanning option.
  * Injected scanning option.
  * Configurable scan buffer size.
  * Pointer scanner.
  * Unknown value scan.
  * Progressive scan filtering based on either value or criteria.
  * Scan history and undo.
  * Case insensitive string scanning option.
  * Binary scanning.
  * Custom scanning via user-supplied predicate.
  * Improved floating-point scanning (configurable or 'smart' epsilon).
  * Group search support.

* Injector
  * .NET injection.
    * Without DLL dependency if possible.
  * Cross-session injection.
  * IAT injection.
  * Varargs/generic export calling.
  * Clean up APIs returning pairs/tuples/etc to return objects with named 
  fields and/or getters.

* Patcher
  * VEH hooking (Both INT3 and DR).
  * Transactional hooking.
  * Improved relative instruction rebuilding (including conditionals).
  * Sanity checking for target process.
  * Freeze target when hooking.
  * VMT hooking.
  * IAT/EAT hooking.
  * Explicitly support hook chains (and write test).
  * Use relative jumps where possible (detect delta at runtime).

* FindPattern
  * Use a file view with a small memory cache rather than consuming large 
  amounts of RAM.
  * Pattern generator.
  * Multi-threaded scanning.
  * 'Start' attribute support.
  * Data/Rdata scanning support (for 'start' attribute and constant scans).
  * Support for loading XML file from resource or memory.
  * Dump results to file.
  * Change parser library from RapidXML to Boost.Spirit (may require a 
  format change from XML to something custom).
  * Object or stream-based implementation that allows operation chaining.
  * Improve constructors.
  * Improve tests.
  * Optional relative address support (for dumping addresses where the game 
  has ASLR enabled).

* PeLib
  * Overlay data support.
  * Finish implementing matching 'setters' for existing 'getters'.
  * Add modules to support more of the PE file format.
  * Check NumberOfRvaAndSizes in NtHeaders sanity checks before attempting to 
  retrieve a data dir.
  * Cache base pointers etc rather than retrieving it manually in every 
  getter/setter. Slightly less 'robust', but due to the typically 'read-only' 
  nature of the data this is the expected behaviour in all known cases anyway.
  * Consistent API for GetBase. e.g. PVOID vs PBYTE vs T*.
  * Resource directory support.
  * Exception directory support.
  * Relocation directory support.
  * Security directory support.
  * Debug directory support.
  * Load config directory support.
  * Delay import directory support.
  * Bound import directory support.
  * IAT (as opposed to Import) directory support.
  * CLR runtime directory support.
  * Full support for writing back to PE file, including automatically 
  performing adjustments where required to fit in new data or remove 
  unnecessary space.
  * Move to sub-folder to avoid header clashes etc.
