[article HadesMem
  [quickbook 1.5]
  [version 1.5.0]
  [copyright 2011 Joshua Boyce]
  [authors [Boyce, Joshua]]
  [license Distributed under the Boost Software License, Version 1.0. (See 
    accompanying file LICENSE_1_0.txt or copy at 
    [@http://www.boost.org/LICENSE_1_0.txt]).]
]

[section:overview Overview]

[h3 Introduction]

HadesMem is a C++-based memory hacking library for Windows based 
applications, with the goal of providing a safe, generic, powerful, and 
efficient API. All components are useable on remote targets. Furthermore, all 
components compile for (and work natively on) both IA32 and AMD64.

[h3 Design]

HadesMem's design is built around the `HadesMem::MemoryMgr` class, which 
provides all the basic and critical functionality required for the other 
components to be implemented.

In terms of language usage, the library aims to exploit modern C++ as much as 
possible, both to ease implementation, and to make library use as easy and as 
error-safe as possible.

[h3 Error Handling]

Exceptions are typically favoured over error codes. The rationale for this 
is that memory hacking is quite 'unsable' by nature, and most use cases favour 
grouping operations in an 'all or nothing' fashion. By using exceptions, the 
amount of boilerplate code required to use the library is significantly 
reduced.

Exceptions in HadesMem are all derived from `HadesMem::HadesMemError`, 
which in turn is derived from both `std::exception` and `boost::exception`. 
Internally, exceptions are built and thrown using the 
[@http://www.boost.org/doc/libs/release/libs/exception/doc/boost-exception.html 
Boost.Exception] libary. When dealing with HadesMem exceptions it is 
recommended to use this library, as very little information is available from 
the `std::exception` interface, or the exception class type.

The tag types commonly used in exceptions thrown by HadesMem are:

* `HadesMem::ErrorFunction` - A `std::string` naming the function the 
exception was thrown from.
* `HadesMem::ErrorString` - A `std::string` describing the problem.
* `HadesMem::ErrorCodeWinRet` - A `DWORD_PTR` containing the return value of 
the Windows API which failed.
* `HadesMem::ErrorCodeWinLast` - A `DWORD` containing the Windows LastError 
code.
* `HadesMem::ErrorCodeWinOther` - A `DWORD_PTR` containing any other relevant 
Windows error codes or return values.
* `HadesMem::ErrorCodeOther` - A `DWORD_PTR` containing miscellaneous error 
codes.

All functions in HadesMem should be considered to throw unless otherwise 
stated in the documentation. Furthermore, all function in HadesMem should 
be considered to offer only the 'basic guarantee' unless otherwise stated 
in the documentation. Work is currently underway to offer the strong or 
no-throw guarantee wherever possible, but is not yet complete.

Libraries used by HadesMem may also throw exceptions (notably Boost and the 
C++ Standard Library). In most cases, no attempt is made by HadesMem to 
suppress or 'translate' these exceptions.

[h3 Threading]

Currently no guarantees are made that multiple threads accessing the same 
HadesMem object will work. Typically it should, but until each function is 
reviewed and documented it is recommended to synchronise access to shared 
objects. Work is currently underway to improve the threading guarantees 
offered by the library, but it is not yet complete.

[h3 Versioning]

HadesMem uses the [@http://semver.org/ semantic versioning] system. Macros 
are available to detect the HadesMem version.

* `HADES_VERSION_MAJOR` - HadesMem major version number.
* `HADES_VERSION_MINOR` - HadesMem minor version number.
* `HADES_VERSION_PATCH` - HadesMem patch version number.
* `HADES_VERSION_FULL` - Full HadesMem version number in format XXYYZZ.
* `HADES_VERSION_FULL_STRING` - Full HadesMem version number in format 
vXX.YY.ZZ, as a narrow C-style string.

[h3 Iterators]

HadesMem iterators are STL-compatible. Iterators are 'lazy' to keep the API 
performant. Lazy in this context means that data enumeration and initialization 
is only performed on-demmand, rather than lists being pre-processed. Furthermore, 
caching is implemented to improve performance when the list is used in multi-pass 
algorithms.

[h3 Support]

Please direct all bug reports and/or feature requests to the issue tracker on 
the [@http://code.google.com/p/hadesmem/ project page]. If you have something 
you would like to discuss in private, or if you have a relatively advanced 
question about the library that can't be answered by looking at the 
documentation or code, I can be reached via email at 
raptorfactor@raptorfactor.com.

[endsect] [/ Overview]

[section:lic License]

HadesMem is licensed under the Boost Software License. Dependencies are under 
their respective (different) licenses. Please respect all license agreements.

[pre Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
]

[endsect] [/ License]

[section:changes Changes]

[h3 v1.5.0]

[*New Features]

* Added new `FindPattern` APIs.
* Added `Export::IsForwardedByOrdinal` and `Export::GetForwarderOrdinal`.
* Added `MemoryMgr::Call` overload to support calling multiple functions from the same 
thread.

[*Bug Fixes]

* Fixed build process.
* Fixed bug in MemoryMgr::CanRead, MemoryMgr::CanWrite, and 
MemoryMgr::CanExecute that was causing failures in Region unit tests. Attempts 
to read/write/execute memory marked as MEM_RESERVE (and not MEM_COMMIT) will 
fail, so check it explicitly.
* Support API Set Schema redirection in `ManualMap`. Fixes various failures 
under Windows 7.
* Various minor bug fixes to `ManualMap`.
* `ManualMap` now attempts to load modules at their preferred base address. 
Fixes some issues with images without relocation data.
* `ManualMap` now bumps the load count of dependent modules. Fixes rare issue 
where dependent module is unloaded by target application.
* `ManualMap` now correctly writes the entire PE headers to memory rather than 
just selected structures.
* `ManualMap` now implements correct path resolution (minus manifest/sxs 
redirection).
* `ManualMap` now calls TLS callbacks from the same thread as the EP.
* `ManualMap` now validates the OS version, machine type, etc of modules 
before attempting to map them.

[*Changes]

* `ManualMap` now uses existing instances of DLLs loaded in the target where 
possible, rather than giving private copies of every module. Done because of 
stability issues when mapping certain system DLLs which can't be properly 
initialized more than once per process.
* Allow HadesMem to be built targetting Windows 2000 SP4. Please note that 
this platform is still not officially supported, I'm just making it an 
'unofficial' option.
* Refactored 'ManualMap'.

[h3 v1.4.0]

[*New Features]

* Added new `Region` APIs.
* Added name based constructor for `Export`.

[*Bug Fixes]

* Fixed handling of forwarded exports in `ManualMap`.
* Fixed case-sensitivity of module caching/detection in `ManualMap`.
* Fixes case where image contained bound imports and `ManualMap` 
stopped. Import bindings are now ignored and reprocessed manually.
* Fixed import processing to use the OriginalFirstThunk list for parsing, 
and the FirstThunk list for binding. Fixes x64 import processing.
* Fixed `Export::GetForwarderFunction`. Was incorrectly including the 
delimiter in the string.

[*Changes]

* All dependencies are now statically linked.
* `ManualMap` now manually maps all dependencies regardless of whether they 
already exist in the process or not. The only exception to this is NTDLL, which 
cannot be mapped twice due to conflicts when calling LdrInitializeThunk.
* Make `ManualMap` test target a more difficult module.
* Update Boost to latest trunk.
* Update BeaEngine to latest trunk.

[h3 v1.3.0]

[*New Features]

* Added new `Injector` APIs.
* Added new `PeLib` APIs.
  * `DosHeader`
  * `ExportDir`
  * `ImportDir`
  * `NtHeaders`
  * `PeFile`
  * `Section`
  * `TlsDir`
* Added experimental `ManualMap` API. Subject to change and availability, not 
for production use. Currently undocumented.
* Added experimental manual mapping example program.

[*Bug Fixes]

* Added missing headers to '''Memory.hpp'''.
* Fixed Boost build scripts.
* `MemoryMgr::ReadString`, `MemoryMgr::ReadList`, `MemoryMgr::WriteString`, 
and `MemoryMgr::WriteList` now support custom allocators and traits classes 
(where appliciable) for the containers passed as template arguments.

[*Changes]

* HadesMem is now licensed under the [@http://www.boost.org/LICENSE_1_0.txt 
Boost Software License]. This is a far more permissive license than the 
previous one (the GNU GPL v3). Please review the new license before use.
* Improved `Module` tests.
* Improved documentation.
* Updated Boost.
* Removed unnecessary template metaprogramming from `MemoryMgr::ReadString`, 
`MemoryMgr::ReadList`, `MemoryMgr::WriteString`, and `MemoryMgr::WriteList`. 
Now using static assertions instead.

[h3 v1.2.0]

[*New Features]

* Added `CreateProcess` overload for argument lists (to ensure correct 
quoting).
* Move support for `AllocAndFree`.

[*Bug Fixes]

* Ensure COM is initialized and cleaned up in `CreateProcess`.
* Fixed documentation for `HADES_VERSION_FULL_STRING`. Format is vXX.YY.ZZ, 
not vXXYYZZ.
* Fix critical bug causing problems opening processes other than the 
current process.

[*Changes]

[h3 v1.1.0]

[*New Features]

* Move support for `MemoryMgr`.
* Version macros.
* Documented copy/assignment/move constructors/operators for `MemoryMgr`.
* Added new `Module` APIs.

[*Bug Fixes]

* Fixed build scripts for users who did not have BJam installed in their 
%PATH%. This was a bug introduced when Boost.Build changed BJam's name to B2.

[*Changes]

* Improved compiler detection.
* Improved build scripts to allow architecture selection.
* Changed `MemoryMgr::Call` to use the new `Module` APIs for increased 
stability.
* Improved Boost build scripts to only build the libraries that are used 
by HadesMem. This results in a much faster build time.
* Updated Boost to latest trunk.
* Added build scripts for Intel. Please note that this platform is still 
unsupported (as per the documentation). The scripts are there so users can 
help with the porting process (as are the Clang scripts).

[h3 v1.0.0]

* Initial SemVer release. Currently the only API available is the MemoryMgr 
component, but it should remain stable from now on (until the next major 
version bump). New components will be added incrementally once stabilized.

[endsect] [/ Changes]

[section:building Building]

HadesMem uses the [@http://www.boost.org/boost-build2/ Boost.Build] build 
system. If you have not already, it is recommended you familiarize yourself 
with this framework.

Supported Compilers:

* [@http://www.microsoft.com/visualstudio/en-us Microsoft Visual C++ 2010] 
(Express edition not officially supported)
* [@http://gcc.gnu.org/ GNU GCC 4.6.0] (via 
[@http://www.equation.com/servlet/equation.cmd?fa=fortran MinGW-w64])

Supported Platforms:

* [@http://www.microsoft.com/windows/ Microsoft Windows] (Windows XP SP2 or 
later)

Steps to Build:

# Build Boost.
  # Navigate to Build/Boost.
  # Run Bootstrap.bat.
  # Run Build_Compiler_Architecture.bat (Substitute 'Compiler', and 
  'Architecture' as appropriate).
  # Check output and ensure there are no errors.
# Build HadesMem.
  # Navigate to Build/Full.
  # Run Build_Compiler_Configuration_Architecture.bat (Substitute 'Compiler', 
  'Configuration', and 'Architecture' as appropriate).
  # Check output and ensure there are no errors.
  
Using HadesMem (in a Boost.Build based project):

# Add a /use-project/ directive to your Jamroot targeting HadesMem (this 
document assumes you name the project 'HadesMem').
# Add '''/HadesMem//HadesMem''' to the source list of your application/library 
or the requirements list of your project.
# Add `#include <HadesMemory/Memory.hpp>` to your code.
# Set the BOOST_ROOT environmental variable and copy b2 to somewhere in your 
PATH.

[note When compiling your Boost.Build based project, explicitly specify the 
toolset, address-model and debug/release configuration on the command line to 
ensure that nothing needs to be recompiled and you are using the correct 
settings. If you've done it right then you should only need to link to Boost 
and HadesMem (i.e. nothing should be recompiled).]

Sample Jamroot
``
use-project /HadesMem 
  : 
    ../../HadesMem-Branches-v1.0.0/
  ;

exe Test
  : 
    Test.cpp
    /HadesMem//HadesMem
  ;
``

Sample Command-line:
``
b2 toolset=msvc-10.0 address-model=32 debug
``

[endsect] [/ Building]

[section:reference Reference]

[section:core Core]

[section:memorymgr MemoryMgr]

[h3 Synopsis]

  // In header: <HadesMemory/MemoryMgr.hpp>

  class MemoryMgr
  {
  public:
    class Error : public virtual HadesMemError;

    explicit MemoryMgr(DWORD ProcID);
      
    MemoryMgr(MemoryMgr const& Other);
    
    MemoryMgr& operator=(MemoryMgr const& Other);
    
    MemoryMgr(MemoryMgr&& Other);
    
    MemoryMgr& operator=(MemoryMgr&& Other);
    
    ~MemoryMgr();

    class RemoteFunctionRet
    {
    public:
      DWORD_PTR GetReturnValue() const;
      
      DWORD64 GetReturnValue64() const;
      
      DWORD GetLastError() const;
    };
  
    enum CallConv
    {
      CallConv_Default, 
      CallConv_CDECL, 
      CallConv_STDCALL, 
      CallConv_THISCALL, 
      CallConv_FASTCALL, 
      CallConv_X64
    };

    RemoteFunctionRet Call(LPCVOID Address, CallConv MyCallConv, 
      std::vector<PVOID> const& Args) const;

    std::vector<RemoteFunctionRet> Call(std::vector<LPCVOID> Addresses, 
      std::vector<CallConv> MyCallConvs, 
      std::vector<std::vector<PVOID>> const& Args) const;

    template <typename T>
    T Read(PVOID Address) const;

    template <typename T>
    T ReadString(PVOID Address) const;

    template <typename T>
    T ReadList(PVOID Address, std::size_t Size) const;

    template <typename T>
    void Write(PVOID Address, T const& Data) const;

    template <typename T>
    void WriteString(PVOID Address, T const& Data) const;

    template <typename T>
    void WriteList(PVOID Address, T const& Data) const;

    bool CanRead(LPCVOID Address) const;

    bool CanWrite(LPCVOID Address) const;

    bool IsGuard(LPCVOID Address) const;
    
    DWORD ProtectRegion(LPVOID Address, DWORD Protect) const;

    PVOID Alloc(SIZE_T Size) const;

    void Free(PVOID Address) const;

    void FlushCache(LPCVOID Address, SIZE_T Size) const;

    DWORD GetProcessId() const;

    HANDLE GetProcessHandle() const;
    
    std::wstring GetProcessPath() const;
    
    bool IsProcessWoW64() const;
    
    bool operator==(MemoryMgr const& Rhs) const;
    
    bool operator!=(MemoryMgr const& Rhs) const;
  };
  
  MemoryMgr CreateProcess(std::wstring const& Path, 
    std::wstring const& Params, 
    std::wstring const& WorkingDir);
  
  void GetSeDebugPrivilege();

  class AllocAndFree
  {
  public:
    AllocAndFree(MemoryMgr const& MyMemoryMgr, SIZE_T Size);

    ~AllocAndFree();
    
    void Free() const;

    PVOID GetBase() const;
    
    SIZE_T GetSize() const;

  protected:
    AllocAndFree(AllocAndFree const&);
    AllocAndFree& operator=(AllocAndFree const&);
  };

[h3 Description]

The MemoryMgr class provides the most basic memory hacking functionality, and 
is the basis on which all other HadesMem components are built.

Free functions are provided for other common basic operations which are not 
specific to a remote process.

The AllocAndFree class is an RAII wrapper for remote memory allocation.

[h3 MemoryMgr public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `MemoryMgr` methods when an error occurs.

  class RemoteFunctionRet;

Type containing the return information of a remote function call. Exposes 
integer and thread-local return values. Floating point return information 
is currently unsupported. See `RemoteFunctionRet' documentation for more 
information.

  enum CallConv;

Calling conventions for remote function caller. All calling conventions follow 
Microsoft specifications. Other compilers and custom calling conventions are 
currently unsupported.

* CallConv_Default - Default calling convention. Equivalent to 
`CallConv_STDCALL` on x86 and `CallConv_X64` on x64.
* CallConv_CDECL - [@http://msdn.microsoft.com/en-us/library/zkwh89ks.aspx 
__cdecl] calling convention.
* CallConv_STDCALL - [@http://msdn.microsoft.com/en-us/library/zxk0tw93.aspx 
__stdcall] calling convention.
* CallConv_THISCALL - [@http://msdn.microsoft.com/en-us/library/ek8tkfbw.aspx 
__thiscall] calling convention.
* CallConv_FASTCALL - [@http://msdn.microsoft.com/en-us/library/6xa169sk.aspx 
__fastcall] calling convention.
* CallConv_X64 - [@http://msdn.microsoft.com/en-us/library/ms235286.aspx x64] 
calling convention.

[h3 MemoryMgr public construct/copy/destruct/move]

[h4 MemoryMgr process ID constructor]

  explicit MemoryMgr(DWORD ProcID);

[variablelist

[[Effects:] [Constructs a `MemoryMgr` instance that refers to the specified 
process.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr copy constructor]

  MemoryMgr(MemoryMgr const& Other);

[variablelist

[[Effects:] [Constructs a `MemoryMgr` that refers to the same process as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr copy assignment operator]

  MemoryMgr& operator=(MemoryMgr const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr move constructor]

  MemoryMgr(MemoryMgr&& Other);

[variablelist

[[Effects:] [Constructs a `MemoryMgr` that refers to the same process as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr move assignment operator]

  MemoryMgr& operator=(MemoryMgr&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same process as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr destructor]

  ~MemoryMgr();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 MemoryMgr public member functions]

[h4 MemoryMgr member function `Call`]

  RemoteFunctionRet Call(LPCVOID Address, CallConv MyCallConv, 
    std::vector<PVOID> const& Args) const;

  std::vector<RemoteFunctionRet> Call(std::vector<LPCVOID> Addresses, 
    std::vector<CallConv> MyCallConvs, 
    std::vector<std::vector<PVOID>> const& Args) const;

[variablelist

[[Effects:] [Calls a function at `Address`, using calling convention 
`MyCallConv`, with the arguments `Args`. Alternatively, calls multiple 
functions.]]

[[Returns:] [A `RemoteFunctionRet` instance.]]

[[Throws:] [Yes.]]

[[Notes:] [All arguments must be equivalent to integer arguments, with a size 
equal to or less than the native pointer size of the platform. Floating point 
arguments are unsupported.]]

]

[h4 MemoryMgr member function `Read`]

  template <typename T>
  T Read(PVOID Address) const;

[variablelist

[[Returns:] [Instance of type `T` constructed from memory at `Address`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be a POD type.]]

]

[h4 MemoryMgr member function `ReadString`]

  template <typename T>
  T ReadString(PVOID Address) const;

[variablelist

[[Returns:] [Instance of type `T` constructed from memory at `Address`. Reads 
individual characters until a null is encountered.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be of type `std::basic_string<CharT, U, V>`, where `CharT` 
is a POD character type, `U` is an optional character traits class, and `V` is 
an optional allocator. String is read as if it is a C-style character array.]]

]

[h4 MemoryMgr member function `ReadList`]

  template <typename T>
  T ReadList(PVOID Address, std::size_t Size) const;

[variablelist

[[Returns:] [Instance of type `T` constructed from memory at `Address`. Reads 
`Size` items from `Address` and stores them in a `T`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be of type `std::vector<U, A>`, where `U` is a POD type, 
and `A` is an optional allocator. List is read as if it is a C-style array.]]

]

[h4 MemoryMgr member function `Write`]

  template <typename T>
  void Write(PVOID Address, T const& Data) const;

[variablelist

[[Effects:] [Writes `Data` to `Address`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be a POD type.]]

]

[h4 MemoryMgr member function `WriteString`]

  template <typename T>
  void WriteString(PVOID Address, T const& Data) const;

[variablelist

[[Effects:] [Writes `Data` to `Address`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be of type `std::basic_string<CharT, U, V>`, where `CharT` 
is a POD character type, `U` is an optional character traits class, and `V` is 
an optional allocator. `Data` is written as a C-style character array.]]

]

[h4 MemoryMgr member function `WriteList`]

  template <typename T>
  void WriteList(PVOID Address, T const& Data) const;

[variablelist

[[Effects:] [Writes `Data` to `Address`.]]

[[Throws:] [Yes.]]

[[Notes:] [`T` must be of type `std::vector<U, A>`, where `U` is a POD type, 
and `A` is an optional allocator. `Data` is written as a C-style array.]]

]

[h4 MemoryMgr member function `CanRead`]

  bool CanRead(LPCVOID Address) const;

[variablelist

[[Returns:] [Whether memory region at `Address` is readable.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `CanWrite`]

  bool CanWrite(LPCVOID Address) const;

[variablelist

[[Returns:] [Whether memory region at `Address` is writable.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `CanExecute`]

  bool CanExecute(LPCVOID Address) const;

[variablelist

[[Returns:] [Whether memory region at `Address` is executable.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `IsGuard`]

  bool IsGuard(LPCVOID Address) const;

[variablelist

[[Returns:] [Whether memory region at `Address` is a guard page.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `ProtectRegion`]

  DWORD ProtectRegion(LPVOID Address, DWORD Protect) const;

[variablelist

[[Effects:] [Protect memory region at `Address` with protection `Protect`.]]

[[Returns:] [Previous protection at `Address`.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `Alloc`]

  PVOID Alloc(SIZE_T Size) const;

[variablelist

[[Effects:] [Allocate memory region with size `Size`.]]

[[Returns:] [Base address of memory region.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `Free`]

  void Free(PVOID Address) const;

[variablelist

[[Effects:] [Free memory region at address `Address`.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `FlushCache`]

  void FlushCache(LPCVOID Address, SIZE_T Size) const;

[variablelist

[[Effects:] [Flush instruction cache at address `Address` with size `Size`.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `GetProcessId`]

  DWORD GetProcessId() const;

[variablelist

[[Returns:] [Process ID of target.]]

[[Throws:] [No.]]

]

[h4 MemoryMgr member function `GetProcessHandle`]

  HANDLE GetProcessHandle() const;

[variablelist

[[Returns:] [Process handle to target.]]

[[Throws:] [No.]]

]

[h4 MemoryMgr member function `GetProcessPath`]

  std::wstring GetProcessPath() const;

[variablelist

[[Returns:] [Path to target.]]

[[Throws:] [Yes.]]

]

[h4 MemoryMgr member function `IsProcessWoW64`]

  bool IsProcessWoW64() const;

[variablelist

[[Returns:] [Whether process is running under WoW64.]]

[[Throws:] [No.]]

]

[h4 MemoryMgr equality operator]

  bool operator==(MemoryMgr const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same process.]]

[[Throws:] [No.]]

]

[h4 MemoryMgr inequality operator]

  bool operator!=(MemoryMgr const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different process.]]

[[Throws:] [No.]]

]

[h3 Free functions]

[h4 Free function `CreateProcess`]

  MemoryMgr CreateProcess(std::wstring const& Path, 
    std::wstring const& CommandLine, 
    std::wstring const& WorkingDir);
  
  MemoryMgr CreateProcess(std::wstring const& Path, 
    std::vector<std::wstring> const& Args, 
    std::wstring const& WorkingDir);

[variablelist

[[Effects:1:] [Create process from binary at `Path` with optional command line  
`CommandLine` and optional working dir `WorkingDir`.]]

[[Effects:2:] [Create process from binary at `Path` with optional argument list  
`Args` and optional working dir `WorkingDir`. Command line generation is 
handled by the API to ensure correct quoting as per [@http://goo.gl/t4ERU 
this] article.]]

[[Returns:] [Memory manager instance for new process.]]

[[Throws:] [Yes.]]

]

[h4 Free function `GetSeDebugPrivilege`]
  
  void GetSeDebugPrivilege();

[variablelist

[[Effects:] [Sets the [@http://msdn.microsoft.com/en-us/library/bb530716.aspx 
SeDebugPrivilege] on the calling process.]]

[[Throws:] [Yes.]]

[[Notes:] [Requires the caller to be running with administrator 
credentials.]]

]

[h3 AllocAndFree public construct/copy/destruct/move]

[h4 AllocAndFree constructor]

  AllocAndFree(MemoryMgr const& MyMemoryMgr, SIZE_T Size);

[variablelist

[[Effects:] [Allocates memory block of size `Size` using the `MemoryMgr` 
object `MyMemoryMgr`.]]

[[Throws:] [Yes.]]

]

[h4 AllocAndFree move constructor]

  AllocAndFree(AllocAndFree&& Other);

[variablelist

[[Effects:] [Constructs a `AllocAndFree` that refers to the same memory as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 AllocAndFree move assignment operator]

  AllocAndFree& operator=(AllocAndFree&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same memory as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 AllocAndFree destructor]

  ~AllocAndFree();

[variablelist

[[Effects:] [Frees the remote memory block (unless already freed manually).]]

[[Throws:] [No. Exceptions thrown when freeing the memor will be swallowed.]]

]

[h3 AllocAndFree public member functions]

[h4 AllocAndFree member function `Free`]

  void Free() const;

[variablelist

[[Effects:] [Frees the remote memory block (unless already freed manually).]]

[[Throws:] [Yes.]]

]

[h4 AllocAndFree member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of remote memory block.]]

[[Throws:] [No.]]

]

[h4 AllocAndFree member function `GetSize`]

  SIZE_T GetSize() const;

[variablelist

[[Returns:] [Size of remote memory block.]]

[[Throws:] [No.]]

]

[h3 MemoryMgr::RemoteFunctionRet public member functions]

[h4 MemoryMgr::RemoteFunctionRet member function `GetReturnValue`]

    DWORD_PTR GetReturnValue() const;

[variablelist

[[Returns:] [The integer return value for the remote function in the native 
pointer size for the platform.]]

[[Throws:] [No.]]

]

[h4 MemoryMgr::RemoteFunctionRet member function `GetReturnValue64`]

    DWORD64 GetReturnValue64() const;

[variablelist

[[Returns:] [The 64-bit integer return value for the remote function.]]

[[Throws:] [No.]]

[[Notes:] [Same as GetReturnValue on x64.]]

]

[h4 MemoryMgr::RemoteFunctionRet member function `GetLastError`]

    DWORD GetLastError() const;

[variablelist

[[Returns:] [The last error code for the remote function. Equivalent to 
calling the Windows API `GetLastError` in the context of the target process 
after the function call.]]

[[Throws:] [No.]]

]

[endsect] [/ MemoryMgr]

[section:module Module]

[h3 Synopsis]

  // In header: <HadesMemory/Module.hpp>

  class Module
  {
  public:
    class Error : public virtual HadesMemError;
    
    Module(MemoryMgr const& MyMemory, HMODULE Handle);
    
    Module(MemoryMgr const& MyMemory, std::wstring const& ModuleName);
    
    Module(MemoryMgr const& MyMemory, MODULEENTRY32 const& ModuleEntry);
    
    Module(Module const& Other);
    
    Module& operator=(Module const& Other);
    
    Module(Module&& Other);
    
    Module& operator=(Module&& Other);
    
    ~Module();
    
    HMODULE GetBase() const;
    
    DWORD GetSize() const;
    
    std::wstring GetName() const;
    
    std::wstring GetPath() const;
    
    FARPROC FindProcedure(std::string const& Name) const;
    
    FARPROC FindProcedure(WORD Ordinal) const;
    
    bool operator==(Module const& Rhs) const;
    
    bool operator!=(Module const& Rhs) const;
  };
  
  Module GetRemoteModule(MemoryMgr const& MyMemory, LPCWSTR ModuleName);
  
  class ModuleList
  {
  public:
    class Error : public virtual HadesMemError;
    
    typedef unspecified iterator;
    typedef unspecified const_iterator;
    
    explicit ModuleList(MemoryMgr const& MyMemory);
    
    iterator begin();
    
    iterator end();
    
    const_iterator begin() const;
    
    const_iterator end() const;
    
    const_iterator cbegin() const;
    
    const_iterator cend() const;
  };

[h3 Description]

The `Module` class provides functionality for finding and working with modules 
(a.k.a DLLs or EXEs).

The GetRemoteModuleHandle free function provides an 'extension' of the 
`GetModuleHandle` Windows API to allow lookup in a remote process.

The `ModuleList` class provides STL-compatible iterators for module 
enumeration.

[h3 Module public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `Module` methods when an error occurs.

[h3 Module public construct/copy/destruct/move]

[h4 Module handle constructor]

  Module(MemoryMgr const& MyMemory, HMODULE Handle);

[variablelist

[[Effects:] [Constructs a `Module` instance that refers to the specified 
module.]]

[[Throws:] [Yes.]]

]

[h4 Module name constructor]

  Module(MemoryMgr const& MyMemory, std::wstring const& ModuleName);

[variablelist

[[Effects:] [Constructs a `Module` instance that refers to the specified 
module.]]

[[Throws:] [Yes.]]

]

[h4 Module module entry constructor]

  Module(MemoryMgr const& MyMemory, MODULEENTRY32 const& ModuleEntry);

[variablelist

[[Effects:] [Constructs a `Module` instance from the data in the module 
entry.]]

[[Throws:] [Yes.]]

]

[h4 Module copy constructor]

  Module(Module const& Other);

[variablelist

[[Effects:] [Constructs a `Module` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 Module copy assignment operator]

  Module& operator=(Module const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 Module move constructor]

  Module(Module&& Other);

[variablelist

[[Effects:] [Constructs a `Module` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Module move assignment operator]

  Module& operator=(Module&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Module destructor]

  ~Module();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 Module public member functions]

[h4 Module member function `GetHandle`]

  HMODULE GetHandle() const;

[variablelist

[[Returns:] [Handle (a.k.a base address) to module.]]

[[Throws:] [Yes.]]

]

[h4 Module member function `GetSize`]

  DWORD GetSize() const;

[variablelist

[[Returns:] [Size of module.]]

[[Throws:] [Yes.]]

]

[h4 Module member function `GetName`]

  std::wstring GetName() const;

[variablelist

[[Returns:] [Name of module.]]

[[Throws:] [Yes.]]

]

[h4 Module member function `GetPath`]

  std::wstring GetPath() const;

[variablelist

[[Returns:] [Path to module.]]

[[Throws:] [Yes.]]

]

[h4 Module member function `FindProcedure`]

  FARPROC FindProcedure(std::string const& Name) const;
  FARPROC FindProcedure(WORD Ordinal) const;

[variablelist

[[Effects:] [Looks for procedure in export address table of module, either 
via name `Name` or ordinal `Ordinal`.]]

[[Returns:] [Address of procedure.]]

[[Throws:] [Yes.]]

]

[h4 Module equality operator]

  bool operator==(Module const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same module.]]

[[Throws:] [No.]]

]

[h4 Module inequality operator]

  bool operator!=(Module const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different module.]]

[[Throws:] [No.]]

]

[h3 Free functions]

[h4 Free function `GetRemoteModule`]

  Module GetRemoteModule(MemoryMgr const& MyMemory, LPCWSTR ModuleName);

[variablelist

[[Effects:] [Has the same effects as the Windows API 
[@http://msdn.microsoft.com/en-us/library/ms683199.aspx GetModuleHandle].]]

[[Returns:] [Requested module.]]

[[Throws:] [Yes.]]

]

[h3 ModuleList public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `ModuleList` methods when an error occurs.

  typedef unspecified iterator;
  typedef unspecified const_iterator;
  
Iterator type for module list. Models the 
[@http://www.sgi.com/tech/stl/ForwardIterator.html ForwardIterator] concept. 
Implementation type unspecified.

[h3 ModuleList public construct/copy/destruct/move]

[h4 ModuleList constructor]

  explicit ModuleList(MemoryMgr const& MyMemory);

[variablelist

[[Effects:] [Constructs a `ModuleList` instance targetting the process 
specified by `MyMemory`.]]

[[Throws:] [Yes.]]

]

[h4 ModuleList move constructor]

  ModuleList(ModuleList&& Other);

[variablelist

[[Effects:] [Constructs a `ModuleList` that refers to the same module list as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ModuleList move assignment operator]

  ModuleList& operator=(ModuleList&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same module list as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ModuleList destructor]

  ~ModuleList();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 ModuleList public member functions]

[h4 ModuleList member function `begin`]

  iterator begin();
  const_iterator begin() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for start of module 
list.]]

[[Throws:] [Yes.]]

]

[h4 ModuleList member function `end`]

  iterator end();
  const_iterator end() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for off-the-end of 
module list.]]

[[Throws:] [Yes.]]

]

[h4 ModuleList member function `cbegin`]

  const_iterator cbegin() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for start of module list.]]

[[Throws:] [Yes.]]

]

[h4 ModuleList member function `cend`]

  const_iterator cend() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for off-the-end of module list.]]

[[Throws:] [Yes.]]

]

[endsect] [/ Module]

[section:injector Injector]

[h3 Synopsis]

  // In header: <HadesMemory/Injector.hpp>

  class Injector
  {
  public:
    class Error : public virtual HadesMemError;

    explicit Injector(MemoryMgr const& MyMemory);
      
    Injector(Injector const& Other);
    
    Injector& operator=(Injector const& Other);
    
    Injector(Injector&& Other);
    
    Injector& operator=(Injector&& Other);
    
    ~Injector();
    
    enum InjectFlags
    {
      InjectFlag_None, 
      InjectFlag_PathResolution
    };

    HMODULE InjectDll(std::wstring const& Path, 
      InjectFlags Flags = InjectFlag_None) const;
      
    void FreeDll(HMODULE Module) const;
    
    MemoryMgr::RemoteFunctionRet CallExport(HMODULE RemoteModule, 
      std::string const& Export) const;
    
    bool operator==(Injector const& Rhs) const;
    
    bool operator!=(Injector const& Rhs) const;
  };
    
  class CreateAndInjectData
  {
  public:
    CreateAndInjectData(MemoryMgr const& MyMemory, HMODULE Module, 
      DWORD_PTR ExportRet, DWORD ExportLastError);
    
    CreateAndInjectData(CreateAndInjectData const& Other);
    
    CreateAndInjectData& operator=(CreateAndInjectData const& Other);
    
    CreateAndInjectData(CreateAndInjectData&& Other);
    
    CreateAndInjectData& operator=(CreateAndInjectData&& Other);
    
    ~CreateAndInjectData();
    
    MemoryMgr GetMemoryMgr() const;
    
    HMODULE GetModule() const;
    
    DWORD_PTR GetExportRet() const;
    
    DWORD GetExportLastError() const;
  };
  
  CreateAndInjectData CreateAndInject(
    std::wstring const& Path, 
    std::wstring const& WorkDir, 
    std::vector<std::wstring> const& Args, 
    std::wstring const& Module, 
    std::string const& Export, 
    Injector::InjectFlags Flags = Injector::InjectFlag_None);

[h3 Description]

The Injector class provides DLL injection and freeing/'ejection' 
functionality.

CreateAndInject is a free function is provided to facilitate the injection of 
a module at process startup, before the entry point of the program is run.

The CreateAndInjectData class contains return information for the 
CreateAndInject free function.

[h3 Injector public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `Injector` methods when an error occurs.

  enum InjectFlags;

Injection flags to control behaviour such as path resolution. Necessary because 
sometimes you will want paths to be resolved completely in the context of your 
code, and other times you will want paths to be resolved by the PE loader in 
the context of the target.

* InjectFlag_None - No injection flags.
* InjectFlag_PathResolution - Resolve relative paths in the context of the 
caller. Default behaviour without this flag is to defer path resolution to 
the target.

[h3 Injector public construct/copy/destruct/move]

[h4 Injector constructor]

  explicit Injector(MemoryMgr const& MyMemory);

[variablelist

[[Effects:] [Constructs an `Injector` instance that refers to the specified 
target.]]

[[Throws:] [Yes.]]

]

[h4 Injector copy constructor]

  Injector(Injector const& Other);

[variablelist

[[Effects:] [Constructs an `Injector` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 Injector copy assignment operator]

  Injector& operator=(Injector const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 Injector move constructor]

  Injector(Injector&& Other);

[variablelist

[[Effects:] [Constructs a `Injector` that refers to the same process as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Injector move assignment operator]

  Injector& operator=(Injector&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same process as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Injector destructor]

  ~Injector();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 Injector public member functions]

[h4 Injector member function `InjectDll`]

  HMODULE InjectDll(std::wstring const& Path, 
    InjectFlags Flags = InjectFlag_None) const;

[variablelist

[[Effects:] [Inject DLL loaded from `Path` using the injection flags `Flags`. 
Injection is done by calling the Windows API 
[@http://msdn.microsoft.com/en-us/library/ms684175.aspx LoadLibraryW] 
in the context of the remote target.]]

[[Returns:] [A handle to the injected module.]]

[[Throws:] [Yes.]]

]

[h4 Injector member function `FreeDll`]

  void FreeDll(HMODULE Module) const;

[variablelist

[[Effects:] [Frees a module by calling the Windows API 
[@http://msdn.microsoft.com/en-us/library/ms683152.aspx FreeLibrary] in the 
context of the remote target.]]

[[Throws:] [Yes.]]

]

[h4 Injector member function `CallExport`]

  MemoryMgr::RemoteFunctionRet CallExport(HMODULE RemoteModule, 
    std::string const& Export) const;

[variablelist

[[Effects:] [Calls the export `Export` in module `RemoteModule`, assuming 
function prototype '''DWORD_PTR __stdcall Foo(HMODULE)'''.]]

[[Returns:] [A `RemoteFunctionRet` instance.]]

[[Throws:] [Yes.]]

[[Notes:] [This is a thin wrapper around `MemoryMgr::Call`, see the 
`MemoryMgr` documentation for further information.]]

]

[h4 Injector equality operator]

  bool operator==(Injector const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same target.]]

[[Throws:] [No.]]

]

[h4 Injector inequality operator]

  bool operator!=(Injector const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different target.]]

[[Throws:] [No.]]

]

[h3 CreateAndInjectData public construct/copy/destruct/move]

[h4 CreateAndInjectData constructor]

  CreateAndInjectData(MemoryMgr const& MyMemory, HMODULE Module, 
    DWORD_PTR ExportRet, DWORD ExportLastError);

[variablelist

[[Effects:] [Creates an injection data wrapper from MemoryMgr instance 
`MyMemory`, module handle `Module`, export return value `ExportRet`, and 
export last error code `ExportLastError`.]]

[[Throws:] [Yes.]]

]

[h4 CreateAndInjectData copy constructor]

  CreateAndInjectData(CreateAndInjectData const& Other);

[variablelist

[[Effects:] [Constructs a `CreateAndInjectData` that refers to the same target 
as `Other`.]]

[[Throws:] [Yes.]]

]

[h4 CreateAndInjectData copy assignment operator]

  CreateAndInjectData& operator=(CreateAndInjectData const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 CreateAndInjectData move constructor]

  CreateAndInjectData(CreateAndInjectData&& Other);

[variablelist

[[Effects:] [Constructs a `CreateAndInjectData` that refers to the same target 
as `Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 CreateAndInjectData move assignment operator]

  CreateAndInjectData& operator=(CreateAndInjectData&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 CreateAndInjectData destructor]

  ~CreateAndInjectData();

[variablelist

[[Effects:] [Frees the remote memory block (unless already freed manually).]]

[[Throws:] [No.]]

]

[h3 CreateAndInjectData public member functions]

[h4 CreateAndInjectData member function `GetMemoryMgr`]

  MemoryMgr GetMemoryMgr() const;

[variablelist

[[Returns:] [Memory manager object for new process.]]

[[Throws:] [Yes.]]

]

[h4 CreateAndInjectData member function `GetModule`]

  HMODULE GetModule() const;

[variablelist

[[Returns:] [Handle to injected module.]]

[[Throws:] [No.]]

]

[h4 CreateAndInjectData member function `GetExportRet`]

  DWORD_PTR GetExportRet() const;

[variablelist

[[Returns:] [Return value of export.]]

[[Throws:] [No.]]

]

[h4 CreateAndInjectData member function `GetExportLastError`]

  DWORD GetExportLastError() const;

[variablelist

[[Returns:] [Last error code for export.]]

[[Throws:] [No.]]

]

[h3 Free functions]

[h4 Free function `CreateAndInject`]

  CreateAndInjectData CreateAndInject(
    std::wstring const& Path, 
    std::wstring const& WorkDir, 
    std::vector<std::wstring> const& Args, 
    std::wstring const& Module, 
    std::string const& Export, 
    Injector::InjectFlags Flags = Injector::InjectFlag_None);

[variablelist

[[Effects:] [Create suspended process from binary at `Path` with optional 
working dir `WorkDir`, optional arguments `Args`. DLL at path `Module` is then 
injected using optional injection flags `Flags`, and optional export `Export` 
is run. Process is then resumed.]]

[[Returns:] [A `CreateAndInjectData` instance.]]

[[Throws:] [Yes.]]

]

[endsect] [/ Injector]

[section:region Region]

[h3 Synopsis]

  // In header: <HadesMemory/Region.hpp>
  
  class Region
  {
  public:
    class Error : public virtual HadesMemError 
    { };
    
    Region(MemoryMgr const& MyMemory, PVOID Address);
    
    Region(MemoryMgr const& MyMemory, MEMORY_BASIC_INFORMATION const& MyMbi);

    PVOID GetBase() const;
    
    PVOID GetAllocBase() const;
    
    DWORD GetAllocProtect() const;
    
    SIZE_T GetSize() const;
    
    DWORD GetState() const;
    
    DWORD GetProtect() const;
    
    DWORD GetType() const;
    
    DWORD SetProtect(DWORD Protect) const;
    
    void Dump(std::wstring const& Path) const;
    
    bool operator==(Region const& Rhs) const;
    
    bool operator!=(Region const& Rhs) const;
  };
  
  class RegionList
  {
  public:
    class Error : public virtual HadesMemError
    { };
      
    typedef unspecified iterator;
    typedef unspecified const_iterator;
        
    RegionList(MemoryMgr const& MyMemory);
    
    RegionList(RegionList&& Other);
    
    RegionList& operator=(RegionList&& Other);
    
    iterator begin();
    
    iterator end();
    
    const_iterator begin() const;
     
    const_iterator end() const;
    
    const_iterator cbegin() const;
     
    const_iterator cend() const;
  };

[h3 Description]

The `Region` class provides functionality for working with memory regions.

The `RegionList` class provides STL-compatible iterators for region 
enumeration.

[h3 Region public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `Region` methods when an error occurs.

[h3 Region public construct/copy/destruct/move]

[h4 Region address constructor]

  Region(MemoryMgr const& MyMemory, PVOID Address);

[variablelist

[[Effects:] [Constructs a `Region` instance that refers to the specified 
region.]]

[[Throws:] [Yes.]]

]

[h4 Region memory information constructor]

  Region(MemoryMgr const& MyMemory, MEMORY_BASIC_INFORMATION const& MyMbi);

[variablelist

[[Effects:] [Constructs a `Region` instance directly (without memory queries) 
using the fields from the memory region structure.]]

[[Throws:] [Yes.]]

]

[h4 Region copy constructor]

  Region(Region const& Other);

[variablelist

[[Effects:] [Constructs a `Region` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 Region copy assignment operator]

  Region& operator=(Region const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 Region move constructor]

  Region(Region&& Other);

[variablelist

[[Effects:] [Constructs a `Region` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Region move assignment operator]

  Region& operator=(Region&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Region destructor]

  ~Region();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 Region public member functions]

[h4 Region member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of region.]]

[[Throws:] [Yes.]]

]

[h4 Region member function `GetAllocBase`]

  PVOID GetAllocBase() const;

[variablelist

[[Returns:] [Allocation base address of region.]]

[[Throws:] [Yes.]]

]

[h4 Region member function `GetAllocProtect`]

  DWORD GetAllocProtect() const;

[variablelist

[[Returns:] [Allocation protection of region.]]

[[Throws:] [Yes.]]

]

[h4 Region member function `GetSize`]

  SIZE_T GetSize() const;

[variablelist

[[Returns:] [Size of region.]]

[[Throws:] [Yes.]]

]

[h4 Region member function `GetState`]

  DWORD GetState() const;

[variablelist

[[Returns:] [State of region.]]

[[Throws:] [Yes.]]

]

[h4 Region member function `GetProtect`]

  DWORD GetProtect() const;

[variablelist

[[Returns:] [Protection of region.]]

[[Throws:] [Yes.]]

]

[h4 Region member function `GetType`]

  DWORD GetType() const;

[variablelist

[[Returns:] [Type of region.]]

[[Throws:] [Yes.]]

]

[h4 Region member function `SetProtect`]

  DWORD SetProtect(DWORD Protect) const;

[variablelist

[[Effects:] [Sets protection of region to `Protect`.]]

[[Returns:] [Previous protection of region.]]

[[Throws:] [Yes.]]

]

[h4 Region member function `Dump`]

  void Dump(std::wstring const& Path) const;

[variablelist

[[Effects:] [Dump contents of memory region to binary file specified by 
`Path`.]]

[[Throws:] [Yes.]]

]

[h4 Region equality operator]

  bool operator==(Region const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same region.]]

[[Throws:] [No.]]

]

[h4 Region inequality operator]

  bool operator!=(Region const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different region.]]

[[Throws:] [No.]]

]

[h3 RegionList public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `RegionList` methods when an error occurs.

  typedef unspecified iterator;
  typedef unspecified const_iterator;
  
Iterator type for region list. Models the 
[@http://www.sgi.com/tech/stl/ForwardIterator.html ForwardIterator] concept. 
Implementation type unspecified.

[h3 RegionList public construct/copy/destruct/move]

[h4 RegionList constructor]

  explicit RegionList(MemoryMgr const& MyMemory);

[variablelist

[[Effects:] [Constructs a `RegionList` instance targetting the process 
specified by `MyMemory`.]]

[[Throws:] [Yes.]]

]

[h4 RegionList move constructor]

  RegionList(RegionList&& Other);

[variablelist

[[Effects:] [Constructs a `RegionList` that refers to the same region list as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 RegionList move assignment operator]

  RegionList& operator=(RegionList&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same region list as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 RegionList destructor]

  ~RegionList();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 RegionList public member functions]

[h4 RegionList member function `begin`]

  iterator begin();
  const_iterator begin() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for start of region 
list.]]

[[Throws:] [Yes.]]

]

[h4 RegionList member function `end`]

  iterator end();
  const_iterator end() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for off-the-end of 
region list.]]

[[Throws:] [Yes.]]

]

[h4 RegionList member function `cbegin`]

  const_iterator cbegin() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for start of region list.]]

[[Throws:] [Yes.]]

]

[h4 RegionList member function `cend`]

  const_iterator cend() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for off-the-end of region list.]]

[[Throws:] [Yes.]]

]

[endsect] [/ Region]

[section:findpattern FindPattern]

[h3 Synopsis]

  // In header: <HadesMemory/FindPattern.hpp>
  
  class FindPattern
  {
  public:
    friend class Pattern;
    
    class Error : public virtual HadesMemError 
    { };
    
    explicit FindPattern(MemoryMgr const& MyMemory, 
      HMODULE Module = nullptr);
    
    FindPattern(FindPattern const& Other);
    
    FindPattern& operator=(FindPattern const& Other);
    
    FindPattern(FindPattern&& Other);
    
    FindPattern& operator=(FindPattern&& Other);
    
    ~FindPattern();
    
    enum FindFlags
    {
      FindFlags_None = 0, 
      FindFlags_ThrowOnUnmatch = 1, 
      FindFlags_RelativeAddress = 2, 
      FindFlags_ScanData = 4
    };
    
    PVOID Find(std::wstring const& Data, FindFlags Flags = 
      FindFlags_None) const;
    
    PVOID Find(std::wstring const& Data, std::wstring const& Name, 
      FindFlags Flags = FindFlags_None);
    
    std::map<std::wstring, PVOID> GetAddresses() const;
    
    PVOID operator[](std::wstring const& Name) const;
    
    void LoadFile(std::wstring const& Path);
    
    void LoadFileMemory(std::wstring const& Data);
    
    bool operator==(FindPattern const& Rhs) const;
    
    bool operator!=(FindPattern const& Rhs) const;
  };
  
  class Pattern
  {
  public:
    Pattern(FindPattern& Finder, std::wstring const& Data, 
      std::wstring const& Name, FindPattern::FindFlags Flags = 
      FindPattern::FindFlags_None);
    
    Pattern(FindPattern& Finder, std::wstring const& Data, 
      FindPattern::FindFlags Flags = FindPattern::FindFlags_None);
    
    Pattern(Pattern&& Other);
    
    Pattern& operator=(Pattern&& Other);
    
    ~Pattern();
    
    void Save();
    
    void Update(PBYTE Address);
    
    PBYTE GetAddress() const;
    
    MemoryMgr GetMemory() const;
    
    FindPattern::FindFlags GetFlags() const;
    
    DWORD_PTR GetBase() const;
  };
  
  namespace PatternManipulators
  {
    class Manipulator
    {
    public:
      virtual void Manipulate(Pattern& /*Pat*/) const;
      
      friend Pattern& operator<< (Pattern& Pat, 
        Manipulator const& Manip);
    };
    
    class Save : public Manipulator
    {
    public:
      virtual void Manipulate(Pattern& Pat) const;
    };
    
    class Add : public Manipulator
    {
    public:
      explicit Add(DWORD_PTR Offset);
      
      virtual void Manipulate(Pattern& Pat) const;
    };
    
    class Sub : public Manipulator
    {
    public:
      explicit Sub(DWORD_PTR Offset);
      
      virtual void Manipulate(Pattern& Pat) const;
    };
    
    class Lea : public Manipulator
    {
    public:
      virtual void Manipulate(Pattern& Pat) const;
    };
    
    class Rel : public Manipulator
    {
    public:
      Rel(DWORD_PTR Size, DWORD_PTR Offset);
      
      virtual void Manipulate(Pattern& Pat) const;
    };
  }

[h3 Description]

The FindPattern class pattern scanning functionality, both 'manually' and from 
a pattern file (either in memory or on disk).

The Pattern class represents a single pattern, and is a wrapper around the 
FindPattern functionality. It also proivdes support for `manually` finding 
more complex patterns which require manipulators (manipulators are also 
available in pattern files). Manipulators have an overloaded output stream 
operator to facilitate manipulator chaining.

The PatternManipulators namespace contains all pattern manipulators. Supported 
manipulators are:
Save, Add, Sub, Lea, Rel.

Patterns are of the format:
``
HadesMem Patterns (Flags)
{ Name1, Data1|WildCard1, Data2|WildCard2, ... DataN|WildCardN }
[ Manipulator1, Arg1, Arg2, ..., ArgN ]
[ Manipulator2, Arg1, Arg2, ..., ArgN ]
{ Name2, Data1|WildCard1, Data2|WildCard2, ... DataN|WildCardN }
[ Manipulator1, Arg1, Arg2, ..., ArgN ]
[ Manipulator2, Arg1, Arg2, ..., ArgN ]
``

Example:
``
HadesMem Patterns (RelativeAddress, ThrowOnUnmatch)
{ First Call, E8 }
[ Add, 1 ]
[ Rel, 5, 1 ]
{ Zeros New, 00 ?? 00 }
[ Add, 1 ]
[ Sub, 1 ]
{ Nop Other, 90 }
``

[h3 FindPattern public types]

  class Error : public virtual HadesMemError;

Exception type thrown by `FindPattern` methods when an error occurs.

  enum FindFlags;

Calling conventions for remote function caller. All calling conventions follow 
Microsoft specifications. Other compilers and custom calling conventions are 
currently unsupported.

* FindFlags_None - No flags.
* FindFlags_ThrowOnUnmatch - Throw an exception when a match can't be found.
* FindFlags_RelativeAddress - Resolve patterns to relative addresses.
* FindFlags_ScanData - Scan the data section(s) of the target, instead of the 
code section(s).

[h3 FindPattern public construct/copy/destruct/move]

[h4 FindPattern constructor]

  explicit FindPattern(MemoryMgr const& MyMemory, HMODULE Module = nullptr);

[variablelist

[[Effects:] [Constructs a `FindPattern` instance that refers to the specified 
process and module (a null module handle means the owner process).]]

[[Throws:] [Yes.]]

]

[h4 FindPattern copy constructor]

  FindPattern(FindPattern const& Other);

[variablelist

[[Effects:] [Constructs a `FindPattern` that refers to the same process as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 FindPattern copy assignment operator]

  FindPattern& operator=(FindPattern const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 FindPattern move constructor]

  FindPattern(FindPattern&& Other);

[variablelist

[[Effects:] [Constructs a `FindPattern` that refers to the same process as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 FindPattern move assignment operator]

  FindPattern& operator=(FindPattern&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same process as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 FindPattern destructor]

  ~FindPattern();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 FindPattern public member functions]

[h4 FindPattern member function `Find`]

  PVOID Find(std::wstring const& Data, FindFlags Flags = 
    FindFlags_None) const;

  PVOID Find(std::wstring const& Data, std::wstring const& Name, 
    FindFlags Flags = FindFlags_None);

[variablelist

[[Effects:] [Attempts to find a match for pattern `Data`, with scan flags 
`Flags`. If specified, adds returned address to internal cache under name 
`Name`.]]

[[Returns:] [Address of matched pattern, or null of not found.]]

[[Throws:] [Yes.]]

[[Notes:] [`Data` must be of the format "XX XX ?? XX XX ??" where XX are hex 
bytes, and '??' is a wildcard. Each hex byte or wildcard is separated by a 
space.]]

]

[h4 FindPattern member function `GetAddresses`]

  std::map<std::wstring, PVOID> GetAddresses() const;

[variablelist

[[Returns:] [Copy of internal address 'cache' (name to pointer lookup).]]

[[Throws:] [Yes.]]

]

[h4 FindPattern subscript operator]

  PVOID operator[](std::wstring const& Name) const;

[variablelist

[[Returns:] [Address of pattern match with name `Name`.]]

[[Throws:] [Yes.]]

]

[h4 FindPattern member function `LoadFile`]

  void LoadFile(std::wstring const& Path);

[variablelist

[[Effects:] [Loads pattern file from `Path` and processes it.]]

[[Throws:] [Yes.]]

[[Notes:] [Pattern file must be of format described in the overview.]]

]

[h4 FindPattern member function `WriteString`]

  void LoadFileMemory(std::wstring const& Data);

[variablelist

[[Effects:] [Loads pattern file from memory and processes it.]]

[[Throws:] [Yes.]]

[[Notes:] [Pattern file must be of format described in the overview.]]

]

[h4 FindPattern equality operator]

  bool operator==(FindPattern const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same instance.]]

[[Throws:] [No.]]

]

[h4 FindPattern inequality operator]

  bool operator!=(FindPattern const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different instance.]]

[[Throws:] [No.]]

]

[h3 Pattern public construct/copy/destruct/move]

[h4 Pattern constructor]

  Pattern(FindPattern& Finder, std::wstring const& Data, 
    std::wstring const& Name, FindPattern::FindFlags Flags = 
    FindPattern::FindFlags_None);

[variablelist

[[Effects:] [Wrapper around `FindPattern::Find`.]]

[[Throws:] [Yes.]]

]

[h4 Pattern name constructor]

  Pattern(FindPattern& Finder, std::wstring const& Data, 
    FindPattern::FindFlags Flags = FindPattern::FindFlags_None);

[variablelist

[[Effects:] [Wrapper around `FindPattern::Find`.]]

[[Throws:] [Yes.]]

]

[h4 Pattern move constructor]

  Pattern(Pattern&& Other);

[variablelist

[[Effects:] [Constructs a `Pattern` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Pattern move assignment operator]

  Pattern& operator=(Pattern&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Pattern destructor]

  ~Pattern();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 Pattern public member functions]

[h4 Pattern member function `Save`]

  void Save();

[variablelist

[[Effects:] [Saves pattern back to parent.]]

[[Throws:] [Yes.]]

]

[h4 Pattern member function `Update`]

  void Update(PBYTE Address);

[variablelist

[[Effects:] [Updates pattern with new address `Address`.]]

[[Throws:] [Yes.]]

]

[h4 Pattern member function `GetAddress`]

  PBYTE GetAddress() const;

[variablelist

[[Returns:] [Address of matched pattern.]]

[[Throws:] [No.]]

]

[h4 Pattern member function `GetMemory`]

  MemoryMgr GetMemory() const;

[variablelist

[[Returns:] [Memory manager instance.]]

[[Throws:] [No.]]

]

[h4 Pattern member function `GetFlags`]

  FindPattern::FindFlags GetFlags() const;

[variablelist

[[Returns:] [Scanning flags.]]

[[Throws:] [No.]]

]

[h4 Pattern member function `GetBase`]

  DWORD_PTR GetBase() const;

[variablelist

[[Returns:] [Base address of target module.]]

[[Throws:] [No.]]

]

[endsect] [/ FindPattern]

[endsect] [/ Core]

[section:pelib PeLib]

[section:dosheader DosHeader]

[h3 Synopsis]

  // In header: <HadesMemory/PeLib/DosHeader.hpp>

  class DosHeader
  {
  public:
    class Error : public virtual HadesMemError;

    explicit DosHeader(PeFile const& MyPeFile);
      
    DosHeader(DosHeader const& Other);
    
    DosHeader& operator=(DosHeader const& Other);
    
    DosHeader(DosHeader&& Other);
    
    DosHeader& operator=(DosHeader&& Other);
    
    ~DosHeader();
    
    PVOID GetBase() const;

    bool IsMagicValid() const;

    void EnsureMagicValid() const;

    WORD GetMagic() const;

    WORD GetBytesOnLastPage() const;

    WORD GetPagesInFile() const;

    WORD GetRelocations() const;

    WORD GetSizeOfHeaderInParagraphs() const;

    WORD GetMinExtraParagraphs() const;

    WORD GetMaxExtraParagraphs() const;

    WORD GetInitialSS() const;

    WORD GetInitialSP() const;

    WORD GetChecksum() const;

    WORD GetInitialIP() const;

    WORD GetInitialCS() const;

    WORD GetRelocTableFileAddr() const;

    WORD GetOverlayNum() const;

    std::array<WORD, 4> GetReservedWords1() const;

    WORD GetOEMID() const;

    WORD GetOEMInfo() const;

    std::array<WORD, 10> GetReservedWords2() const;

    LONG GetNewHeaderOffset() const;

    void SetMagic(WORD Magic) const;

    void SetBytesOnLastPage(WORD BytesOnLastPage) const;

    void SetPagesInFile(WORD PagesInFile) const;

    void SetRelocations(WORD Relocations) const;

    void SetSizeOfHeaderInParagraphs(WORD SizeOfHeaderInParagraphs) const;

    void SetMinExtraParagraphs(WORD MinExtraParagraphs) const;

    void SetMaxExtraParagraphs(WORD MaxExtraParagraphs) const;

    void SetInitialSS(WORD InitialSS) const;

    void SetInitialSP(WORD InitialSP) const;

    void SetChecksum(WORD Checksum) const;

    void SetInitialIP(WORD InitialIP) const;

    void SetInitialCS(WORD InitialCS) const;

    void SetRelocTableFileAddr(WORD RelocTableFileAddr) const;

    void SetOverlayNum(WORD OverlayNum) const;

    void SetReservedWords1(std::array<WORD, 4> const& ReservedWords1) const;

    void SetOEMID(WORD OEMID) const;

    void SetOEMInfo(WORD OEMInfo) const;

    void SetReservedWords2(std::array<WORD, 10> const& ReservedWords2) const;

    void SetNewHeaderOffset(LONG Offset) const;
    
    bool operator==(DosHeader const& Rhs) const;
    
    bool operator!=(DosHeader const& Rhs) const;
  };

[h3 Description]

The `DosHeader` class provides functionality for working with the DOS header 
of a PE file.

See the [@http://msdn.microsoft.com/en-us/windows/hardware/gg463119 PE and 
COFF Specification] for more information on working with the PE file format.

[h3 DosHeader public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `DosHeader` methods when an error occurs.

[h3 DosHeader public construct/copy/destruct/move]

[h4 DosHeader constructor]

  DosHeader(PeFile const& MyPeFile);

[variablelist

[[Effects:] [Constructs a `DosHeader` instance that refers to the specified 
PE file.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader copy constructor]

  DosHeader(DosHeader const& Other);

[variablelist

[[Effects:] [Constructs a `DosHeader` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader copy assignment operator]

  DosHeader& operator=(DosHeader const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader move constructor]

  DosHeader(DosHeader&& Other);

[variablelist

[[Effects:] [Constructs a `DosHeader` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader move assignment operator]

  DosHeader& operator=(DosHeader&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader destructor]

  ~DosHeader();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 DosHeader public member functions]

[h4 DosHeader member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of DOS header.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `IsValid`]

  bool IsValid() const;

[variablelist

[[Returns:] [Whether the target is a valid DOS header.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `EnsureValid`]

  void EnsureValid() const;

[variablelist

[[Effects:] [Throw if the target is an invalid DOS header.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetMagic`]

  WORD GetMagic() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_magic.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetBytesOnLastPage`]

  WORD GetBytesOnLastPage() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_cblp.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetPagesInFile`]

  WORD GetPagesInFile() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_cp.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetRelocations`]

  WORD GetRelocations() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_crlc.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetSizeOfHeaderInParagraphs`]

  WORD GetSizeOfHeaderInParagraphs() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_cparhdr.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetMinExtraParagraphs`]

  WORD GetMinExtraParagraphs() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_minalloc.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetMaxExtraParagraphs`]

  WORD GetMaxExtraParagraphs() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_maxalloc.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetInitialSS`]

  WORD GetInitialSS() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_ss.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetInitialSP`]

  WORD GetInitialSP() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_sp.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetChecksum`]

  WORD GetChecksum() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_csum.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetInitialIP`]

  WORD GetInitialIP() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_ip.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetInitialCS`]

  WORD GetInitialCS() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_cs.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetRelocTableFileAddr`]

  WORD GetRelocTableFileAddr() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_lfarlc.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetOverlayNum`]

  WORD GetOverlayNum() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_ovno.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetReservedWords1`]

  std::array<WORD, 4> GetReservedWords1() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_res.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetOEMID`]

  WORD GetOEMID() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_oemid.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetOEMInfo`]

  WORD GetOEMInfo() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_oeminfo.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetReservedWords2`]

  std::array<WORD, 10> GetReservedWords2() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_res2.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `GetNewHeaderOffset`]

  LONG GetNewHeaderOffset() const;

[variablelist

[[Returns:] [IMAGE_DOS_HEADER.e_lfanew.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetMagic`]

  void SetMagic(WORD Magic) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_magic.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetBytesOnLastPage`]

  void SetBytesOnLastPage(WORD BytesOnLastPage) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_cblp.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetPagesInFile`]

  void SetPagesInFile(WORD PagesInFile) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_cp.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetRelocations`]

  void SetRelocations(WORD Relocations) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_crlc.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetSizeOfHeaderInParagraphs`]

  void SetSizeOfHeaderInParagraphs(WORD SizeOfHeaderInParagraphs) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_cparhdr.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetMinExtraParagraphs`]

  void SetMinExtraParagraphs(WORD MinExtraParagraphs) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_minalloc.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetMaxExtraParagraphs`]

  void SetMaxExtraParagraphs(WORD MaxExtraParagraphs) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_maxalloc.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetInitialSS`]

  void SetInitialSS(WORD InitialSS) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_ss.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetInitialSP`]

  void SetInitialSP(WORD InitialSP) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_sp.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetChecksum`]

  void SetChecksum(WORD Checksum) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_csum.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetInitialIP`]

  void SetInitialIP(WORD InitialIP) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_ip.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetInitialCS`]

  void SetInitialCS(WORD InitialCS) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_cs.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetRelocTableFileAddr`]

  void SetRelocTableFileAddr(WORD RelocTableFileAddr) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_lfarlc.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetOverlayNum`]

  void SetOverlayNum(WORD OverlayNum) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_ovno.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetReservedWords1`]

  void SetReservedWords1(std::array<WORD, 4> const& ReservedWords1) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_res.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetOEMID`]

  void SetOEMID(WORD OEMID) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_oemid.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetOEMInfo`]

  void SetOEMInfo(WORD OEMInfo) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_oeminfo.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetReservedWords2`]

  void SetReservedWords2(std::array<WORD, 10> const& ReservedWords2) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_res2.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader member function `SetNewHeaderOffset`]

  void SetNewHeaderOffset(LONG Offset) const;

[variablelist

[[Effects:] [Sets IMAGE_DOS_HEADER.e_lfanew.]]

[[Throws:] [Yes.]]

]

[h4 DosHeader equality operator]

  bool operator==(DosHeader const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same target.]]

[[Throws:] [No.]]

]

[h4 DosHeader inequality operator]

  bool operator!=(DosHeader const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different target.]]

[[Throws:] [No.]]

]

[endsect] [/ DosHeader]

[section:exportdir ExportDir]

[h3 Synopsis]

  // In header: <HadesMemory/PeLib/ExportDir.hpp>

  class ExportDir
  {
  public:
    class Error : public virtual HadesMemError;

    explicit ExportDir(PeFile const& MyPeFile);
      
    ExportDir(ExportDir const& Other);
    
    ExportDir& operator=(ExportDir const& Other);
    
    ExportDir(ExportDir&& Other);
    
    ExportDir& operator=(ExportDir&& Other);
    
    ~ExportDir();

    PVOID GetBase() const;

    bool IsValid() const;

    void EnsureValid() const;

    DWORD GetCharacteristics() const;

    DWORD GetTimeDateStamp() const;

    WORD GetMajorVersion() const;

    WORD GetMinorVersion() const;

    std::string GetName() const;

    DWORD GetOrdinalBase() const;

    DWORD GetNumberOfFunctions() const;

    DWORD GetNumberOfNames() const;

    DWORD GetAddressOfFunctions() const;

    DWORD GetAddressOfNames() const;

    DWORD GetAddressOfNameOrdinals() const;

    void SetCharacteristics(DWORD Characteristics) const;

    void SetTimeDateStamp(DWORD TimeDateStamp) const;

    void SetMajorVersion(WORD MajorVersion) const;

    void SetMinorVersion(WORD MinorVersion) const;

    void SetOrdinalBase(DWORD OrdinalBase) const;

    void SetNumberOfFunctions(DWORD NumberOfFunctions) const;

    void SetNumberOfNames(DWORD NumberOfNames) const;

    void SetAddressOfFunctions(DWORD AddressOfFunctions) const;

    void SetAddressOfNames(DWORD AddressOfNames) const;

    void SetAddressOfNameOrdinals(DWORD AddressOfNameOrdinals) const;
    
    bool operator==(ExportDir const& Rhs) const;
    
    bool operator!=(ExportDir const& Rhs) const;
  };

  class Export
  {
  public:
    Export(PeFile const& MyPeFile, DWORD Ordinal);
      
    Export(Export const& Other);
    
    Export& operator=(Export const& Other);
    
    Export(Export&& Other);
    
    Export& operator=(Export&& Other);
    
    ~Export();

    DWORD GetRva() const;

    PVOID GetVa() const;

    std::string GetName() const;

    WORD GetOrdinal() const;

    bool ByName() const;

    bool Forwarded() const;

    std::string GetForwarder() const;
    
    std::string GetForwarderModule() const;
    
    std::string GetForwarderFunction() const;
    
    bool IsForwardedByOrdinal() const;
    
    WORD GetForwarderOrdinal() const;
    
    bool operator==(Export const& Rhs) const;
    
    bool operator!=(Export const& Rhs) const;
  };
  
  class ExportList
  {
  public:
    class Error : public virtual HadesMemError;
    
    typedef unspecified iterator;
    typedef unspecified const_iterator;
    
    explicit ExportList(PeFile const& MyPeFile);
    
    ExportList(ExportList&& Other);
    
    ExportList& operator=(ExportList&& Other);
    
    iterator begin();
    
    iterator end();
    
    const_iterator begin() const;
     
    const_iterator end() const;
    
    const_iterator cbegin() const;
     
    const_iterator cend() const;
  };

[h3 Description]

The `ExportDir` and `Export` classes provide functionality for working with 
the export directory of a PE file.

See the [@http://msdn.microsoft.com/en-us/windows/hardware/gg463119 PE and 
COFF Specification] for more information on working with the PE file format.

The `ExportList` class provides STL-compatible iterators for export 
enumeration.

[h3 ExportDir public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `ExportDir` methods when an error occurs.

[h3 ExportDir public construct/copy/destruct/move]

[h4 ExportDir constructor]

  ExportDir(PeFile const& MyPeFile);

[variablelist

[[Effects:] [Constructs an `ExportDir` instance that refers to the specified 
PE file.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir copy constructor]

  ExportDir(ExportDir const& Other);

[variablelist

[[Effects:] [Constructs an `ExportDir` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir copy assignment operator]

  ExportDir& operator=(ExportDir const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir move constructor]

  ExportDir(ExportDir&& Other);

[variablelist

[[Effects:] [Constructs an `ExportDir` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir move assignment operator]

  ExportDir& operator=(ExportDir&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir destructor]

  ~ExportDir();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 ExportDir public member functions]

[h4 ExportDir member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of export directory.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `IsValid`]

  bool IsValid() const;

[variablelist

[[Returns:] [Whether the target is a valid export dir.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `EnsureValid`]

  void EnsureValid() const;

[variablelist

[[Effects:] [Throw if the target is an invalid export dir.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetCharacteristics`]

  DWORD GetCharacteristics() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetTimeDateStamp`]

  DWORD GetTimeDateStamp() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.TimeDateStamp.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetMajorVersion`]

  WORD GetMajorVersion() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.MajorVersion.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetMinorVersion`]

  WORD GetMinorVersion() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.MinorVersion.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetName`]

  std::string GetName() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.Name.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetOrdinalBase`]

  DWORD GetOrdinalBase() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.Base.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetNumberOfFunctions`]

  DWORD GetNumberOfFunctions() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.NumberOfFunctions.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetNumberOfNames`]

  DWORD GetNumberOfNames() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.NumberOfNames.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetAddressOfFunctions`]

  DWORD GetAddressOfFunctions() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.AddressOfFunctions.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetAddressOfNames`]

  DWORD GetAddressOfNames() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.AddressOfNames.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `GetAddressOfNameOrdinals`]

  DWORD GetAddressOfNameOrdinals() const;

[variablelist

[[Returns:] [IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetCharacteristics`]

  void SetCharacteristics(DWORD Characteristics) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetTimeDateStamp`]

  void SetTimeDateStamp(DWORD TimeDateStamp) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.TimeDateStamp.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetMajorVersion`]

  void SetMajorVersion(WORD MajorVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.MajorVersion.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetMinorVersion`]

  void SetMinorVersion(WORD MinorVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.MinorVersion.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetName`]

  void SetName(std::string const& Name) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.Name.]]

[[Notes:] [Length of new name must be equal to or less than the length of the 
current name. Allocating space for a new string in the file is currently 
unsupported.]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetOrdinalBase`]

  void SetOrdinalBase(DWORD OrdinalBase) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.Base.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetNumberOfFunctions`]

  void SetNumberOfFunctions(DWORD NumberOfFunctions) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.NumberOfFunctions.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetNumberOfNames`]

  void SetNumberOfNames(DWORD NumberOfNames) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.NumberOfNames.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetAddressOfFunctions`]

  void SetAddressOfFunctions(DWORD AddressOfFunctions) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.AddressOfFunctions.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetAddressOfNames`]

  void SetAddressOfNames(DWORD AddressOfNames) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.AddressOfNames.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir member function `SetAddressOfNameOrdinals`]

  void SetAddressOfNameOrdinals(DWORD AddressOfNameOrdinals) const;

[variablelist

[[Effects:] [Sets IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals.]]

[[Throws:] [Yes.]]

]

[h4 ExportDir equality operator]

  bool operator==(ExportDir const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same export dir.]]

[[Throws:] [No.]]

]

[h4 ExportDir inequality operator]

  bool operator!=(ExportDir const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different export dir.]]

[[Throws:] [No.]]

]

[h3 Export public construct/copy/destruct/move]

[h4 Export ordinal constructor]

  Export(PeFile const& MyPeFile, DWORD Ordinal);

[variablelist

[[Effects:] [Constructs an `ExportDir` instance that refers to the specified 
PE file and ordinal.]]

[[Throws:] [Yes.]]

]

[h4 Export name constructor]

  Export(PeFile const& MyPeFile, std::string const& Name);

[variablelist

[[Effects:] [Constructs an `ExportDir` instance that refers to the specified 
PE file and name.]]

[[Throws:] [Yes.]]

]

[h4 Export copy constructor]

  Export(Export const& Other);

[variablelist

[[Effects:] [Constructs an `Export` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 Export copy assignment operator]

  Export& operator=(Export const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 Export move constructor]

  Export(Export&& Other);

[variablelist

[[Effects:] [Constructs an `Export` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Export move assignment operator]

  Export& operator=(Export&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Export destructor]

  ~Export();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 Export public member functions]

[h4 Export member function `GetRva`]

  DWORD GetRva() const;

[variablelist

[[Returns:] [RVA of export.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `GetVa`]

  PVOID GetVa() const;

[variablelist

[[Returns:] [VA of export.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `GetName`]

  std::string GetName() const;

[variablelist

[[Returns:] [Name of export.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `GetOrdinal`]

  WORD GetOrdinal() const;

[variablelist

[[Returns:] [Ordinal of export.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `ByName`]

  bool ByName() const;

[variablelist

[[Returns:] [Whether entry is exported by name.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `Forwarded`]

  bool Forwarded() const;

[variablelist

[[Returns:] [Whether entry is forwarded.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `GetForwarder`]

  std::string GetForwarder() const;

[variablelist

[[Returns:] [Full unprocessed forwarder of export.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `GetForwarderModule`]

  std::string GetForwarderModule() const;

[variablelist

[[Returns:] [Name part of export forwarder.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `GetForwarderFunction`]

  std::string GetForwarderFunction() const;

[variablelist

[[Returns:] [Function part of export forwarder.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `IsForwardedByOrdinal`]

  bool IsForwardedByOrdinal() const;

[variablelist

[[Returns:] [Whether entry is forwarded by ordinal.]]

[[Throws:] [Yes.]]

]

[h4 Export member function `GetForwarderOrdinal`]

  WORD GetForwarderOrdinal() const;

[variablelist

[[Returns:] [Ordinal for forwarder.]]

[[Throws:] [Yes.]]

]

[h4 Export equality operator]

  bool operator==(Export const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same export.]]

[[Throws:] [No.]]

]

[h4 Export inequality operator]

  bool operator!=(Export const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different export.]]

[[Throws:] [No.]]

]

[h3 ExportList public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `ExportList` methods when an error occurs.

  typedef unspecified iterator;
  typedef unspecified const_iterator;
  
Iterator type for export list. Models the 
[@http://www.sgi.com/tech/stl/ForwardIterator.html ForwardIterator] concept. 
Implementation type unspecified.

[h3 ExportList public construct/copy/destruct/move]

[h4 ExportList constructor]

  explicit ExportList(PeFile const& MyPeFile);

[variablelist

[[Effects:] [Constructs a `ExportList` instance targetting the PE file 
specified by `MyPeFile`.]]

[[Throws:] [Yes.]]

]

[h4 ExportList move constructor]

  ExportList(ExportList&& Other);

[variablelist

[[Effects:] [Constructs a `ExportList` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ExportList move assignment operator]

  ExportList& operator=(ExportList&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ExportList destructor]

  ~ExportList();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 ExportList public member functions]

[h4 ExportList member function `begin`]

  iterator begin();
  const_iterator begin() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for start of export 
list.]]

[[Throws:] [Yes.]]

]

[h4 ExportList member function `end`]

  iterator end();
  const_iterator end() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for off-the-end of 
export list.]]

[[Throws:] [Yes.]]

]

[h4 ExportList member function `cbegin`]

  const_iterator cbegin() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for start of export list.]]

[[Throws:] [Yes.]]

]

[h4 ExportList member function `cend`]

  const_iterator cend() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for off-the-end of export list.]]

[[Throws:] [Yes.]]

]

[endsect] [/ ExportDir]

[section:importdir ImportDir]

[h3 Synopsis]

  // In header: <HadesMemory/PeLib/ImportDir.hpp>
  
  class ImportDir
  {
  public:
    class Error : public virtual HadesMemError
    { };

    explicit ImportDir(PeFile const& MyPeFile, 
      PIMAGE_IMPORT_DESCRIPTOR pImpDesc = nullptr);
      
    ImportDir(ImportDir const& Other);
    
    ImportDir& operator=(ImportDir const& Other);
    
    ImportDir(ImportDir&& Other);
    
    ImportDir& operator=(ImportDir&& Other);
    
    ~ImportDir();

    PVOID GetBase() const;

    bool IsValid() const;

    void EnsureValid() const;

    DWORD GetCharacteristics() const;

    DWORD GetTimeDateStamp() const;

    DWORD GetForwarderChain() const;

    DWORD GetNameRaw() const;

    std::string GetName() const;

    DWORD GetFirstThunk() const;

    void SetCharacteristics(DWORD Characteristics) const;

    void SetTimeDateStamp(DWORD TimeDateStamp) const;

    void SetForwarderChain(DWORD ForwarderChain) const;

    void SetNameRaw(DWORD Name) const;
    
    void SetName(std::string const& Name) const;

    void SetFirstThunk(DWORD FirstThunk) const;
    
    bool operator==(ImportDir const& Rhs) const;
    
    bool operator!=(ImportDir const& Rhs) const;
  };
    
  class ImportDirList
  {
  public:
    class Error : public virtual HadesMemError;
    
    typedef unspecified iterator;
    typedef unspecified const_iterator;
    
    explicit ImportDirList(PeFile const& MyPeFile);
    
    ImportDirList(ImportDirList&& Other);
    
    ImportDirList& operator=(ImportDirList&& Other);
    
    iterator begin();
    
    iterator end();
    
    const_iterator begin() const;
     
    const_iterator end() const;
    
    const_iterator cbegin() const;
     
    const_iterator cend() const;
  };
  
  class ImportThunk
  {
  public:
    class Error : public virtual HadesMemError;

    ImportThunk(PeFile const& MyPeFile, PVOID pThunk);
      
    ImportThunk(ImportThunk const& Other);
    
    ImportThunk& operator=(ImportThunk const& Other);
    
    ImportThunk(ImportThunk&& Other);
    
    ImportThunk& operator=(ImportThunk&& Other);
    
    ~ImportThunk();
    
    PVOID GetBase() const;

    bool IsValid() const;

    void EnsureValid() const;

    DWORD_PTR GetAddressOfData() const;

    DWORD_PTR GetOrdinalRaw() const;
    
    bool ByOrdinal() const;

    WORD GetOrdinal() const;

    DWORD_PTR GetFunction() const;

    WORD GetHint() const;

    std::string GetName() const;

    void SetAddressOfData(DWORD_PTR AddressOfData) const;

    void SetOrdinalRaw(DWORD_PTR OrdinalRaw) const;
    
    void SetFunction(DWORD_PTR Function) const;

    void SetHint(WORD Hint) const;
    
    bool operator==(ImportThunk const& Rhs) const;
    
    bool operator!=(ImportThunk const& Rhs) const;
  };
  
  class ImportThunkList
  {
  public:
    class Error : public virtual HadesMemError;
    
    typedef unspecified iterator;
    typedef unspecified const_iterator;
    
    explicit ImportThunkList(PeFile const& MyPeFile, DWORD FirstThunk);
    
    ImportThunkList(ImportThunkList&& Other);
    
    ImportThunkList& operator=(ImportThunkList&& Other);
    
    iterator begin();
    
    iterator end();
    
    const_iterator begin() const;
     
    const_iterator end() const;
    
    const_iterator cbegin() const;

    const_iterator cend() const;
  };

[h3 Description]

The `ImportDir` and `ImportThunk` classes provide functionality for working 
with the import directory of a PE file.

See the [@http://msdn.microsoft.com/en-us/windows/hardware/gg463119 PE and 
COFF Specification] for more information on working with the PE file format.

The `ImportDirList` class provides STL-compatible iterators for import 
directory  enumeration. The `ImportThunkList` class provides STL-compatible 
iterators for import thunk enumeration.

[h3 ImportDir public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `ImportDir` methods when an error occurs.

[h3 ImportDir public construct/copy/destruct/move]

[h4 ImportDir constructor]

  ImportDir(PeFile const& MyPeFile, PIMAGE_IMPORT_DESCRIPTOR pImpDesc = 
    nullptr);

[variablelist

[[Effects:] [Constructs an `ImportDir` instance that refers to the specified 
PE file, and optionally, the specified import descriptor (or the first one in 
the list by default).]]

[[Throws:] [Yes.]]

]

[h4 ImportDir copy constructor]

  ImportDir(ImportDir const& Other);

[variablelist

[[Effects:] [Constructs an `ImportDir` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir copy assignment operator]

  ImportDir& operator=(ImportDir const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir move constructor]

  ImportDir(ImportDir&& Other);

[variablelist

[[Effects:] [Constructs an `ImportDir` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir move assignment operator]

  ImportDir& operator=(ImportDir&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir destructor]

  ~ImportDir();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 ImportDir public member functions]

[h4 ImportDir member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of import directory.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `IsValid`]

  bool IsValid() const;

[variablelist

[[Returns:] [Whether the target is a valid import dir.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `EnsureValid`]

  void EnsureValid() const;

[variablelist

[[Effects:] [Throw if the target is an invalid import dir.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `GetCharacteristics`]

  DWORD GetCharacteristics() const;

[variablelist

[[Returns:] [IMAGE_IMPORT_DESCRIPTOR.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `GetTimeDateStamp`]

  DWORD GetTimeDateStamp() const;

[variablelist

[[Returns:] [IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `GetForwarderChain`]

  DWORD GetForwarderChain() const;

[variablelist

[[Returns:] [IMAGE_IMPORT_DESCRIPTOR.ForwarderChain.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `GetNameRaw`]

  DWORD GetNameRaw() const;

[variablelist

[[Returns:] [IMAGE_IMPORT_DESCRIPTOR.Name.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `GetName`]

  std::string GetName() const;

[variablelist

[[Returns:] [IMAGE_IMPORT_DESCRIPTOR.Name.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `GetFirstThunk`]

  DWORD GetFirstThunk() const;

[variablelist

[[Returns:] [IMAGE_IMPORT_DESCRIPTOR.FirstThunk.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `SetCharacteristics`]

  void SetCharacteristics(DWORD Characteristics) const;

[variablelist

[[Effects:] [Sets IMAGE_IMPORT_DESCRIPTOR.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `SetTimeDateStamp`]

  void SetTimeDateStamp(DWORD TimeDateStamp) const;

[variablelist

[[Effects:] [Sets IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `SetForwarderChain`]

  void SetForwarderChain(DWORD ForwarderChain) const;

[variablelist

[[Effects:] [Sets IMAGE_IMPORT_DESCRIPTOR.ForwarderChain.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `SetNameRaw`]

  void SetNameRaw(DWORD Name) const;

[variablelist

[[Effects:] [Sets IMAGE_IMPORT_DESCRIPTOR.Name.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `SetName`]

  void SetName(std::string const& Name) const;

[variablelist

[[Effects:] [Sets IMAGE_IMPORT_DESCRIPTOR.Name.]]

[[Notes:] [Length of new name must be equal to or less than the length of the 
current name. Allocating space for a new string in the file is currently 
unsupported.]

[[Throws:] [Yes.]]

]

[h4 ImportDir member function `SetFirstThunk`]

  void SetFirstThunk(DWORD FirstThunk) const;

[variablelist

[[Effects:] [Sets IMAGE_IMPORT_DESCRIPTOR.FirstThunk.]]

[[Throws:] [Yes.]]

]

[h4 ImportDir equality operator]

  bool operator==(ImportDir const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same import dir.]]

[[Throws:] [No.]]

]

[h4 ImportDir inequality operator]

  bool operator!=(ImportDir const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different import dir.]]

[[Throws:] [No.]]

]

[h3 ImportDirList public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `ImportDirList` methods when an error occurs.

  typedef unspecified iterator;
  typedef unspecified const_iterator;
  
Iterator type for import dir list. Models the 
[@http://www.sgi.com/tech/stl/ForwardIterator.html ForwardIterator] concept. 
Implementation type unspecified.

[h3 ImportDirList public construct/copy/destruct/move]

[h4 ImportDirList constructor]

  explicit ImportDirList(PeFile const& MyPeFile);

[variablelist

[[Effects:] [Constructs a `ImportDirList` instance targetting the PE file 
specified by `MyPeFile`.]]

[[Throws:] [Yes.]]

]

[h4 ImportDirList move constructor]

  ImportDirList(ImportDirList&& Other);

[variablelist

[[Effects:] [Constructs a `ImportDirList` that refers to the same target 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportDirList move assignment operator]

  ImportDirList& operator=(ImportDirList&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportDirList destructor]

  ~ImportDirList();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 ImportDirList public member functions]

[h4 ImportDirList member function `begin`]

  iterator begin();
  const_iterator begin() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for start of import 
list.]]

[[Throws:] [Yes.]]

]

[h4 ImportDirList member function `end`]

  iterator end();
  const_iterator end() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for off-the-end of 
import dir list.]]

[[Throws:] [Yes.]]

]

[h4 ImportDirList member function `cbegin`]

  const_iterator cbegin() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for start of import dir list.]]

[[Throws:] [Yes.]]

]

[h4 ImportDirList member function `cend`]

  const_iterator cend() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for off-the-end of import dir list.]]

[[Throws:] [Yes.]]

]

[h3 ImportThunk public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `ImportThunk` methods when an error occurs.

[h3 ImportThunk public construct/copy/destruct/move]

[h4 ImportThunk constructor]

  ImportThunk(PeFile const& MyPeFile, PVOID pThunk);

[variablelist

[[Effects:] [Constructs an `ImportThunk` instance that refers to the specified 
import thunk in the specified PE file.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk copy constructor]

  ImportThunk(ImportThunk const& Other);

[variablelist

[[Effects:] [Constructs an `ImportThunk` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk copy assignment operator]

  ImportThunk& operator=(ImportThunk const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk move constructor]

  ImportThunk(ImportThunk&& Other);

[variablelist

[[Effects:] [Constructs an `ImportThunk` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk move assignment operator]

  ImportThunk& operator=(ImportThunk&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk destructor]

  ~ImportThunk();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 ImportThunk public member functions]

[h4 ImportThunk member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of import thunk.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `IsValid`]

  bool IsValid() const;

[variablelist

[[Returns:] [Whether the target is a valid import thunk.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `EnsureValid`]

  void EnsureValid() const;

[variablelist

[[Effects:] [Throw if the target is an invalid import thunk.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `GetAddressOfData`]

  DWORD_PTR GetAddressOfData() const;

[variablelist

[[Returns:] [IMAGE_THUNK_DATA.u1.AddressOfData.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `GetOrdinalRaw`]

  DWORD_PTR GetOrdinalRaw() const;

[variablelist

[[Returns:] [IMAGE_THUNK_DATA.u1.Ordinal.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `ByOrdinal`]

  bool ByOrdinal() const;

[variablelist

[[Returns:] [Whether import is by ordinal.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `GetOrdinal`]

  WORD GetOrdinal() const;

[variablelist

[[Returns:] [Ordinal portion of IMAGE_THUNK_DATA.u1.Ordinal.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `GetFunction`]

  DWORD_PTR GetFunction() const;

[variablelist

[[Returns:] [IMAGE_THUNK_DATA.u1.Function.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `GetHint`]

  WORD GetHint() const;

[variablelist

[[Returns:] [IMAGE_IMPORT_BY_NAME.Hint.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `GetName`]

  std::string GetName() const;

[variablelist

[[Returns:] [IMAGE_IMPORT_BY_NAME.Name.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `SetAddressOfData`]

  void SetAddressOfData(DWORD_PTR AddressOfData) const;

[variablelist

[[Effects:] [Sets IMAGE_THUNK_DATA.u1.AddressOfData.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `SetOrdinalRaw`]

  void SetOrdinalRaw(DWORD_PTR OrdinalRaw) const;

[variablelist

[[Effects:] [Sets IMAGE_THUNK_DATA.u1.Ordinal.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `SetFunction`]

  void SetFunction(DWORD_PTR Function) const;

[variablelist

[[Effects:] [Sets IMAGE_THUNK_DATA.u1.Function.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk member function `SetHint`]

  void SetHint(WORD Hint) const;

[variablelist

[[Effects:] [Sets IMAGE_IMPORT_BY_NAME.Hint.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunk equality operator]

  bool operator==(ImportThunk const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same import thunk.]]

[[Throws:] [No.]]

]

[h4 ImportThunk inequality operator]

  bool operator!=(ImportThunk const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different import thunk.]]

[[Throws:] [No.]]

]

[h3 ImportThunkList public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `ImportThunkList` methods when an error occurs.

  typedef unspecified iterator;
  typedef unspecified const_iterator;
  
Iterator type for import thunk list. Models the 
[@http://www.sgi.com/tech/stl/ForwardIterator.html ForwardIterator] concept. 
Implementation type unspecified.

[h3 ImportThunkList public construct/copy/destruct/move]

[h4 ImportThunkList constructor]

  ImportThunkList(PeFile const& MyPeFile, DWORD FirstThunk);

[variablelist

[[Effects:] [Constructs a `ImportThunkList` instance targetting the PE file 
specified by `MyPeFile` and the first thunk specified by `FirstThunk`.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunkList move constructor]

  ImportThunkList(ImportThunkList&& Other);

[variablelist

[[Effects:] [Constructs a `ImportThunkList` that refers to the same target 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunkList move assignment operator]

  ImportThunkList& operator=(ImportThunkList&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunkList destructor]

  ~ImportThunkList();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 ImportThunkList public member functions]

[h4 ImportThunkList member function `begin`]

  iterator begin();
  const_iterator begin() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for start of import 
thunk list.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunkList member function `end`]

  iterator end();
  const_iterator end() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for off-the-end of 
import thunk list.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunkList member function `cbegin`]

  const_iterator cbegin() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for start of import thunk list.]]

[[Throws:] [Yes.]]

]

[h4 ImportThunkList member function `cend`]

  const_iterator cend() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for off-the-end of import thunk 
list.]]

[[Throws:] [Yes.]]

]

[endsect] [/ ImportDir]

[section:ntheaders NtHeaders]

[h3 Synopsis]

  // In header: <HadesMemory/PeLib/NtHeaders.hpp>

  class NtHeaders
  {
  public:
    class Error : public virtual HadesMemError;

    enum DataDir
    {
      DataDir_Export, 
      DataDir_Import, 
      DataDir_Resource, 
      DataDir_Exception, 
      DataDir_Security, 
      DataDir_BaseReloc, 
      DataDir_Debug, 
      DataDir_Architecture, 
      DataDir_GlobalPTR, 
      DataDir_TLS, 
      DataDir_LoadConfig, 
      DataDir_BoundImport, 
      DataDir_IAT, 
      DataDir_DelayImport, 
      DataDir_COMDescriptor
    };

    explicit NtHeaders(PeFile const& MyPeFile);
      
    NtHeaders(NtHeaders const& Other);
    
    NtHeaders& operator=(NtHeaders const& Other);
    
    NtHeaders(NtHeaders&& Other);
    
    NtHeaders& operator=(NtHeaders&& Other);
    
    ~NtHeaders();

    PVOID GetBase() const;

    bool IsValid() const;

    void EnsureValid() const;

    DWORD GetSignature() const;

    WORD GetMachine() const;

    WORD GetNumberOfSections() const;

    DWORD GetTimeDateStamp() const;

    DWORD GetPointerToSymbolTable() const;

    DWORD GetNumberOfSymbols() const;

    WORD GetSizeOfOptionalHeader() const;

    WORD GetCharacteristics() const;

    WORD GetMagic() const;

    BYTE GetMajorLinkerVersion() const;

    BYTE GetMinorLinkerVersion() const;

    DWORD GetSizeOfCode() const;

    DWORD GetSizeOfInitializedData() const;

    DWORD GetSizeOfUninitializedData() const;

    DWORD GetAddressOfEntryPoint() const;

    DWORD GetBaseOfCode() const;

  #if defined(_M_IX86) 
    DWORD GetBaseOfData() const;
  #endif

    ULONG_PTR GetImageBase() const;

    DWORD GetSectionAlignment() const;

    DWORD GetFileAlignment() const;

    WORD GetMajorOperatingSystemVersion() const;

    WORD GetMinorOperatingSystemVersion() const;

    WORD GetMajorImageVersion() const;

    WORD GetMinorImageVersion() const;

    WORD GetMajorSubsystemVersion() const;

    WORD GetMinorSubsystemVersion() const;

    DWORD GetWin32VersionValue() const;

    DWORD GetSizeOfImage() const;

    DWORD GetSizeOfHeaders() const;

    DWORD GetCheckSum() const;

    WORD GetSubsystem() const;

    WORD GetDllCharacteristics() const;

    ULONG_PTR GetSizeOfStackReserve() const;

    ULONG_PTR GetSizeOfStackCommit() const;

    ULONG_PTR GetSizeOfHeapReserve() const;

    ULONG_PTR GetSizeOfHeapCommit() const;

    DWORD GetLoaderFlags() const;

    DWORD GetNumberOfRvaAndSizes() const;

    DWORD GetDataDirectoryVirtualAddress(DataDir MyDataDir) const;

    DWORD GetDataDirectorySize(DataDir MyDataDir) const;

    void SetSignature(DWORD Signature) const;

    void SetMachine(WORD Machine) const;

    void SetNumberOfSections(WORD NumberOfSections) const;

    void SetTimeDateStamp(DWORD TimeDateStamp) const;

    void SetPointerToSymbolTable(DWORD PointerToSymbolTable) const;

    void SetNumberOfSymbols(DWORD NumberOfSymbols) const;

    void SetSizeOfOptionalHeader(WORD SizeOfOptionalHeader) const;

    void SetCharacteristics(WORD Characteristics) const;

    void SetMagic(WORD Magic) const;

    void SetMajorLinkerVersion(BYTE MajorLinkerVersion) const;

    void SetMinorLinkerVersion(BYTE MinorLinkerVersion) const;

    void SetSizeOfCode(DWORD SizeOfCode) const;

    void SetSizeOfInitializedData(DWORD SizeOfInitializedData) const;

    void SetSizeOfUninitializedData(DWORD SizeOfUninitializedData) const;

    void SetAddressOfEntryPoint(DWORD AddressOfEntryPoint) const;

    void SetBaseOfCode(DWORD BaseOfCode) const;

  #if defined(_M_IX86) 
    void SetBaseOfData(DWORD BaseOfData) const;
  #endif

    void SetImageBase(ULONG_PTR ImageBase) const;

    void SetSectionAlignment(DWORD SectionAlignment) const;

    void SetFileAlignment(DWORD FileAlignment) const;

    void SetMajorOperatingSystemVersion(
      WORD MajorOperatingSystemVersion) const;

    void SetMinorOperatingSystemVersion(
      WORD MinorOperatingSystemVersion) const;

    void SetMajorImageVersion(WORD MajorImageVersion) const;

    void SetMinorImageVersion(WORD MinorImageVersion) const;

    void SetMajorSubsystemVersion(WORD MajorSubsystemVersion) const;

    void SetMinorSubsystemVersion(WORD MinorSubsystemVersion) const;

    void SetWin32VersionValue(DWORD Win32VersionValue) const;
    
    void SetSizeOfImage(DWORD SizeOfImage) const;

    void SetSizeOfHeaders(DWORD SizeOfHeaders) const;

    void SetCheckSum(DWORD CheckSum) const;

    void SetSubsystem(WORD Subsystem) const;

    void SetDllCharacteristics(WORD DllCharacteristics) const;

    void SetSizeOfStackReserve(ULONG_PTR SizeOfStackReserve) const;

    void SetSizeOfStackCommit(ULONG_PTR SizeOfStackCommit) const;

    void SetSizeOfHeapReserve(ULONG_PTR SizeOfHeapReserve) const;

    void SetSizeOfHeapCommit(ULONG_PTR SizeOfHeapCommit) const;

    void SetLoaderFlags(DWORD LoaderFlags) const;

    void SetNumberOfRvaAndSizes(DWORD NumberOfRvaAndSizes) const;

    void SetDataDirectoryVirtualAddress(DataDir MyDataDir, 
      DWORD DataDirectoryVirtualAddress) const;

    void SetDataDirectorySize(DataDir MyDataDir, 
      DWORD DataDirectorySize) const;
    
    bool operator==(NtHeaders const& Rhs) const;
    
    bool operator!=(NtHeaders const& Rhs) const;
  };

[h3 Description]

The `NtHeaders` class provides functionality for working with the NT headers 
of a PE file.

See the [@http://msdn.microsoft.com/en-us/windows/hardware/gg463119 PE and 
COFF Specification] for more information on working with the PE file format.

[h3 NtHeaders public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `DosHeader` methods when an error occurs.

  enum DataDir;

Data directories as specified by Microsoft.

[h3 NtHeaders public construct/copy/destruct/move]

[h4 NtHeaders constructor]

  NtHeaders(PeFile const& MyPeFile);

[variablelist

[[Effects:] [Constructs a `NtHeaders` instance that refers to the specified 
PE file.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders copy constructor]

  NtHeaders(NtHeaders const& Other);

[variablelist

[[Effects:] [Constructs a `NtHeaders` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders copy assignment operator]

  NtHeaders& operator=(NtHeaders const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders move constructor]

  NtHeaders(NtHeaders&& Other);

[variablelist

[[Effects:] [Constructs a `DosHeader` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders move assignment operator]

  NtHeaders& operator=(NtHeaders&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders destructor]

  ~NtHeaders();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 NtHeaders public member functions]

[h4 NtHeaders member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of NT headers.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `IsValid`]

  bool IsValid() const;

[variablelist

[[Returns:] [Whether the target is a valid NT headers.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `EnsureValid`]

  void EnsureValid() const;

[variablelist

[[Effects:] [Throw if the target is an invalid NT headers.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSignature`]

  DWORD GetSignature() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.Signature.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMachine`]

  WORD GetMachine() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.FileHeader.Machine.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetNumberOfSections`]

  WORD GetNumberOfSections() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.FileHeader.NumberOfSections.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetTimeDateStamp`]

  DWORD GetTimeDateStamp() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.FileHeader.TimeDateStamp.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetPointerToSymbolTable`]

  DWORD GetPointerToSymbolTable() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.FileHeader.PointerToSymbolTable.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetNumberOfSymbols`]

  DWORD GetNumberOfSymbols() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.FileHeader.NumberOfSymbols.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfOptionalHeader`]

  WORD GetSizeOfOptionalHeader() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.FileHeader.SizeOfOptionalHeader.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetCharacteristics`]

  WORD GetCharacteristics() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.FileHeader.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMagic`]

  WORD GetMagic() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.Magic.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMajorLinkerVersion`]

  BYTE GetMajorLinkerVersion() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.MajorLinkerVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMinorLinkerVersion`]

  BYTE GetMinorLinkerVersion() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.MinorLinkerVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfCode`]

  DWORD GetSizeOfCode() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SizeOfCode.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfInitializedData`]

  DWORD GetSizeOfInitializedData() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SizeOfInitializedData.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfUninitializedData`]

  DWORD GetSizeOfUninitializedData() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SizeOfUninitializedData.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetAddressOfEntryPoint`]

  DWORD GetAddressOfEntryPoint() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetBaseOfCode`]

  DWORD GetBaseOfCode() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.BaseOfCode.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetBaseOfData`]

  DWORD GetBaseOfData() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.BaseOfData.]]

[[Notes:] [Available only under IA32.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetImageBase`]

  ULONG_PTR GetImageBase() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.ImageBase.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSectionAlignment`]

  DWORD GetSectionAlignment() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SectionAlignment.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetFileAlignment`]

  DWORD GetFileAlignment() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.FileAlignment.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMajorOperatingSystemVersion`]

  WORD GetMajorOperatingSystemVersion() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.MajorOperatingSystemVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMinorOperatingSystemVersion`]

  WORD GetMinorOperatingSystemVersion() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.MinorOperatingSystemVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMajorImageVersion`]

  WORD GetMajorImageVersion() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.MajorImageVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMinorImageVersion`]

  WORD GetMinorImageVersion() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.MinorImageVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMajorSubsystemVersion`]

  WORD GetMajorSubsystemVersion() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.MajorSubsystemVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetMinorSubsystemVersion`]

  WORD GetMinorSubsystemVersion() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.MinorSubsystemVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetWin32VersionValue`]

  DWORD GetWin32VersionValue() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.Win32VersionValue.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfImage`]

  DWORD GetSizeOfImage() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfHeaders`]

  DWORD GetSizeOfHeaders() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetCheckSum`]

  DWORD GetCheckSum() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.CheckSum.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSubsystem`]

  WORD GetSubsystem() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.Subsystem.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetDllCharacteristics`]

  WORD GetDllCharacteristics() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfStackReserve`]

  ULONG_PTR GetSizeOfStackReserve() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SizeOfStackReserve.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfStackCommit`]

  ULONG_PTR GetSizeOfStackCommit() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SizeOfStackCommit.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfHeapReserve`]

  ULONG_PTR GetSizeOfHeapReserve() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeapReserve.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetSizeOfHeapCommit`]

  ULONG_PTR GetSizeOfHeapCommit() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeapCommit.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetLoaderFlags`]

  DWORD GetLoaderFlags() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.LoaderFlags.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetNumberOfRvaAndSizes`]

  DWORD GetNumberOfRvaAndSizes() const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.NumberOfRvaAndSizes.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetDataDirectoryVirtualAddress`]

  DWORD GetDataDirectoryVirtualAddress(DataDir MyDataDir) const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.DataDirectory\[MyDataDir\]
.VirtualAddress.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `GetDataDirectorySize`]

  DWORD GetDataDirectorySize(DataDir MyDataDir) const;

[variablelist

[[Returns:] [IMAGE_NT_HEADERS.OptionalHeader.DataDirectory\[MyDataDir\]
.Size.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSignature`]

  void SetSignature(DWORD Signature) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.Signature.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMachine`]

  void SetMachine(WORD Machine) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.FileHeader.Machine.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetNumberOfSections`]

  void SetNumberOfSections(WORD NumberOfSections) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.FileHeader.NumberOfSections.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetTimeDateStamp`]

  void SetTimeDateStamp(DWORD TimeDateStamp) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.FileHeader.TimeDateStamp.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetPointerToSymbolTable`]

  void SetPointerToSymbolTable(DWORD PointerToSymbolTable) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.FileHeader.PointerToSymbolTable.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetNumberOfSymbols`]

  void SetNumberOfSymbols(DWORD NumberOfSymbols) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.FileHeader.NumberOfSymbols.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfOptionalHeader`]

  void SetSizeOfOptionalHeader(WORD SizeOfOptionalHeader) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.FileHeader.SizeOfOptionalHeader.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetCharacteristics`]

  void SetCharacteristics(WORD Characteristics) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.FileHeader.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMagic`]

  void SetMagic(WORD Magic) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.Magic.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMajorLinkerVersion`]

  void SetMajorLinkerVersion(BYTE MajorLinkerVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.MajorLinkerVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMinorLinkerVersion`]

  void SetMinorLinkerVersion(BYTE MinorLinkerVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.MinorLinkerVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfCode`]

  void SetSizeOfCode(DWORD SizeOfCode) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SizeOfCode.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfInitializedData`]

  void SetSizeOfInitializedData(DWORD SizeOfInitializedData) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SizeOfInitializedData.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfUninitializedData`]

  void SetSizeOfUninitializedData(DWORD SizeOfUninitializedData) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SizeOfUninitializedData.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetAddressOfEntryPoint`]

  void SetAddressOfEntryPoint(DWORD AddressOfEntryPoint) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetBaseOfCode`]

  void SetBaseOfCode(DWORD BaseOfCode) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.BaseOfCode.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetBaseOfData`]

  void SetBaseOfData(DWORD BaseOfData) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.BaseOfData.]]

[[Notes:] [Available only under IA32.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetImageBase`]

  void SetImageBase(ULONG_PTR ImageBase) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.ImageBase.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSectionAlignment`]

  void SetSectionAlignment(DWORD SectionAlignment) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SectionAlignment.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetFileAlignment`]

  void SetFileAlignment(DWORD FileAlignment) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.FileAlignment.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMajorOperatingSystemVersion`]

  void SetMajorOperatingSystemVersion(
      WORD MajorOperatingSystemVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.MajorOperatingSystemVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMinorOperatingSystemVersion`]

  void SetMinorOperatingSystemVersion(
      WORD MinorOperatingSystemVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.MinorOperatingSystemVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMajorImageVersion`]

  void SetMajorImageVersion(WORD MajorImageVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.MajorImageVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMinorImageVersion`]

  void SetMinorImageVersion(WORD MinorImageVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.MinorImageVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMajorSubsystemVersion`]

  void SetMajorSubsystemVersion(WORD MajorSubsystemVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.MajorSubsystemVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetMinorSubsystemVersion`]

  void SetMinorSubsystemVersion(WORD MinorSubsystemVersion) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.MinorSubsystemVersion.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetWin32VersionValue`]

  void SetWin32VersionValue(DWORD Win32VersionValue) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.Win32VersionValue.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfImage`]

  void SetSizeOfImage(DWORD SizeOfImage) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfHeaders`]

  void SetSizeOfHeaders(DWORD SizeOfHeaders) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeaders.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetCheckSum`]

  void SetCheckSum(DWORD CheckSum) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.CheckSum.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSubsystem`]

  void SetSubsystem(WORD Subsystem) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.Subsystem.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetDllCharacteristics`]

  void SetDllCharacteristics(WORD DllCharacteristics) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfStackReserve`]

  void SetSizeOfStackReserve(ULONG_PTR SizeOfStackReserve) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SizeOfStackReserve.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfStackCommit`]

  void SetSizeOfStackCommit(ULONG_PTR SizeOfStackCommit) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SizeOfStackCommit.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfHeapReserve`]

  void SetSizeOfHeapReserve(ULONG_PTR SizeOfHeapReserve) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeapReserve.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetSizeOfHeapCommit`]

  void SetSizeOfHeapCommit(ULONG_PTR SizeOfHeapCommit) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.SizeOfHeapCommit.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetLoaderFlags`]

  void SetLoaderFlags(DWORD LoaderFlags) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.LoaderFlags.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetNumberOfRvaAndSizes`]

  void SetNumberOfRvaAndSizes(DWORD NumberOfRvaAndSizes) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.NumberOfRvaAndSizes.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetDataDirectoryVirtualAddress`]

  void SetDataDirectoryVirtualAddress(DataDir MyDataDir, 
      DWORD DataDirectoryVirtualAddress) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.DataDirectory\[MyDataDir\]
.VirtualAddress.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders member function `SetDataDirectorySize`]

  void SetDataDirectorySize(DataDir MyDataDir, 
      DWORD DataDirectorySize) const;

[variablelist

[[Effects:] [Sets IMAGE_NT_HEADERS.OptionalHeader.DataDirectory\[MyDataDir\]
.Size.]]

[[Throws:] [Yes.]]

]

[h4 NtHeaders equality operator]

  bool operator==(NtHeaders const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same target.]]

[[Throws:] [No.]]

]

[h4 NtHeaders inequality operator]

  bool operator!=(NtHeaders const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different target.]]

[[Throws:] [No.]]

]

[endsect] [/ NtHeaders]

[section:pefile PeFile]

[h3 Synopsis]

  // In header: <HadesMemory/PeLib/PeFile.hpp>

  class PeFile
  {
  public:
    class Error : public virtual HadesMemError;

    enum FileType
    {
      FileType_Image, 
      FileType_Data
    };

    PeFile(MemoryMgr const& MyMemory, PVOID Address, 
      FileType Type = FileType_Image);
      
    PeFile(PeFile const& Other);
    
    PeFile& operator=(PeFile const& Other);
    
    PeFile(PeFile&& Other);
    
    PeFile& operator=(PeFile&& Other);
    
    ~PeFile();

    MemoryMgr GetMemoryMgr() const;

    PVOID GetBase() const;

    PVOID RvaToVa(DWORD Rva) const;

    FileType GetType() const;
    
    bool operator==(PeFile const& Rhs) const;
    
    bool operator!=(PeFile const& Rhs) const;
  };

[h3 Description]

The PeFile class provides the most basic PE file manipulation functionality, 
and is the basis on which all other PeLib components in HadesMem are built.

[h3 PeFile public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `PeFile` methods when an error occurs.

  enum FileType;

PE file 'type', specifying how the PE file is mapped in memory. Affects RVA to 
VA conversions.

* FileType_Image - PE file is mapped as an image (e.g. by 
[@http://msdn.microsoft.com/en-us/library/ms684175.aspx LoadLibrary]).
* FileType_Data - PE file is mapped as data (e.g. in it's original on-disk 
representation).

[h3 PeFile public construct/copy/destruct/move]

[h4 PeFile constructor]

  PeFile(MemoryMgr const& MyMemory, PVOID Address, 
      FileType Type = FileType_Image);

[variablelist

[[Effects:] [Constructs a `PeFile` instance that refers to the specified 
target.]]

[[Throws:] [Yes.]]

]

[h4 PeFile copy constructor]

  PeFile(PeFile const& Other);

[variablelist

[[Effects:] [Constructs a `PeFile` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 PeFile copy assignment operator]

  PeFile& operator=(PeFile const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 PeFile move constructor]

  PeFile(PeFile&& Other);

[variablelist

[[Effects:] [Constructs a `PeFile` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 PeFile move assignment operator]

  PeFile& operator=(PeFile&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 PeFile destructor]

  ~PeFile();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 PeFile public member functions]

[h4 PeFile member function `GetMemoryMgr`]

  MemoryMgr GetMemoryMgr() const;

[variablelist

[[Returns:] [MemoryMgr instance associated with the object.]]

[[Throws:] [Yes.]]

]

[h4 PeFile member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of PE file.]]

[[Throws:] [Yes.]]

]

[h4 PeFile member function `RvaToVa`]

  PVOID RvaToVa(DWORD Rva) const;

[variablelist

[[Returns:] [Virtual address corresponding to the relative virtual address 
`Rva`.]]

[[Throws:] [Yes.]]

]

[h4 PeFile member function `GetType`]

  FileType GetType() const;

[variablelist

[[Returns:] ['Type' of PE file.]]

[[Throws:] [Yes.]]

]

[h4 PeFile equality operator]

  bool operator==(PeFile const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same target.]]

[[Throws:] [No.]]

]

[h4 PeFile inequality operator]

  bool operator!=(PeFile const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different target.]]

[[Throws:] [No.]]

]

[endsect] [/ PeFile]

[section:section Section]

[h3 Synopsis]

  // In header: <HadesMemory/PeLib/Section.hpp>
  
  class Section
  {
  public:
    class Error : public virtual HadesMemError;
    
    Section(PeFile const& MyPeFile, WORD Number);
    
    Section(Section const& Other);
    
    Section& operator=(Section const& Other);
    
    Section(Section&& Other);
    
    Section& operator=(Section&& Other);
    
    ~Section();
    
    PVOID GetBase() const;
    
    WORD GetNumber() const;
    
    std::string GetName() const;
    
    DWORD GetVirtualAddress() const;
    
    DWORD GetVirtualSize() const;
    
    DWORD GetSizeOfRawData() const;
    
    DWORD GetPointerToRawData() const;
    
    DWORD GetPointerToRelocations() const;
    
    DWORD GetPointerToLinenumbers() const;
    
    WORD GetNumberOfRelocations() const;
    
    WORD GetNumberOfLinenumbers() const;
    
    DWORD GetCharacteristics() const;
    
    void SetName(std::string const& Name) const;
    
    void SetVirtualAddress(DWORD VirtualAddress) const;

    void SetVirtualSize(DWORD VirtualSize) const;

    void SetSizeOfRawData(DWORD SizeOfRawData) const;

    void SetPointerToRawData(DWORD PointerToRawData) const;

    void SetPointerToRelocations(DWORD PointerToRelocations) const;

    void SetPointerToLinenumbers(DWORD PointerToLinenumbers) const;

    void SetNumberOfRelocations(WORD NumberOfRelocations) const;

    void SetNumberOfLinenumbers(WORD NumberOfLinenumbers) const;

    void SetCharacteristics(DWORD Characteristics) const;
    
    bool operator==(Section const& Rhs) const;
    
    bool operator!=(Section const& Rhs) const;
  };
  
  class SectionList
  {
  public:
    class Error : public virtual HadesMemError;
    
    typedef unspecified iterator;
    typedef unspecified const_iterator;
    
    explicit SectionList(PeFile const& MyPeFile);
    
    SectionList(SectionList&& Other);
    
    SectionList& operator=(SectionList&& Other);
    
    iterator begin();
    
    iterator end();
    
    const_iterator begin() const;
     
    const_iterator end() const;
    
    const_iterator cbegin() const;
     
    const_iterator cend() const;
  };

[h3 Description]

The `Section` class provides functionality for working with the sections of a 
PE file.

See the [@http://msdn.microsoft.com/en-us/windows/hardware/gg463119 PE and 
COFF Specification] for more information on working with the PE file format.

The `SectionList` class provides STL-compatible iterators for section  
enumeration.

[h3 Section public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `Section` methods when an error occurs.

[h3 Section public construct/copy/destruct/move]

[h4 Section constructor]

  Section(PeFile const& MyPeFile, WORD Number);

[variablelist

[[Effects:] [Constructs a `Section` instance that refers to section number 
`Number` in the PE file.]]

[[Throws:] [Yes.]]

]

[h4 Section copy constructor]

  Section(Section const& Other);

[variablelist

[[Effects:] [Constructs a `Section` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 Section copy assignment operator]

  Section& operator=(Section const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 Section move constructor]

  Section(Section&& Other);

[variablelist

[[Effects:] [Constructs a `Section` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Section move assignment operator]

  Section& operator=(Section&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 Section destructor]

  ~Section();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 Section public member functions]

[h4 Section member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of section header.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetNumber`]

  WORD GetNumber() const;

[variablelist

[[Returns:] [Section number.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetName`]

  std::string GetName() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.Name.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetVirtualAddress`]

  DWORD GetVirtualAddress() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.VirtualAddress.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetVirtualSize`]

  DWORD GetVirtualSize() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.Misc.VirtualSize.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetSizeOfRawData`]

  DWORD GetSizeOfRawData() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.SizeOfRawData.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetPointerToRawData`]

  DWORD GetPointerToRawData() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.PointerToRawData.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetPointerToRelocations`]

  DWORD GetPointerToRelocations() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.PointerToRelocations.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetPointerToLinenumbers`]

  DWORD GetPointerToLinenumbers() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.PointerToLinenumbers.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetNumberOfRelocations`]

  WORD GetNumberOfRelocations() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.NumberOfRelocations.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetNumberOfLinenumbers`]

  WORD GetNumberOfLinenumbers() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.NumberOfLinenumbers.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `GetCharacteristics`]

  DWORD GetCharacteristics() const;

[variablelist

[[Returns:] [IMAGE_SECTION_HEADER.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetName`]

  void SetName(std::string const& Name) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.Name.]]

[[Notes:] [Maximum string length is 8-characters.]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetVirtualAddress`]

  void SetVirtualAddress(DWORD VirtualAddress) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.VirtualAddress.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetVirtualSize`]

  void SetVirtualSize(DWORD VirtualSize) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.Misc.VirtualSize.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetSizeOfRawData`]

  void SetSizeOfRawData(DWORD SizeOfRawData) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.SizeOfRawData.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetPointerToRawData`]

  void SetPointerToRawData(DWORD PointerToRawData) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.PointerToRawData.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetPointerToRelocations`]

  void SetPointerToRelocations(DWORD PointerToRelocations) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.PointerToRelocations.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetPointerToLinenumbers`]

  void SetPointerToLinenumbers(DWORD PointerToLinenumbers) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.PointerToLinenumbers.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetNumberOfRelocations`]

  void SetNumberOfRelocations(WORD NumberOfRelocations) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.NumberOfRelocations.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetNumberOfLinenumbers`]

  void SetNumberOfLinenumbers(WORD NumberOfLinenumbers) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.NumberOfLinenumbers.]]

[[Throws:] [Yes.]]

]

[h4 Section member function `SetCharacteristics`]

  void SetCharacteristics(DWORD Characteristics) const;

[variablelist

[[Effects:] [Sets IMAGE_SECTION_HEADER.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 Section equality operator]

  bool operator==(Section const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same section.]]

[[Throws:] [No.]]

]

[h4 Section inequality operator]

  bool operator!=(Section const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different section.]]

[[Throws:] [No.]]

]

[h3 SectionList public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `SectionList` methods when an error occurs.

  typedef unspecified iterator;
  typedef unspecified const_iterator;
  
Iterator type for section list. Models the 
[@http://www.sgi.com/tech/stl/ForwardIterator.html ForwardIterator] concept. 
Implementation type unspecified.

[h3 SectionList public construct/copy/destruct/move]

[h4 SectionList constructor]

  explicit SectionList(PeFile const& MyPeFile);

[variablelist

[[Effects:] [Constructs a `SectionList` instance targetting the PE file 
specified by `MyPeFile`.]]

[[Throws:] [Yes.]]

]

[h4 SectionList move constructor]

  SectionList(SectionList&& Other);

[variablelist

[[Effects:] [Constructs a `SectionList` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 SectionList move assignment operator]

  SectionList& operator=(SectionList&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 SectionList destructor]

  ~SectionList();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 SectionList public member functions]

[h4 SectionList member function `begin`]

  iterator begin();
  const_iterator begin() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for start of section 
list.]]

[[Throws:] [Yes.]]

]

[h4 SectionList member function `end`]

  iterator end();
  const_iterator end() const;

[variablelist

[[Returns:] [STL-compatible iterator or const_iterator for off-the-end of 
section list.]]

[[Throws:] [Yes.]]

]

[h4 SectionList member function `cbegin`]

  const_iterator cbegin() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for start of section list.]]

[[Throws:] [Yes.]]

]

[h4 SectionList member function `cend`]

  const_iterator cend() const;

[variablelist

[[Returns:] [STL-compatible const_iterator for off-the-end of section list.]]

[[Throws:] [Yes.]]

]

[endsect] [/ Section]

[section:tlsdir TlsDir]

[h3 Synopsis]

  // In header: <HadesMemory/PeLib/Section.hpp>
  
  class TlsDir
  {
  public:
    class Error : public virtual HadesMemError;

    explicit TlsDir(PeFile const& MyPeFile);
      
    TlsDir(TlsDir const& Other);
    
    TlsDir& operator=(TlsDir const& Other);
    
    TlsDir(TlsDir&& Other);
    
    TlsDir& operator=(TlsDir&& Other);
    
    ~TlsDir();

    PVOID GetBase() const;

    bool IsValid() const;

    void EnsureValid() const;

    DWORD_PTR GetStartAddressOfRawData() const;

    DWORD_PTR GetEndAddressOfRawData() const;

    DWORD_PTR GetAddressOfIndex() const;

    DWORD_PTR GetAddressOfCallBacks() const;

    DWORD GetSizeOfZeroFill() const;

    DWORD GetCharacteristics() const;

    void SetStartAddressOfRawData(DWORD_PTR StartAddressOfRawData) const;

    void SetEndAddressOfRawData(DWORD_PTR EndAddressOfRawData) const;

    void SetAddressOfIndex(DWORD_PTR AddressOfIndex) const;

    void SetAddressOfCallBacks(DWORD_PTR AddressOfCallbacks) const;

    void SetSizeOfZeroFill(DWORD SizeOfZeroFill) const;

    void SetCharacteristics(DWORD Characteristics) const;

    std::vector<PIMAGE_TLS_CALLBACK> GetCallbacks() const;
      
    // Todo: SetCallbacks function
    
    bool operator==(TlsDir const& Rhs) const;
    
    bool operator!=(TlsDir const& Rhs) const;
  };

[h3 Description]

The `TlsDir` class provides functionality for working with the TLS dir of a 
PE file.

See the [@http://msdn.microsoft.com/en-us/windows/hardware/gg463119 PE and 
COFF Specification] for more information on working with the PE file format.

[h3 TlsDir public types]

  class Error : public virtual HadesMemError;
  
Exception type thrown by `TlsDir` methods when an error occurs.

[h3 TlsDir public construct/copy/destruct/move]

[h4 TlsDir constructor]

  TlsDir(PeFile const& MyPeFile);

[variablelist

[[Effects:] [Constructs a `TlsDir` instance that refers to the specified PE 
file.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir copy constructor]

  TlsDir(TlsDir const& Other);

[variablelist

[[Effects:] [Constructs a `TlsDir` that refers to the same target as 
`Other`.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir copy assignment operator]

  TlsDir& operator=(TlsDir const& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as the other instance.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir move constructor]

  TlsDir(Section&& Other);

[variablelist

[[Effects:] [Constructs a `TlsDir` that refers to the same target as 
`Other` via move semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir move assignment operator]

  TlsDir& operator=(TlsDir&& Other);

[variablelist

[[Effects:] [Sets self to refer to the same target as `Other` via move 
semantics. Invalidates `Other`.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir destructor]

  ~TlsDir();

[variablelist

[[Effects:] [Destroys the instance and frees all resources.]]

[[Throws:] [No.]]

]

[h3 TlsDir public member functions]

[h4 TlsDir member function `GetBase`]

  PVOID GetBase() const;

[variablelist

[[Returns:] [Base address of TLS dir.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `IsValid`]

  bool IsValid() const;

[variablelist

[[Returns:] [Whether the target is a valid TLS dir.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `EnsureValid`]

  void EnsureValid() const;

[variablelist

[[Effects:] [Throw if the target is an invalid TLS dir.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `GetStartAddressOfRawData`]

  DWORD_PTR GetStartAddressOfRawData() const;

[variablelist

[[Returns:] [IMAGE_TLS_DIRECTORY.StartAddressOfRawData.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `GetEndAddressOfRawData`]

  DWORD_PTR GetEndAddressOfRawData() const;

[variablelist

[[Returns:] [IMAGE_TLS_DIRECTORY.EndAddressOfRawData.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `GetAddressOfIndex`]

  DWORD_PTR GetAddressOfIndex() const;

[variablelist

[[Returns:] [IMAGE_TLS_DIRECTORY.AddressOfIndex(.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `GetAddressOfCallBacks`]

  DWORD_PTR GetAddressOfCallBacks() const;

[variablelist

[[Returns:] [IMAGE_TLS_DIRECTORY.AddressOfCallBacks.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `GetSizeOfZeroFill`]

  DWORD GetSizeOfZeroFill() const;

[variablelist

[[Returns:] [IMAGE_TLS_DIRECTORY.SizeOfZeroFill.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `GetCharacteristics`]

  DWORD GetCharacteristics() const;

[variablelist

[[Returns:] [IMAGE_TLS_DIRECTORY.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `GetCallbacks`]

  std::vector<PIMAGE_TLS_CALLBACK> GetCallbacks() const;

[variablelist

[[Returns:] [Callback list from IMAGE_TLS_DIRECTORY.AddressOfCallbacks.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `SetStartAddressOfRawData`]

  void SetStartAddressOfRawData(DWORD_PTR StartAddressOfRawData) const;

[variablelist

[[Effects:] [Sets IMAGE_TLS_DIRECTORY.StartAddressOfRawData.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `SetEndAddressOfRawData`]

  void SetEndAddressOfRawData(DWORD_PTR EndAddressOfRawData) const;

[variablelist

[[Effects:] [Sets IMAGE_TLS_DIRECTORY.EndAddressOfRawData.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `SetAddressOfIndex`]

  void SetAddressOfIndex(DWORD_PTR AddressOfIndex) const;

[variablelist

[[Effects:] [Sets IMAGE_TLS_DIRECTORY.AddressOfIndex.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `SetAddressOfCallBacks`]

  void SetAddressOfCallBacks(DWORD_PTR AddressOfCallbacks) const;

[variablelist

[[Effects:] [Sets IMAGE_TLS_DIRECTORY.AddressOfCallbacks.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `SetSizeOfZeroFill`]

  void SetSizeOfZeroFill(DWORD SizeOfZeroFill) const;

[variablelist

[[Effects:] [Sets IMAGE_TLS_DIRECTORY.SizeOfZeroFill.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir member function `SetCharacteristics`]

  void SetCharacteristics(DWORD Characteristics) const;

[variablelist

[[Effects:] [Sets IMAGE_TLS_DIRECTORY.Characteristics.]]

[[Throws:] [Yes.]]

]

[h4 TlsDir equality operator]

  bool operator==(TlsDir const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets the same TLS dir.]]

[[Throws:] [No.]]

]

[h4 TlsDir inequality operator]

  bool operator!=(TlsDir const& Rhs) const;

[variablelist

[[Returns:] [Whether `Rhs` represets a different TLS dir.]]

[[Throws:] [No.]]

]

[endsect] [/ TlsDir]

[endsect] [/ PeLib]

[section:experimental Experimental]

[endsect] [/ Experimental]

[endsect] [/ Reference]

[section:acknowledge Acknowledgements]

HadesMem would not be possible without the help of the following 
projects/people:

* [@http://code.google.com/p/asmjit/ AsmJit] - C++ Library
* [@http://www.beaengine.org/ BeaEngine] - C Library
* [@http://www.boost.org/ Boost] - C++ Libraries
* [@http://www.mmowned.com/forums/members/299012-xel.html Xel @ MMOwned] - Logo
* [@http://www.mmowned.com/ MMOwned] - Reverse Engineering and Programming 
Resource
* [@http://www.gamedeception.net/ Game Deception] - Reverse Engineering and 
Programming Resource

[endsect] [/ Acknowledgements]
